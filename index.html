<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF Image Extractor ‚Äì Single-File (Offline)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0b0d10;
    --card: #12161c;
    --muted: #9fb0c0;
    --text: #e8eef5;
    --accent: #61dafb;
    --ok: #3ddc97;
    --warn: #ffcc66;
    --danger: #ff6b6b;
    --border: #273240;
  }
  :root.light {
    --bg: #f7f9fc;
    --card: #ffffff;
    --muted: #5a6a7a;
    --text: #0b0d10;
    --accent: #0077ff;
    --ok: #1a8e5f;
    --warn: #b8860b;
    --danger: #b00020;
    --border: #d8e0ea;
  }
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
  }
  header {
    position: sticky; top: 0; z-index: 10;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
  h1 { font-size: 20px; margin: 0 0 8px 0; letter-spacing: 0.3px; }
  .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .spacer { flex: 1; }

  /* Buttons */
  .btn, button, .toggle {
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 10px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    transition: transform .06s ease, background .2s ease, border .2s ease;
    user-select: none; text-decoration: none;
    outline: none; box-shadow: none; -webkit-tap-highlight-color: transparent;
  }
  .btn:hover, button:hover { transform: translateY(-1px); }
  button.primary { background: linear-gradient(180deg, var(--accent), #2aa3d6); color: #001218; border-color: transparent; }
  button.success { background: linear-gradient(180deg, var(--ok), #2dad78); color: #001b11; border-color: transparent; }
  button.warn { background: linear-gradient(180deg, var(--warn), #d7a13c); color: #2d1f00; border-color: transparent; }
  button:focus, button:active, .btn:focus, .btn:active { outline: none !important; box-shadow: none !important; }

  input[type="file"] { display:none; }
  .hint { color: var(--muted); font-size: 12px; margin-top: -4px; }

  .panel {
    background: var(--card); border: 1px solid var(--border);
    border-radius: 16px; padding: 14px;
  }
  .progress {
    height: 12px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; border: 1px solid var(--border);
  }
  .bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--accent), #9bffd6); transition: width .15s ease; }
  .statline { display: flex; gap: 10px; align-items:center; font-size: 13px; color: var(--muted); }

  .grid {
    display: grid; gap: 14px;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  }
  .card {
    background: var(--card); border: 1px solid var(--border); border-radius: 16px; overflow: hidden;
    display: flex; flex-direction: column;
  }
  .thumb {
    display: block; width: 100%; max-height: 200px; object-fit: contain; background: rgba(0,0,0,0.12);
  }
  .meta { padding: 10px 12px; display: grid; gap: 6px; font-size: 13px; }
  .meta .row { justify-content: space-between; }

  .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
  .tooltip { position: relative; display: inline-block; }
  .tooltip:hover::after {
    content: attr(data-tip);
    position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 8px 10px; border-radius: 10px; min-width: 180px; max-width: 260px;
    box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    white-space: normal; pointer-events: none; z-index: 20; font-size: 12px;
  }
  .empty {
    padding: 24px; text-align: center; color: var(--muted); border: 1px dashed var(--border); border-radius: 16px;
  }
  .small { font-size: 12px; color: var(--muted); }
  .ok { color: var(--ok); }

  .toggle { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; font-weight: 600; }
  .toggle input { width: 0; height: 0; appearance: none; }
  .pill {
    width: 44px; height: 24px; background: rgba(255,255,255,0.12); border-radius: 999px; position: relative; border: 1px solid var(--border);
  }
  .dot { position: absolute; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; border-radius: 50%; background: var(--text); left: 3px; transition: left .15s ease; }
  .toggle input:checked + .pill .dot { left: 23px; }

  .footer-note { margin-top: 30px; font-size: 12px; color: var(--muted); }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor</h1>
        <div class="hint">Single-file, offline. Extracts embedded images as high-quality PNG with sort, preview, and selective ZIP download.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark mode">
        <span>Light</span>
        <input id="themeToggle" type="checkbox" />
        <span class="pill"><span class="dot"></span></span>
        <span>Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex; flex-direction: column; gap: 16px;">

  <section class="panel">
    <div class="row" style="gap: 8px; align-items:center;">
      <label for="fileInput" class="btn tooltip" data-tip="Choose a PDF from your computer (processed 100% locally).">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf"/>

      <button id="startBtn" class="primary tooltip" disabled data-tip="Starts extraction. Processing progress shown below.">‚ñ∂Ô∏è Start Processing</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <div class="tooltip" data-tip="Default sorts by pixel area (width√óheight), largest first. Smart Sort also considers file size and pushes icons/tiny images last.">
        <button id="defaultSortBtn" disabled>Sort: Size (default)</button>
      </div>
      <div class="tooltip" data-tip="Smart Sort pushes probable icons and tiny images last by blending area and MB size against the average.">
        <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>
      </div>

      <button id="downloadSelectedZipBtn" class="success" disabled>Download Selected (ZIP)</button>
      <button id="downloadAllZipBtn" disabled>Download All (ZIP)</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top: 12px; display:grid; gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start Processing</b> to begin.<br/><span class="small">If the PDF has no images, you‚Äôll see a notice.</span></div>
  </section>

  <section class="footer-note">
    <div><b>Notes & Limitations:</b> Extracts embedded images. JPEG is fully supported. PNG/raw (FlateDecode) support includes PNG predictors (10‚Äì15) with /Columns for 8bpc DeviceRGB/DeviceGray. Thumbnails are previews‚Äîdownloads are full-quality PNG.</div>
  </section>

</main>

<script>
/* =============================
   Utility: Theme (Light/Dark)
============================= */
(function initTheme(){
  const root = document.documentElement;
  const toggle = document.getElementById('themeToggle');
  const saved = localStorage.getItem('pdfimg_theme') || 'dark';
  if(saved === 'light'){ root.classList.add('light'); toggle.checked = false; }
  else { root.classList.remove('light'); toggle.checked = true; }
  toggle.addEventListener('change', () => {
    if(toggle.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); }
    else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }
  });
})();
</script>

<script>
/* ===========================================================
   PDF Image Extractor (Single-file, Client-side, Offline)
   Improvements:
   - Uses /Length (resolves indirect) to slice streams safely.
   - Supports filter chains: ASCII85, ASCIIHex, Flate -> DCT/JPX/raw.
   - Handles PNG predictors 10‚Äì15 with /Columns for 8bpc RGB/Gray.
=========================================================== */

const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
};

let state = {
  pdfFile: null,
  pdfNameBase: 'images',
  rawBytes: null,
  text: null,
  objects: [],       // [{obj, gen, content, startIndex, endIndex}]
  objMap: new Map(), // key "obj gen" -> {content, startIndex}
  images: [],        // { id, pngBlob, width, height, mb, name, hashHex, selected, srcObjectUrl }
  removedDuplicates: 0,
  sortMode: 'default',
};

function sanitizeBaseName(name) {
  const base = name.replace(/\.[Pp][Dd][Ff]$/, '');
  let s = base.replace(/[^a-zA-Z0-9_\-]+/g, '_');
  if (s.length > 12) s = s.slice(0, 12);
  if (!s) s = 'images';
  return s.toLowerCase();
}

// File selection
els.fileInput.addEventListener('change', () => {
  const f = els.fileInput.files && els.fileInput.files[0];
  if (!f) return;
  state.pdfFile = f;
  els.pdfName.textContent = f.name;
  state.pdfNameBase = sanitizeBaseName(f.name);
  els.startBtn.disabled = false;
});

// Buttons
els.startBtn.addEventListener('click', async () => {
  if (!state.pdfFile) return;
  resetUIForProcessing();
  try {
    state.rawBytes = new Uint8Array(await state.pdfFile.arrayBuffer());
    state.text = new TextDecoder('latin1').decode(state.rawBytes);

    // Build object index
    indexObjects(state.text);

    updateProgress(0, 'Scanning PDF objects‚Ä¶');
    const items = await extractImagesFromIndexedPDF();
    if (!items.length) {
      showEmpty('No images found in this PDF.');
      finalizeStats();
      return;
    }

    await convertAllToPNGAndDedup(items);
    renderImages();
    enablePostProcessButtons();
    finalizeStats();
  } catch (err) {
    console.error(err);
    showEmpty('Failed to process PDF (corrupt or unsupported).');
    updateProgress(0, 'Error.');
  }
});

els.selectAllBtn.addEventListener('click', () => { for (const it of state.images) it.selected = true; renderImages(); });
els.deselectAllBtn.addEventListener('click', () => { for (const it of state.images) it.selected = false; renderImages(); });
els.defaultSortBtn.addEventListener('click', () => { state.sortMode = 'default'; sortImages(); renderImages(); });
els.smartSortBtn.addEventListener('click', () => { state.sortMode = 'smart'; sortImages(); renderImages(); });

// UI helpers
function resetUIForProcessing(){
  state.images = [];
  state.removedDuplicates = 0;
  state.sortMode = 'default';
  els.gallery.innerHTML = '';
  updateProgress(0, 'Preparing‚Ä¶');
  els.defaultSortBtn.disabled = true;
  els.smartSortBtn.disabled = true;
  els.selectAllBtn.disabled = true;
  els.deselectAllBtn.disabled = true;
  els.downloadSelectedZipBtn.disabled = true;
  els.downloadAllZipBtn.disabled = true;
  els.stats.textContent = '';
}
function enablePostProcessButtons(){
  els.defaultSortBtn.disabled = false;
  els.smartSortBtn.disabled = false;
  els.selectAllBtn.disabled = false;
  els.deselectAllBtn.disabled = false;
  els.downloadSelectedZipBtn.disabled = false;
  els.downloadAllZipBtn.disabled = false;
}
function showEmpty(msg){ els.gallery.innerHTML = `<div class="empty">${msg}</div>`; }
function updateProgress(pct, text){ els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`; els.progressText.textContent = text; }
function finalizeStats(){
  els.stats.innerHTML = `Images: <b>${state.images.length}</b> &nbsp; | &nbsp; Removed duplicates: <b>${state.removedDuplicates}</b>`;
}

// Rendering
function renderImages(){
  sortImages();
  if (!state.images.length) { showEmpty('No images found after processing.'); return; }
  const frag = document.createDocumentFragment();
  for (const it of state.images) frag.appendChild(renderCard(it));
  els.gallery.innerHTML = '';
  els.gallery.appendChild(frag);
}
function renderCard(it){
  const card = document.createElement('div'); card.className = 'card';

  const img = document.createElement('img');
  img.className = 'thumb'; img.src = it.srcObjectUrl; img.alt = it.name; img.loading = 'lazy';
  img.title = 'Click to open full-size in new tab';
  img.addEventListener('click', () => {
    const a = document.createElement('a'); a.href = it.srcObjectUrl; a.target = '_blank'; a.download = it.name; a.click();
  });
  card.appendChild(img);

  const meta = document.createElement('div'); meta.className = 'meta';

  const row1 = document.createElement('div'); row1.className = 'row';
  const label = document.createElement('label'); label.style.display='flex'; label.style.alignItems='center'; label.style.gap='8px';
  const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = !!it.selected;
  const sel = document.createElement('div'); sel.className='small'; sel.innerHTML = it.selected ? `<span class="ok">Selected</span>` : `Not selected`;
  cb.addEventListener('change', ()=>{ it.selected = cb.checked; sel.innerHTML = cb.checked ? `<span class="ok">Selected</span>` : `Not selected`; });
  const bname = document.createElement('span'); bname.className='badge'; bname.textContent = it.name;
  label.appendChild(cb); label.appendChild(bname);

  const dlBtn = document.createElement('button'); dlBtn.textContent = 'Download'; dlBtn.style.padding='6px 10px';
  dlBtn.addEventListener('click', () => { const a = document.createElement('a'); a.href = it.srcObjectUrl; a.download = it.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

  row1.appendChild(label); row1.appendChild(dlBtn); meta.appendChild(row1);

  const row2 = document.createElement('div'); row2.className='row';
  const dims = document.createElement('div'); dims.className='small'; dims.textContent = `Dimensions: ${it.width}√ó${it.height}px`;
  const size = document.createElement('div'); size.className='small'; size.textContent = `Size: ${it.mb.toFixed(2)} MB`;
  row2.appendChild(dims); row2.appendChild(size); meta.appendChild(row2);

  meta.appendChild(sel);
  card.appendChild(meta);
  return card;
}

function sortImages(){
  const arr = state.images; if (!arr.length) return;
  if (state.sortMode === 'default') {
    arr.sort((a,b) => (b.width*b.height) - (a.width*a.height));
  } else {
    const areas = arr.map(i => i.width*i.height);
    const sizes = arr.map(i => i.mb);
    const avgA = (areas.reduce((s,v)=>s+v,0) / areas.length) || 1;
    const avgS = (sizes.reduce((s,v)=>s+v,0) / sizes.length) || 1;
    for (const it of arr) {
      const area = it.width*it.height;
      const wArea = area / avgA;
      const wSize = it.mb / avgS;
      it._smartScore = 0.6*wArea + 0.4*wSize;
    }
    arr.sort((a,b) => (b._smartScore - a._smartScore));
  }
}

/* ============================
   PDF Indexing & Extraction
============================ */
function indexObjects(text){
  state.objects = [];
  state.objMap.clear();
  const reObj = /(\d+)\s+(\d+)\s+obj\b/g;
  let m;
  while ((m = reObj.exec(text)) !== null) {
    const obj = parseInt(m[1],10), gen = parseInt(m[2],10);
    const start = m.index;
    const endObjIdx = text.indexOf('endobj', start);
    if (endObjIdx === -1) break;
    const content = text.slice(m.index, endObjIdx + 'endobj'.length);
    const innerStart = text.indexOf('obj', start) + 3;
    state.objects.push({ obj, gen, content, startIndex: start, endIndex: endObjIdx + 'endobj'.length });
    state.objMap.set(`${obj} ${gen}`, { content, startIndex: start, endIndex: endObjIdx + 'endobj'.length });
    reObj.lastIndex = endObjIdx + 6;
  }
}

function pickLastInt(source, name){
  // Find last /Name <int> in the given source
  const re = new RegExp(`/${name}\\s+(\\d+)`, 'g');
  let m, val = null;
  while ((m = re.exec(source)) !== null) val = parseInt(m[1],10);
  return val;
}
function pickRef(source, name){
  const re = new RegExp(`/${name}\\s+(\\d+)\\s+(\\d+)\\s+R`);
  const m = re.exec(source);
  if (!m) return null;
  return { obj: parseInt(m[1],10), gen: parseInt(m[2],10) };
}
function pickName(source, name){
  const re = new RegExp(`/${name}\\s+/([A-Za-z0-9]+)`);
  const m = re.exec(source);
  return m ? m[1] : null;
}
function pickArrayNames(source, name){
  const re = new RegExp(`/${name}\\s+\\[([^\\]]+)\\]`);
  const m = re.exec(source);
  if (!m) return [];
  return (m[1].match(/\/([A-Za-z0-9]+)/g) || []).map(s => s.slice(1));
}
function getObjectNumericValue(ref){
  if (!ref) return null;
  const obj = state.objMap.get(`${ref.obj} ${ref.gen}`);
  if (!obj) return null;
  const m = obj.content.match(/(\d+)/);
  return m ? parseInt(m[1],10) : null;
}

async function extractImagesFromIndexedPDF(){
  const items = [];
  for (const entry of state.objects) {
    const block = entry.content;
    if (!/\/Subtype\s*\/Image/.test(block)) continue;

    // Dictionary
    const dictMatch = /<<(.*?)>>/s.exec(block);
    if (!dictMatch) continue;
    const dictStr = dictMatch[1];

    const width  = pickLastInt(dictStr, 'Width');
    const height = pickLastInt(dictStr, 'Height');
    const bits   = pickLastInt(dictStr, 'BitsPerComponent') || 8;

    // ColorSpace: simple name only (DeviceRGB/DeviceGray)
    let cs = pickName(dictStr, 'ColorSpace') || 'DeviceRGB';

    // Filters (chain)
    let filters = pickArrayNames(dictStr, 'Filter');
    if (!filters.length) {
      const single = pickName(dictStr, 'Filter');
      if (single) filters = [single];
    }

    // DecodeParms (get last occurrence in case of arrays)
    const predictor = pickLastInt(dictStr, 'Predictor') || 1;
    const colors    = pickLastInt(dictStr, 'Colors') || (cs==='DeviceRGB' ? 3 : 1);
    const columns   = pickLastInt(dictStr, 'Columns') || width;

    // Length (direct or indirect)
    let length = pickLastInt(dictStr, 'Length');
    if (length == null) {
      const lenRef = pickRef(dictStr, 'Length');
      length = getObjectNumericValue(lenRef);
    }

    // Stream start offset (bytes)
    const local = block;
    const dictEndIdx = local.indexOf('>>');
    const streamIdx = local.indexOf('stream', dictEndIdx);
    if (streamIdx === -1) continue;

    let dataStartInBlock = streamIdx + 6;
    if (local[dataStartInBlock] === '\r' && local[dataStartInBlock+1] === '\n') dataStartInBlock += 2;
    else if (local[dataStartInBlock] === '\n') dataStartInBlock += 1;

    // Absolute start index in file
    const absBlockStart = entry.startIndex;
    const absStart = absBlockStart + dataStartInBlock;

    let absEnd;
    if (length != null && Number.isFinite(length) && length >= 0) {
      absEnd = absStart + length;
    } else {
      // Fallback search (less reliable)
      const endRel = local.indexOf('endstream', dataStartInBlock);
      if (endRel === -1) continue;
      absEnd = absBlockStart + endRel;
    }

    // Bounds check
    if (absStart < 0 || absEnd > state.rawBytes.length || absEnd <= absStart) continue;

    const bytes = state.rawBytes.subarray(absStart, absEnd);

    items.push({
      index: items.length + 1,
      width, height, bits, cs,
      filters,
      predictor, colors, columns,
      bytes
    });
  }
  return items;
}

/* =======================================
   Convert to PNG & Deduplicate by SHA256
======================================= */
async function convertAllToPNGAndDedup(items){
  const total = items.length;
  const seen = new Set();
  const results = [];
  const base = state.pdfNameBase;

  for (let i=0;i<total;i++){
    updateProgress(Math.round((i/total)*100), `Processing image ${i+1}/${total}‚Ä¶`);
    const it = items[i];
    try {
      const pngBlob = await convertOneToPNG(it);
      if (!pngBlob) continue;

      const ab = await pngBlob.arrayBuffer();
      const hash = await sha256Hex(new Uint8Array(ab));
      if (seen.has(hash)) { state.removedDuplicates++; continue; }
      seen.add(hash);

      const { w:realW, h:realH } = await getImageSizeFromBlob(pngBlob, it.width, it.height);
      const url = URL.createObjectURL(pngBlob);

      const name = `${base}_img${results.length+1}.png`;
      results.push({
        id: 'img'+(results.length+1),
        pngBlob, hashHex: hash,
        width: realW, height: realH,
        mb: ab.byteLength/(1024*1024),
        name,
        selected: false,
        srcObjectUrl: url
      });
    } catch (e) {
      console.warn('Skipping an image due to error', e);
    }
  }
  updateProgress(100, `Done (${results.length} images).`);
  state.images = results;
}

/* Convert one image object by decoding filter chain */
async function convertOneToPNG(item){
  const { bytes } = item;
  const filters = (item.filters && item.filters.length) ? item.filters.slice() : [];
  if (!filters.length) {
    // No filters: assume raw raster (rare). Try raw path with 8bpc RGB/Gray.
    return rawRasterToPNG(item, bytes);
  }

  // Process chain in order; terminal is DCT/JPX/Flate
  let data = bytes;
  for (let i=0;i<filters.length;i++){
    const f = filters[i];
    if (/^ASCII85Decode$/i.test(f)) {
      data = ascii85DecodeToBytes(data);
      continue;
    }
    if (/^ASCIIHexDecode$/i.test(f)) {
      data = asciiHexDecodeToBytes(data);
      continue;
    }
    if (/^FlateDecode$/i.test(f)) {
      data = await inflateZlib(data);
      // next may be raw raster (terminal) if no further filters
      if (i === filters.length - 1) {
        return rawRasterToPNG(item, data); // use predictor/columns/colors
      }
      continue;
    }
    if (/^DCTDecode$/i.test(f)) {
      // JPEG terminal; previous ASCII85/Hex should have been applied already
      return jpegToPNG(data, item.width, item.height);
    }
    if (/^JPXDecode$/i.test(f)) {
      return jpxToPNG(data, item.width, item.height);
    }
    // Unsupported filter in chain; abort
    console.warn('Unsupported filter in chain:', f);
    return null;
  }

  // If we get here, filters were only ASCII* without terminal; try raw
  return rawRasterToPNG(item, data);
}

async function jpegToPNG(u8, hintW, hintH){
  const blob = new Blob([u8], { type: 'image/jpeg' });
  const { canvas, ctx, img } = await drawToCanvas(blob, hintW, hintH);
  const png = await canvasToPNG(canvas);
  cleanupCanvas(canvas, ctx, img);
  return png;
}
async function jpxToPNG(u8, hintW, hintH){
  const blob = new Blob([u8], { type: 'image/jp2' });
  try {
    const { canvas, ctx, img } = await drawToCanvas(blob, hintW, hintH);
    const png = await canvasToPNG(canvas);
    cleanupCanvas(canvas, ctx, img);
    return png;
  } catch {
    console.warn('JPEG2000 not supported by this browser.');
    return null;
  }
}

async function rawRasterToPNG(item, raw){
  const { width, height, cs, bits, predictor, columns } = item;
  if (!(bits===8 && (cs==='DeviceRGB' || cs==='DeviceGray'))) {
    console.warn('Raw raster unsupported (need 8bpc DeviceRGB/DeviceGray).'); return null;
  }
  const comps = (cs==='DeviceRGB') ? 3 : 1;

  let pixels;
  if (predictor === 1) {
    const expected = width * height * comps;
    if (raw.length !== expected) { console.warn('Raw length mismatch; skipping.'); return null; }
    pixels = raw;
  } else if (predictor >= 10 && predictor <= 15) {
    const rowBytes = columns * comps;
    const stride = 1 + rowBytes;
    if (raw.length !== stride * height) {
      // Try fallback assuming Columns==width
      const altRowBytes = width * comps;
      const altStride = 1 + altRowBytes;
      if (raw.length === altStride * height) {
        pixels = undoPNGPrediction(raw, altRowBytes, height, comps);
      } else {
        console.warn('Predictor size mismatch; skipping.'); return null;
      }
    } else {
      pixels = undoPNGPrediction(raw, rowBytes, height, comps);
    }
  } else {
    console.warn('Unsupported Predictor:', predictor); return null;
  }

  return rawToPNG(pixels, width, height, comps);
}

/* ASCII85 & ASCIIHex decoders */
function ascii85DecodeToBytes(u8){
  const s = new TextDecoder('ascii').decode(u8);
  return ascii85DecodeString(s);
}
function ascii85DecodeString(str){
  // strip delimiters <~ ~> if present; remove whitespace
  const s = str.replace(/<~/g,'').replace(/~>/g,'').replace(/\s+/g,'');
  const out = [];
  let group = [];
  for (let i=0;i<s.length;i++){
    const c = s[i];
    if (c === 'z' && group.length === 0){ out.push(0,0,0,0); continue; }
    const code = c.charCodeAt(0);
    if (code < 33 || code > 117) continue; // skip non-data
    group.push(code - 33);
    if (group.length === 5){
      let v = 0;
      for (let j=0;j<5;j++){ v = v*85 + group[j]; }
      out.push((v>>>24)&255, (v>>>16)&255, (v>>>8)&255, v&255);
      group.length = 0;
    }
  }
  if (group.length > 0){
    for (let k=group.length; k<5; k++) group.push(84); // 'u' => 117-33=84
    let v = 0;
    for (let j=0;j<5;j++){ v = v*85 + group[j]; }
    // emit group.length-1 bytes
    for (let j=0;j<group.length-1;j++){
      out.push((v >>> (24 - 8*j)) & 255);
    }
  }
  return new Uint8Array(out);
}
function asciiHexDecodeToBytes(u8){
  let s = new TextDecoder('ascii').decode(u8);
  const end = s.indexOf('>'); if (end !== -1) s = s.slice(0,end);
  s = s.replace(/\s+/g,'');
  if (s.length % 2 === 1) s += '0';
  const out = new Uint8Array(s.length/2);
  for (let i=0;i<s.length;i+=2){
    out[i/2] = parseInt(s.substr(i,2),16) & 255;
  }
  return out;
}

/* PNG predictor undo */
function undoPNGPrediction(inflated, rowBytes, rows, comps){
  const out = new Uint8Array(rowBytes * rows);
  const bpp = comps;
  let src = 0, dst = 0;
  const priorRow = new Uint8Array(rowBytes);

  for (let y=0; y<rows; y++){
    const filterType = inflated[src++]; // 0..4
    switch (filterType) {
      case 0: // None
        out.set(inflated.subarray(src, src+rowBytes), dst);
        break;
      case 1: // Sub
        for (let x=0; x<rowBytes; x++){
          const left = (x>=bpp) ? out[dst + x - bpp] : 0;
          out[dst + x] = (inflated[src + x] + left) & 0xFF;
        }
        break;
      case 2: // Up
        for (let x=0; x<rowBytes; x++){
          const up = priorRow[x] || 0;
          out[dst + x] = (inflated[src + x] + up) & 0xFF;
        }
        break;
      case 3: // Average
        for (let x=0; x<rowBytes; x++){
          const left = (x>=bpp) ? out[dst + x - bpp] : 0;
          const up = priorRow[x] || 0;
          out[dst + x] = (inflated[src + x] + ((left + up) >> 1)) & 0xFF;
        }
        break;
      case 4: // Paeth
        for (let x=0; x<rowBytes; x++){
          const left = (x>=bpp) ? out[dst + x - bpp] : 0;
          const up = priorRow[x] || 0;
          const upLeft = (x>=bpp) ? priorRow[x - bpp] : 0;
          out[dst + x] = (inflated[src + x] + paeth(left, up, upLeft)) & 0xFF;
        }
        break;
      default:
        out.set(inflated.subarray(src, src+rowBytes), dst);
    }
    priorRow.set(out.subarray(dst, dst+rowBytes));
    src += rowBytes; dst += rowBytes;
  }
  return out;
}
function paeth(a,b,c){
  const p = a + b - c;
  const pa = Math.abs(p - a);
  const pb = Math.abs(p - b);
  const pc = Math.abs(p - c);
  if (pa <= pb && pa <= pc) return a;
  if (pb <= pc) return b;
  return c;
}

/* Raster ‚Üí PNG via canvas */
async function rawToPNG(raw, width, height, comps){
  const canvas = document.createElement('canvas');
  canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imgData = ctx.createImageData(width, height);
  const dst = imgData.data;
  if (comps === 3) {
    let si=0, di=0, n = width*height;
    for (let i=0;i<n;i++){
      dst[di++] = raw[si++]; dst[di++] = raw[si++]; dst[di++] = raw[si++]; dst[di++] = 255;
    }
  } else {
    let si=0, di=0, n = width*height;
    for (let i=0;i<n;i++){
      const v = raw[si++]; dst[di++] = v; dst[di++] = v; dst[di++] = v; dst[di++] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  return canvasToPNG(canvas);
}

/* Draw blob to canvas for JPEG/JPX */
function drawToCanvas(blob, hintW, hintH){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const w = hintW || img.naturalWidth || img.width;
      const h = hintH || img.naturalHeight || img.height;
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha: true });
      ctx.drawImage(img, 0, 0, w, h);
      resolve({ canvas, ctx, img });
    };
    img.onerror = () => reject(new Error('Image decode failed'));
    img.src = URL.createObjectURL(blob);
  });
}
function canvasToPNG(canvas){
  return new Promise((resolve) => { canvas.toBlob(b => resolve(b), 'image/png', 1.0); });
}
function cleanupCanvas(canvas, ctx, img){
  try { URL.revokeObjectURL(img.src); } catch {}
}

/* Get size of PNG blob */
async function getImageSizeFromBlob(blob, fallbackW, fallbackH){
  if ('createImageBitmap' in window) {
    try {
      const bmp = await createImageBitmap(blob);
      const w = bmp.width, h = bmp.height;
      bmp.close();
      return { w, h };
    } catch {}
  }
  return new Promise((resolve) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => { const w = img.naturalWidth||fallbackW||0, h = img.naturalHeight||fallbackH||0; URL.revokeObjectURL(url); resolve({ w, h }); };
    img.onerror = () => { URL.revokeObjectURL(url); resolve({ w: fallbackW||0, h: fallbackH||0 }); };
    img.src = url;
  });
}

/* Inflate zlib using DecompressionStream */
async function inflateZlib(u8){
  if ('DecompressionStream' in window) {
    const ds = new DecompressionStream('deflate');
    const inStream = new Response(new Blob([u8])).body;
    const outStream = inStream.pipeThrough(ds);
    const out = await new Response(outStream).arrayBuffer();
    return new Uint8Array(out);
  } else {
    throw new Error('DecompressionStream not supported in this browser.');
  }
}

/* SHA-256 (WebCrypto) */
async function sha256Hex(u8){
  const buf = await crypto.subtle.digest('SHA-256', u8);
  const arr = Array.from(new Uint8Array(buf));
  return arr.map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* ===================
   ZIP (store method)
=================== */
const CRC32_TABLE = (() => {
  let c, table = [];
  for (let n =0; n < 256; n++) {
    c = n;
    for (let k=0; k<8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    table[n] = c >>> 0;
  }
  return table;
})();
function crc32(u8){
  let c = 0 ^ (-1);
  for (let i=0;i<u8.length;i++){
    c = (c >>> 8) ^ CRC32_TABLE[(c ^ u8[i]) & 0xFF];
  }
  return (c ^ (-1)) >>> 0;
}
function strToU8(s){ const u = new Uint8Array(s.length); for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i) & 0xFF; return u; }
function writeUint16LE(v){ return new Uint8Array([v & 0xFF, (v>>8) & 0xFF]); }
function writeUint32LE(v){ return new Uint8Array([v & 0xFF, (v>>8)&0xFF, (v>>16)&0xFF, (v>>24)&0xFF]); }

async function buildZipFromImages(files){
  const fileRecords = [];
  let localOffset = 0;
  const localParts = [];

  const now = new Date();
  const dosTime = toDosTime(now);
  const dosDate = toDosDate(now);

  for (const f of files) {
    const ab = await f.pngBlob.arrayBuffer();
    const u8 = new Uint8Array(ab);
    const c = crc32(u8);
    const nameU8 = strToU8(f.name);

    const LFH = [
      writeUint32LE(0x04034b50),
      writeUint16LE(20),
      writeUint16LE(0),
      writeUint16LE(0),
      writeUint16LE(dosTime),
      writeUint16LE(dosDate),
      writeUint32LE(c),
      writeUint32LE(u8.length),
      writeUint32LE(u8.length),
      writeUint16LE(nameU8.length),
      writeUint16LE(0),
      nameU8,
      u8
    ];
    const lfhSize = LFH.reduce((s,part)=> s + part.length, 0);
    localParts.push(...LFH);

    fileRecords.push({ nameU8, crc: c, size: u8.length, compSize: u8.length, offset: localOffset, time: dosTime, date: dosDate });
    localOffset += lfhSize;
  }

  const cdParts = [];
  let cdSize = 0;
  for (const rec of fileRecords) {
    const CDFH = [
      writeUint32LE(0x02014b50),
      writeUint16LE(20),
      writeUint16LE(20),
      writeUint16LE(0),
      writeUint16LE(0),
      writeUint16LE(rec.time),
      writeUint16LE(rec.date),
      writeUint32LE(rec.crc),
      writeUint32LE(rec.compSize),
      writeUint32LE(rec.size),
      writeUint16LE(rec.nameU8.length),
      writeUint16LE(0),
      writeUint16LE(0),
      writeUint16LE(0),
      writeUint16LE(0),
      writeUint32LE(0),
      writeUint32LE(rec.offset),
      rec.nameU8
    ];
    const size = CDFH.reduce((s, part)=> s + part.length, 0);
    cdSize += size;
    cdParts.push(...CDFH);
  }

  const cdOffset = localOffset;
  const EOCD = [
    writeUint32LE(0x06054b50),
    writeUint16LE(0), writeUint16LE(0),
    writeUint16LE(fileRecords.length),
    writeUint16LE(fileRecords.length),
    writeUint32LE(cdSize),
    writeUint32LE(cdOffset),
    writeUint16LE(0)
  ];

  const totalSize = localOffset + cdSize + EOCD.reduce((s,part)=> s+part.length, 0);
  const out = new Uint8Array(totalSize);
  let pos = 0;
  for (const p of localParts) { out.set(p, pos); pos += p.length; }
  for (const p of cdParts)    { out.set(p, pos); pos += p.length; }
  for (const p of EOCD)       { out.set(p, pos); pos += p.length; }

  return new Blob([out], { type: 'application/zip' });
}

function toDosTime(d){ let h=d.getHours(), m=d.getMinutes(), s=Math.floor(d.getSeconds()/2); return (h<<11)|(m<<5)|s; }
function toDosDate(d){ let y=Math.max(1980,d.getFullYear())-1980, mon=d.getMonth()+1, day=d.getDate(); return (y<<9)|(mon<<5)|day; }

/* Downloads */
els.downloadSelectedZipBtn.addEventListener('click', async () => {
  const chosen = state.images.filter(i => i.selected);
  if (!chosen.length) { alert('No images selected.'); return; }
  const zipBlob = await buildZipFromImages(chosen);
  const a = document.createElement('a'); a.href = URL.createObjectURL(zipBlob); a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove();
});
els.downloadAllZipBtn.addEventListener('click', async () => {
  const chosen = state.images.slice();
  if (!chosen.length) { alert('Nothing to download.'); return; }
  const zipBlob = await buildZipFromImages(chosen);
  const a = document.createElement('a'); a.href = URL.createObjectURL(zipBlob); a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove();
});
</script>
</body>
</html>
