<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF Image Extractor ‚Äì Single-File (Offline)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0b0d10;
    --card: #12161c;
    --muted: #9fb0c0;
    --text: #e8eef5;
    --accent: #61dafb;
    --ok: #3ddc97;
    --warn: #ffcc66;
    --danger: #ff6b6b;
    --border: #273240;
  }
  :root.light {
    --bg: #f7f9fc;
    --card: #ffffff;
    --muted: #5a6a7a;
    --text: #0b0d10;
    --accent: #0077ff;
    --ok: #1a8e5f;
    --warn: #b8860b;
    --danger: #b00020;
    --border: #d8e0ea;
  }
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
  }
  header {
    position: sticky; top: 0; z-index: 10;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
  h1 { font-size: 20px; margin: 0 0 8px 0; letter-spacing: 0.3px; }
  .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .spacer { flex: 1; }

  /* Buttons / labels */
  .btn, button, .toggle {
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 10px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    transition: transform .06s ease, background .2s ease, border .2s ease;
    user-select: none; text-decoration: none; outline: none; box-shadow: none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:hover, button:hover { transform: translateY(-1px); }
  button.primary { background: linear-gradient(180deg, var(--accent), #2aa3d6); color: #001218; border-color: transparent; }
  button.success { background: linear-gradient(180deg, var(--ok), #2dad78); color: #001b11; border-color: transparent; }
  button.warn { background: linear-gradient(180deg, var(--warn), #d7a13c); color: #2d1f00; border-color: transparent; }
  button:focus, button:active, .btn:focus, .btn:active { outline: none !important; box-shadow: none !important; }

  input[type="file"] { display:none; }
  .hint { color: var(--muted); font-size: 12px; margin-top: -4px; }

  .panel {
    background: var(--card); border: 1px solid var(--border);
    border-radius: 16px; padding: 14px;
  }
  .progress {
    height: 12px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; border: 1px solid var(--border);
  }
  .bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--accent), #9bffd6); transition: width .15s ease; }
  .statline { display: flex; gap: 10px; align-items:center; font-size: 13px; color: var(--muted); }

  .grid {
    display: grid; gap: 14px;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  }
  .card {
    background: var(--card); border: 1px solid var(--border); border-radius: 16px; overflow: hidden;
    display: flex; flex-direction: column;
  }
  .thumb {
    display: block; width: 100%; max-height: 200px; object-fit: contain; background: rgba(0,0,0,0.12);
  }
  .meta { padding: 10px 12px; display: grid; gap: 6px; font-size: 13px; }
  .meta .row { justify-content: space-between; }

  .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
  .tooltip { position: relative; display: inline-block; }
  .tooltip:hover::after {
    content: attr(data-tip);
    position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 8px 10px; border-radius: 10px; min-width: 180px; max-width: 260px;
    box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    white-space: normal; pointer-events: none; z-index: 20; font-size: 12px;
  }
  .empty {
    padding: 24px; text-align: center; color: var(--muted); border: 1px dashed var(--border); border-radius: 16px;
  }
  .small { font-size: 12px; color: var(--muted); }
  .ok { color: var(--ok); }

  .toggle { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; font-weight: 600; }
  .toggle input { width: 0; height: 0; appearance: none; }
  .pill {
    width: 44px; height: 24px; background: rgba(255,255,255,0.12); border-radius: 999px; position: relative; border: 1px solid var(--border);
  }
  .dot { position: absolute; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; border-radius: 50%; background: var(--text); left: 3px; transition: left .15s ease; }
  .toggle input:checked + .pill .dot { left: 23px; }

  .footer-note { margin-top: 30px; font-size: 12px; color: var(--muted); }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor</h1>
        <div class="hint">Single-file, offline. Extracts embedded & inline images as high-quality PNG with sort, preview, and selective ZIP download.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark mode">
        <span>Light</span>
        <input id="themeToggle" type="checkbox" />
        <span class="pill"><span class="dot"></span></span>
        <span>Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex; flex-direction: column; gap: 16px;">

  <section class="panel">
    <div class="row" style="gap: 8px; align-items:center;">
      <label for="fileInput" class="btn tooltip" data-tip="Choose a PDF from your computer (processed 100% locally).">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf"/>

      <button id="startBtn" class="primary tooltip" disabled data-tip="Starts extraction. Processing progress shown below.">‚ñ∂Ô∏è Start Processing</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <div class="tooltip" data-tip="Default sorts by pixel area (width√óheight), largest first. Smart Sort also considers file size and pushes icons/tiny images last.">
        <button id="defaultSortBtn" disabled>Sort: Size (default)</button>
      </div>
      <div class="tooltip" data-tip="Smart Sort pushes probable icons and tiny images last by blending area and MB size against the average.">
        <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>
      </div>

      <button id="downloadSelectedZipBtn" class="success" disabled>Download Selected (ZIP)</button>
      <button id="downloadAllZipBtn" disabled>Download All (ZIP)</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top: 12px; display:grid; gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start Processing</b> to begin.<br/><span class="small">If the PDF has no images, you‚Äôll see a notice.</span></div>
  </section>

  <section class="footer-note">
    <div><b>Notes & Limitations:</b> Handles embedded <i>and inline</i> images. JPEG/JPX good; Flate with PNG predictors supported; LZW added. Complex color spaces (Indexed/ICCBased/CMYK) are skipped (warn in console).</div>
  </section>

</main>

<script>
/* =============================
   Utility: Theme (Light/Dark)
============================= */
(function initTheme(){
  const root = document.documentElement;
  const toggle = document.getElementById('themeToggle');
  const saved = localStorage.getItem('pdfimg_theme') || 'dark';
  if(saved === 'light'){ root.classList.add('light'); toggle.checked = false; }
  else { root.classList.remove('light'); toggle.checked = true; }
  toggle.addEventListener('change', () => {
    if(toggle.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); }
    else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }
  });
})();
</script>

<script>
/* ===========================================================
   PDF Image Extractor ‚Äì robust, offline
   - Balanced outer dictionary parsing for streams (fixes /Length & filters).
   - Stream slicing via /Length (resolves indirect).
   - Filter chaining: ASCII85, ASCIIHex, Flate, LZW, DCT, JPX.
   - PNG predictors 10‚Äì15 (with /Columns) for 8bpc DeviceRGB/DeviceGray.
   - Extracts embedded /Subtype /Image AND inline BI/ID/EI images.
=========================================================== */

const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
};

let state = {
  pdfFile: null,
  pdfNameBase: 'images',
  raw: null,      // Uint8Array
  text: null,     // latin1 text
  objects: [],    // { obj, gen, startIndex, endIndex, dictRange:[a,b], dictStr, streamStart, streamEnd }
  objMap: new Map(),
  images: [],
  removedDuplicates: 0,
  sortMode: 'default',
};

function sanitizeBaseName(name) {
  const base = name.replace(/\.[Pp][Dd][Ff]$/, '');
  let s = base.replace(/[^a-zA-Z0-9_\-]+/g, '_');
  if (s.length > 12) s = s.slice(0, 12);
  if (!s) s = 'images';
  return s.toLowerCase();
}

els.fileInput.addEventListener('change', () => {
  const f = els.fileInput.files && els.fileInput.files[0];
  if (!f) return;
  state.pdfFile = f;
  els.pdfName.textContent = f.name;
  state.pdfNameBase = sanitizeBaseName(f.name);
  els.startBtn.disabled = false;
});

els.startBtn.addEventListener('click', async () => {
  if (!state.pdfFile) return;
  resetUIForProcessing();
  try {
    state.raw = new Uint8Array(await state.pdfFile.arrayBuffer());
    state.text = new TextDecoder('latin1').decode(state.raw);
    indexObjects(state.text);

    const items = await collectAllImages();
    if (!items.length) {
      showEmpty('No images found in this PDF.');
      finalizeStats();
      return;
    }
    await convertAllToPNGAndDedup(items);
    renderImages();
    enablePostProcessButtons();
    finalizeStats();
  } catch (err) {
    console.error(err);
    showEmpty('Failed to process PDF (corrupt or unsupported).');
    updateProgress(0, 'Error.');
  }
});

els.selectAllBtn.addEventListener('click', () => { for (const it of state.images) it.selected = true; renderImages(); });
els.deselectAllBtn.addEventListener('click', () => { for (const it of state.images) it.selected = false; renderImages(); });
els.defaultSortBtn.addEventListener('click', () => { state.sortMode = 'default'; sortImages(); renderImages(); });
els.smartSortBtn.addEventListener('click', () => { state.sortMode = 'smart'; sortImages(); renderImages(); });

function resetUIForProcessing(){
  state.images = [];
  state.removedDuplicates = 0;
  state.sortMode = 'default';
  els.gallery.innerHTML = '';
  updateProgress(0, 'Preparing‚Ä¶');
  els.defaultSortBtn.disabled = true;
  els.smartSortBtn.disabled = true;
  els.selectAllBtn.disabled = true;
  els.deselectAllBtn.disabled = true;
  els.downloadSelectedZipBtn.disabled = true;
  els.downloadAllZipBtn.disabled = true;
  els.stats.textContent = '';
}
function enablePostProcessButtons(){
  els.defaultSortBtn.disabled = false;
  els.smartSortBtn.disabled = false;
  els.selectAllBtn.disabled = false;
  els.deselectAllBtn.disabled = false;
  els.downloadSelectedZipBtn.disabled = false;
  els.downloadAllZipBtn.disabled = false;
}
function showEmpty(msg){ els.gallery.innerHTML = `<div class="empty">${msg}</div>`; }
function updateProgress(pct, text){ els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`; els.progressText.textContent = text; }
function finalizeStats(){
  els.stats.innerHTML = `Images: <b>${state.images.length}</b> &nbsp; | &nbsp; Removed duplicates: <b>${state.removedDuplicates}</b>`;
}

/* ============================
   Balanced dictionary parsing
============================ */
function findBalancedDictRange(block, fromIdx=0){
  // Find first '<<' then scan for matching '>>', handling nested << >> and strings/comments.
  const n = block.length;
  let i = block.indexOf('<<', fromIdx);
  if (i < 0) return null;
  let depth = 0;
  let j = i;
  let inStr = false, strParen = 0, inHexStr = false, inComment = false;
  while (j < n - 1){
    const a = block[j], b = block[j+1];
    // handle comment
    if (!inStr && !inHexStr && a === '%' && !inComment) { inComment = true; j++; continue; }
    if (inComment) { if (a === '\n' || a === '\r') inComment = false; j++; continue; }

    // string literal (...)
    if (!inHexStr && a === '('){
      inStr = true; strParen = 1; j++; continue;
    }
    if (inStr){
      if (a === '\\') { j += 2; continue; } // escaped char
      if (a === '(') strParen++;
      if (a === ')') { strParen--; if (strParen === 0) inStr = false; }
      j++; continue;
    }

    // hex string <...> (but not dictionary open '<<')
    if (!inHexStr && a === '<' && b !== '<'){ inHexStr = true; j++; continue; }
    if (inHexStr){
      if (a === '>') inHexStr = false;
      j++; continue;
    }

    // dictionary tokens
    if (a === '<' && b === '<'){ depth++; j += 2; continue; }
    if (a === '>' && b === '>'){
      depth--; j += 2;
      if (depth === 0) return [i, j];
      continue;
    }
    j++;
  }
  return null;
}

function indexObjects(text){
  state.objects = [];
  state.objMap.clear();
  const reObj = /(\d+)\s+(\d+)\s+obj\b/g;
  let m;
  while ((m = reObj.exec(text)) !== null) {
    const obj = parseInt(m[1],10), gen = parseInt(m[2],10);
    const start = m.index;
    const endObjIdx = text.indexOf('endobj', start);
    if (endObjIdx === -1) break;
    const block = text.slice(start, endObjIdx + 6);

    const dictRange = findBalancedDictRange(block);
    let dictStr = '';
    let streamStart = -1, streamEnd = -1;
    if (dictRange){
      const [a,b] = dictRange;
      dictStr = block.slice(a+2, b-2);
      // locate stream only after the full dictionary
      const streamIdx = block.indexOf('stream', b);
      if (streamIdx !== -1){
        let dataStart = streamIdx + 6;
        if (block[dataStart] === '\r' && block[dataStart+1] === '\n') dataStart += 2;
        else if (block[dataStart] === '\n') dataStart += 1;
        const absStart = start + dataStart;

        // read /Length (direct or indirect)
        let length = pickLastInt(dictStr, 'Length');
        if (length == null) {
          const lenRef = pickRef(dictStr, 'Length');
          length = getObjectNumericValue(lenRef);
        }
        if (length != null && Number.isFinite(length) && length >= 0){
          streamStart = absStart;
          streamEnd = Math.min(absStart + length, state.raw.length);
        } else {
          // fallback to endstream search
          const relEnd = block.indexOf('endstream', dataStart);
          if (relEnd !== -1) {
            streamStart = absStart;
            streamEnd = start + relEnd;
          }
        }
      }
    }

    const rec = { obj, gen, startIndex: start, endIndex: endObjIdx+6, dictRange, dictStr, streamStart, streamEnd };
    state.objMap.set(`${obj} ${gen}`, rec);
    state.objects.push(rec);
    reObj.lastIndex = endObjIdx + 6;
  }
}

function pickLastInt(source, name){
  const re = new RegExp(`/${name}\\s+(\\d+)`, 'g');
  let m, val = null;
  while ((m = re.exec(source)) !== null) val = parseInt(m[1],10);
  return val;
}
function pickRef(source, name){
  const re = new RegExp(`/${name}\\s+(\\d+)\\s+(\\d+)\\s+R`);
  const m = re.exec(source);
  return m ? { obj: parseInt(m[1],10), gen: parseInt(m[2],10) } : null;
}
function pickArrayNames(source, key){
  const re = new RegExp(`/${key}\\s+\\[([^\\]]+)\\]`);
  const m = re.exec(source);
  if (!m) return [];
  return (m[1].match(/\/([A-Za-z0-9]+)/g) || []).map(s => s.slice(1));
}
function pickName(source, key){
  const re = new RegExp(`/${key}\\s+/([A-Za-z0-9]+)`);
  const m = re.exec(source);
  return m ? m[1] : null;
}
function getObjectNumericValue(ref){
  if (!ref) return null;
  const obj = state.objMap.get(`${ref.obj} ${ref.gen}`);
  if (!obj) return null;
  const block = state.text.slice(obj.startIndex, obj.endIndex);
  const num = (block.match(/(\d+)/) || [])[1];
  return num ? parseInt(num,10) : null;
}

/* ============== Image collection (embedded + inline) ============== */

async function collectAllImages(){
  const embedded = [];
  const candidatesForInline = [];

  for (const rec of state.objects) {
    const dict = rec.dictStr || '';
    const hasStream = rec.streamStart >= 0 && rec.streamEnd > rec.streamStart;

    if (hasStream && /\/Subtype\s*\/Image\b/.test(dict)) {
      const width  = pickLastInt(dict, 'Width');
      const height = pickLastInt(dict, 'Height');
      const bits   = pickLastInt(dict, 'BitsPerComponent') || 8;

      let cs = pickName(dict, 'ColorSpace') || 'DeviceRGB';
      // Allow simple array form: [/ICCBased n 0 R] etc. (skip complex)
      if (!/^Device(RGB|Gray)$/.test(cs)) {
        console.warn('Skipping non-RGB/Gray image (ColorSpace=', cs, ')');
        continue;
      }

      let filters = pickArrayNames(dict, 'Filter');
      if (!filters.length) {
        const single = pickName(dict, 'Filter'); if (single) filters = [single];
      }
      const predictor = pickLastInt(dict, 'Predictor') || 1;
      const colors = pickLastInt(dict, 'Colors') || (cs==='DeviceRGB' ? 3 : 1);
      const columns = pickLastInt(dict, 'Columns') || width;

      const bytes = state.raw.subarray(rec.streamStart, rec.streamEnd);
      embedded.push({ kind:'embedded', width, height, bits, cs, filters, predictor, colors, columns, bytes });
      continue;
    }

    // Decode possible content streams for inline images
    if (hasStream) candidatesForInline.push(rec);
  }

  // Inline images from content streams (decode first if filtered)
  const inlineFound = [];
  for (const rec of candidatesForInline) {
    let data = state.raw.subarray(rec.streamStart, rec.streamEnd);
    const dict = rec.dictStr || '';
    let filters = pickArrayNames(dict, 'Filter');
    if (!filters.length) {
      const single = pickName(dict, 'Filter'); if (single) filters = [single];
    }
    for (const f of (filters || [])) {
      if (/^ASCII85Decode$/i.test(f)) { data = ascii85DecodeToBytes(data); continue; }
      if (/^ASCIIHexDecode$/i.test(f)) { data = asciiHexDecodeToBytes(data); continue; }
      if (/^FlateDecode$/i.test(f)) { data = await inflateZlib(data); continue; }
      if (/^LZWDecode$/i.test(f)) { data = lzwDecode(data); continue; }
    }
    const inlines = extractInlineImagesFromContent(data);
    inlineFound.push(...inlines);
  }

  return embedded.concat(inlineFound);
}

/* ============== Inline image parser (BI/ID/EI) ==================== */

function extractInlineImagesFromContent(u8){
  const isWs = b => b===9||b===10||b===12||b===13||b===32;
  const out = [];
  let i = 0, n = u8.length;

  while (i < n - 3) {
    if (u8[i]===0x42 && u8[i+1]===0x49 && (i===0 || isWs(u8[i-1])) && isWs(u8[i+2])) { // 'BI'
      i += 2; while (i<n && isWs(u8[i])) i++;

      // parse dict bytes until 'ID'
      const dictStart = i;
      let idPos = -1;
      for (let j=i; j<n-3; j++){
        if (isWs(u8[j]) && u8[j+1]===0x49 && u8[j+2]===0x44 && isWs(u8[j+3])) { idPos = j+1; break; } // ' ID '
      }
      if (idPos === -1) break;

      const dictBytes = u8.subarray(dictStart, idPos-1);
      i = idPos + 2;
      if (i<n && isWs(u8[i])) i++;

      const dataStart = i;
      let dataEnd = -1;
      for (let j=i; j<n-3; j++){
        if (isWs(u8[j]) && u8[j+1]===0x45 && u8[j+2]===0x49 && (j+3>=n || isWs(u8[j+3]))) { dataEnd = j; break; } // ' EI'
      }
      if (dataEnd === -1) break;

      const dataBytes = u8.subarray(dataStart, dataEnd);
      i = dataEnd + 3;

      const dictStr = new TextDecoder('latin1').decode(dictBytes);
      const width  = pickLastInt(dictStr, 'W') || pickLastInt(dictStr, 'Width');
      const height = pickLastInt(dictStr, 'H') || pickLastInt(dictStr, 'Height');
      const bits   = pickLastInt(dictStr, 'BPC') || pickLastInt(dictStr, 'BitsPerComponent') || 8;
      let cs = pickName(dictStr, 'CS') || pickName(dictStr, 'ColorSpace') || 'DeviceRGB';
      if (cs === 'RGB') cs = 'DeviceRGB';
      if (cs === 'G') cs = 'DeviceGray';
      if (!/^Device(RGB|Gray)$/.test(cs)) { console.warn('Skip inline non-RGB/Gray', cs); continue; }

      let filters = pickArrayNames(dictStr, 'F') || pickArrayNames(dictStr, 'Filter');
      if (!filters.length) {
        const singleF = pickName(dictStr, 'F') || pickName(dictStr, 'Filter');
        if (singleF) filters = [singleF];
      }
      const predictor = pickLastInt(dictStr, 'Predictor') || 1;
      const colors = pickLastInt(dictStr, 'Colors') || (cs==='DeviceRGB'?3:1);
      const columns = pickLastInt(dictStr, 'Columns') || width;

      out.push({ kind:'inline', width, height, bits, cs, filters, predictor, colors, columns, bytes: dataBytes });
      continue;
    }
    i++;
  }
  return out;
}

/* =================== Filter decoders & converters ================= */

async function convertAllToPNGAndDedup(items){
  const total = items.length;
  const seen = new Set();
  const results = [];
  const base = state.pdfNameBase;

  for (let idx=0; idx<total; idx++){
    updateProgress(Math.round((idx/Math.max(1,total))*100), `Processing image ${idx+1}/${total}‚Ä¶`);
    const it = items[idx];
    try {
      const pngBlob = await convertOneToPNG(it);
      if (!pngBlob) continue;

      const ab = await pngBlob.arrayBuffer();
      const hash = await sha256Hex(new Uint8Array(ab));
      if (seen.has(hash)) { state.removedDuplicates++; continue; }
      seen.add(hash);

      const { w, h } = await getImageSizeFromBlob(pngBlob, it.width, it.height);
      const url = URL.createObjectURL(pngBlob);
      const name = `${base}_img${results.length+1}.png`;

      results.push({
        id: 'img'+(results.length+1),
        pngBlob, hashHex: hash,
        width: w, height: h,
        mb: ab.byteLength/(1024*1024),
        name,
        selected: false,
        srcObjectUrl: url
      });
    } catch (e) {
      console.warn('Skipping image due to error', e);
    }
  }
  updateProgress(100, `Done (${results.length} images).`);
  state.images = results;
}

async function convertOneToPNG(item){
  let data = item.bytes;
  const filters = (item.filters && item.filters.length) ? item.filters.slice() : [];

  if (!filters.length) {
    return rawRasterToPNG(item, data);
  }

  for (let i=0;i<filters.length;i++){
    const f = filters[i];
    if (/^ASCII85Decode$/i.test(f)) { data = ascii85DecodeToBytes(data); continue; }
    if (/^ASCIIHexDecode$/i.test(f)) { data = asciiHexDecodeToBytes(data); continue; }
    if (/^FlateDecode$/i.test(f)) { data = await inflateZlib(data); if (i===filters.length-1) return rawRasterToPNG(item, data); continue; }
    if (/^LZWDecode$/i.test(f)) { data = lzwDecode(data); if (i===filters.length-1) return rawRasterToPNG(item, data); continue; }
    if (/^DCTDecode$/i.test(f)) { return jpegToPNG(data, item.width, item.height); }
    if (/^JPXDecode$/i.test(f)) { return jpxToPNG(data, item.width, item.height); }
    console.warn('Unsupported filter:', f); return null;
  }
  return rawRasterToPNG(item, data);
}

async function jpegToPNG(u8, hintW, hintH){
  const blob = new Blob([u8], { type: 'image/jpeg' });
  const { canvas, img } = await drawToCanvas(blob, hintW, hintH);
  const png = await canvasToPNG(canvas);
  try { URL.revokeObjectURL(img.src); } catch {}
  return png;
}
async function jpxToPNG(u8, hintW, hintH){
  const blob = new Blob([u8], { type: 'image/jp2' });
  try {
    const { canvas, img } = await drawToCanvas(blob, hintW, hintH);
    const png = await canvasToPNG(canvas);
    try { URL.revokeObjectURL(img.src); } catch {}
    return png;
  } catch {
    console.warn('JPEG2000 not supported by this browser.'); return null;
  }
}

async function rawRasterToPNG(item, raw){
  const { width, height, cs, bits, predictor, columns } = item;
  if (!(bits===8 && (cs==='DeviceRGB' || cs==='DeviceGray'))) { console.warn('Unsupported raster (needs 8bpc DeviceRGB/DeviceGray).'); return null; }
  const comps = (cs==='DeviceRGB') ? 3 : 1;

  let pixels;
  if (predictor === 1) {
    const expected = width * height * comps;
    if (raw.length !== expected) { console.warn('Raw length mismatch'); return null; }
    pixels = raw;
  } else if (predictor >= 10 && predictor <= 15) {
    const rowBytes = (columns||width) * comps;
    const stride = 1 + rowBytes;
    if (raw.length !== stride * height) {
      const altRowBytes = width * comps;
      const altStride = 1 + altRowBytes;
      if (raw.length !== altStride * height) { console.warn('Predictor size mismatch'); return null; }
      pixels = undoPNGPrediction(raw, altRowBytes, height, comps);
    } else {
      pixels = undoPNGPrediction(raw, rowBytes, height, comps);
    }
  } else {
    console.warn('Unsupported Predictor:', predictor); return null;
  }

  const canvas = document.createElement('canvas');
  canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imgData = ctx.createImageData(width, height);
  const dst = imgData.data;
  if (comps === 3) {
    let si=0, di=0, n=width*height;
    for (let i=0;i<n;i++){ dst[di++]=pixels[si++]; dst[di++]=pixels[si++]; dst[di++]=pixels[si++]; dst[di++]=255; }
  } else {
    let si=0, di=0, n=width*height;
    for (let i=0;i<n;i++){ const v=pixels[si++]; dst[di++]=v; dst[di++]=v; dst[di++]=v; dst[di++]=255; }
  }
  ctx.putImageData(imgData, 0, 0);
  return canvasToPNG(canvas);
}

/* ====== ASCII85 / ASCIIHex / Flate / LZW ======= */
function ascii85DecodeToBytes(u8){
  const s = new TextDecoder('ascii').decode(u8);
  return ascii85DecodeString(s);
}
function ascii85DecodeString(str){
  const s = str.replace(/<~/g,'').replace(/~>/g,'').replace(/\s+/g,'');
  const out = [];
  let group = [];
  for (let i=0;i<s.length;i++){
    const c = s[i];
    if (c==='z' && group.length===0){ out.push(0,0,0,0); continue; }
    const code = s.charCodeAt(i);
    if (code < 33 || code > 117) continue;
    group.push(code - 33);
    if (group.length===5){
      let v=0; for (let j=0;j<5;j++) v = v*85 + group[j];
      out.push((v>>>24)&255, (v>>>16)&255, (v>>>8)&255, v&255);
      group.length=0;
    }
  }
  if (group.length>0){
    for (let k=group.length; k<5; k++) group.push(84);
    let v=0; for (let j=0;j<5;j++) v = v*85 + group[j];
    for (let j=0;j<group.length-1;j++) out.push((v >>> (24 - 8*j)) & 255);
  }
  return new Uint8Array(out);
}
function asciiHexDecodeToBytes(u8){
  let s = new TextDecoder('ascii').decode(u8);
  const end = s.indexOf('>'); if (end !== -1) s = s.slice(0,end);
  s = s.replace(/\s+/g,'');
  if (s.length % 2 === 1) s += '0';
  const out = new Uint8Array(s.length/2);
  for (let i=0;i<s.length;i+=2) out[i/2] = parseInt(s.substr(i,2),16) & 255;
  return out;
}
async function inflateZlib(u8){
  if ('DecompressionStream' in window) {
    const ds = new DecompressionStream('deflate');
    const inStream = new Response(new Blob([u8])).body;
    const outStream = inStream.pipeThrough(ds);
    const out = await new Response(outStream).arrayBuffer();
    return new Uint8Array(out);
  } else { throw new Error('DecompressionStream unsupported'); }
}

/* ---- LZWDecode (PDF variant) ---- */
function lzwDecode(data){
  let pos = 0, bitPos = 0;
  function readBits(n){
    let val = 0;
    for (let i=0;i<n;i++){
      if (pos >= data.length) return null;
      const byte = data[pos];
      val = (val << 1) | ((byte >> (7 - bitPos)) & 1);
      bitPos++;
      if (bitPos === 8){ bitPos = 0; pos++; }
    }
    return val;
  }
  const CLEAR=256, EOD=257;
  let codeSize=9, dict=[], prev=null, out=[];
  for (let i=0;i<256;i++) dict[i]=new Uint8Array([i]);
  dict[CLEAR]=dict[EOD]=null;

  function readCode(n){ let v=0; for (let i=0;i<n;i++){ const b=readBits(1); if (b===null) return null; v=(v<<1)|b; } return v; }
  function concat(a,b){ const r=new Uint8Array(a.length+b.length); r.set(a); r.set(b,a.length); return r; }

  while (true){
    let code = readCode(codeSize); if (code===null) break;
    if (code===CLEAR){ dict=[]; for (let i=0;i<256;i++) dict[i]=new Uint8Array([i]); dict[CLEAR]=dict[EOD]=null; codeSize=9; prev=null; continue; }
    if (code===EOD) break;

    let entry;
    if (dict[code]) entry=dict[code];
    else if (prev!=null) entry=concat(dict[prev], new Uint8Array([dict[prev][0]]));
    else entry = new Uint8Array([code]);

    out.push(...entry);
    if (prev!=null) dict.push(concat(dict[prev], new Uint8Array([entry[0]])));
    prev = code;
    if (dict.length === (1<<codeSize) && codeSize<12) codeSize++;
  }
  return new Uint8Array(out);
}

/* ====== PNG predictor undo ====== */
function undoPNGPrediction(inflated, rowBytes, rows, comps){
  const out = new Uint8Array(rowBytes * rows);
  const bpp = comps;
  let src = 0, dst = 0;
  const priorRow = new Uint8Array(rowBytes);
  for (let y=0; y<rows; y++){
    const ft = inflated[src++]; // 0..4
    switch (ft){
      case 0: out.set(inflated.subarray(src, src+rowBytes), dst); break;
      case 1:
        for (let x=0; x<rowBytes; x++){ const left = (x>=bpp) ? out[dst+x-bpp] : 0; out[dst+x] = (inflated[src+x] + left) & 0xFF; }
        break;
      case 2:
        for (let x=0; x<rowBytes; x++){ const up = priorRow[x] || 0; out[dst+x] = (inflated[src+x] + up) & 0xFF; }
        break;
      case 3:
        for (let x=0; x<rowBytes; x++){ const left=(x>=bpp)?out[dst+x-bpp]:0, up=priorRow[x]||0; out[dst+x]=(inflated[src+x]+((left+up)>>1))&0xFF; }
        break;
      case 4:
        for (let x=0; x<rowBytes; x++){
          const left=(x>=bpp)?out[dst+x-bpp]:0, up=priorRow[x]||0, ul=(x>=bpp)?priorRow[x-bpp]:0;
          out[dst+x] = (inflated[src+x] + paeth(left, up, ul)) & 0xFF;
        }
        break;
      default: out.set(inflated.subarray(src, src+rowBytes), dst);
    }
    priorRow.set(out.subarray(dst, dst+rowBytes));
    src += rowBytes; dst += rowBytes;
  }
  return out;
}
function paeth(a,b,c){ const p=a+b-c, pa=Math.abs(p-a), pb=Math.abs(p-b), pc=Math.abs(p-c); if (pa<=pb && pa<=pc) return a; if (pb<=pc) return b; return c; }

/* ============== Canvas helpers & PNG export ============== */
function drawToCanvas(blob, hintW, hintH){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const w = hintW || img.naturalWidth || img.width;
      const h = hintH || img.naturalHeight || img.height;
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha: true });
      ctx.drawImage(img, 0, 0, w, h);
      resolve({ canvas, img });
    };
    img.onerror = () => reject(new Error('Image decode failed'));
    img.src = URL.createObjectURL(blob);
  });
}
function canvasToPNG(canvas){
  return new Promise((resolve) => { canvas.toBlob(b => resolve(b), 'image/png', 1.0); });
}
async function getImageSizeFromBlob(blob, fallbackW, fallbackH){
  if ('createImageBitmap' in window) {
    try { const bmp = await createImageBitmap(blob); const w=bmp.width, h=bmp.height; bmp.close(); return { w, h }; } catch {}
  }
  return new Promise((resolve) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => { const w=img.naturalWidth||fallbackW||0, h=img.naturalHeight||fallbackH||0; URL.revokeObjectURL(url); resolve({ w, h }); };
    img.onerror = () => { URL.revokeObjectURL(url); resolve({ w: fallbackW||0, h: fallbackH||0 }); };
    img.src = url;
  });
}

/* ============== SHA-256 & ZIP (store) ============== */
async function sha256Hex(u8){ const buf = await crypto.subtle.digest('SHA-256', u8); return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join(''); }

const CRC32_TABLE = (() => { let c, t=[]; for (let n=0;n<256;n++){ c=n; for (let k=0;k<8;k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); t[n]=c>>>0; } return t; })();
function crc32(u8){ let c=0^(-1); for (let i=0;i<u8.length;i++) c=(c>>>8)^CRC32_TABLE[(c^u8[i])&0xFF]; return (c^(-1))>>>0; }
function strToU8(s){ const u = new Uint8Array(s.length); for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i) & 0xFF; return u; }
function u16(v){ return new Uint8Array([v & 0xFF, (v>>8) & 0xFF]); }
function u32(v){ return new Uint8Array([v & 0xFF, (v>>8)&0xFF, (v>>16)&0xFF, (v>>24)&0xFF]); }
function toDosTime(d){ let h=d.getHours(), m=d.getMinutes(), s=Math.floor(d.getSeconds()/2); return (h<<11)|(m<<5)|s; }
function toDosDate(d){ let y=Math.max(1980,d.getFullYear())-1980, mon=d.getMonth()+1, day=d.getDate(); return (y<<9)|(mon<<5)|day; }

async function buildZipFromImages(files){
  const fileRecords = [];
  const localParts = [];
  let localOffset = 0;

  const now = new Date(), dt=toDosTime(now), dd=toDosDate(now);

  for (const f of files) {
    const ab = await f.pngBlob.arrayBuffer(); const u8 = new Uint8Array(ab);
    const c = crc32(u8), nameU8 = strToU8(f.name);
    const LFH = [ u32(0x04034b50), u16(20), u16(0), u16(0), u16(dt), u16(dd), u32(c), u32(u8.length), u32(u8.length), u16(nameU8.length), u16(0), nameU8, u8 ];
    const lfhSize = LFH.reduce((s,p)=> s+p.length, 0); localParts.push(...LFH);
    fileRecords.push({ nameU8, crc:c, size:u8.length, comp:u8.length, off: localOffset, dt, dd });
    localOffset += lfhSize;
  }

  const cdParts = []; let cdSize = 0;
  for (const r of fileRecords){
    const CDFH = [ u32(0x02014b50), u16(20), u16(20), u16(0), u16(0), u16(r.dt), u16(r.dd), u32(r.crc), u32(r.comp), u32(r.size),
                   u16(r.nameU8.length), u16(0), u16(0), u16(0), u16(0), u32(0), u32(r.off), r.nameU8 ];
    const size = CDFH.reduce((s,p)=> s+p.length, 0); cdSize += size; cdParts.push(...CDFH);
  }
  const cdOffset = localOffset;
  const EOCD = [ u32(0x06054b50), u16(0), u16(0), u16(fileRecords.length), u16(fileRecords.length), u32(cdSize), u32(cdOffset), u16(0) ];
  const total = localOffset + cdSize + EOCD.reduce((s,p)=> s+p.length, 0);
  const out = new Uint8Array(total); let pos=0;
  for (const p of localParts){ out.set(p, pos); pos += p.length; }
  for (const p of cdParts){ out.set(p, pos); pos += p.length; }
  for (const p of EOCD){ out.set(p, pos); pos += p.length; }
  return new Blob([out], { type: 'application/zip' });
}

/* ============== Render UI ============== */
function renderImages(){
  sortImages();
  if (!state.images.length) { showEmpty('No images found after processing.'); return; }
  const frag = document.createDocumentFragment();
  for (const it of state.images) frag.appendChild(renderCard(it));
  els.gallery.innerHTML = ''; els.gallery.appendChild(frag);
  els.defaultSortBtn.disabled = false;
  els.smartSortBtn.disabled = false;
  els.selectAllBtn.disabled = false;
  els.deselectAllBtn.disabled = false;
  els.downloadSelectedZipBtn.disabled = false;
  els.downloadAllZipBtn.disabled = false;
}
function renderCard(it){
  const card = document.createElement('div'); card.className = 'card';
  const img = document.createElement('img'); img.className='thumb'; img.src=it.srcObjectUrl; img.alt=it.name; img.loading='lazy';
  img.title='Click to open full-size in new tab'; img.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=it.srcObjectUrl; a.target='_blank'; a.download=it.name; a.click();});
  card.appendChild(img);

  const meta = document.createElement('div'); meta.className='meta';
  const row1 = document.createElement('div'); row1.className='row';
  const label = document.createElement('label'); label.style.display='flex'; label.style.alignItems='center'; label.style.gap='8px';
  const cb = document.createElement('input'); cb.type='checkbox'; cb.checked=!!it.selected;
  const name = document.createElement('span'); name.className='badge'; name.textContent = it.name;
  label.appendChild(cb); label.appendChild(name);
  const dl = document.createElement('button'); dl.textContent='Download'; dl.style.padding='6px 10px';
  dl.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=it.srcObjectUrl; a.download=it.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
  row1.appendChild(label); row1.appendChild(dl); meta.appendChild(row1);

  const row2 = document.createElement('div'); row2.className='row';
  const dims = document.createElement('div'); dims.className='small'; dims.textContent = `Dimensions: ${it.width}√ó${it.height}px`;
  const size = document.createElement('div'); size.className='small'; size.textContent = `Size: ${it.mb.toFixed(2)} MB`;
  row2.appendChild(dims); row2.appendChild(size); meta.appendChild(row2);

  const sel = document.createElement('div'); sel.className='small'; sel.innerHTML = it.selected ? `<span class="ok">Selected</span>` : `Not selected`;
  cb.addEventListener('change', ()=>{ it.selected = cb.checked; sel.innerHTML = cb.checked ? `<span class="ok">Selected</span>` : `Not selected`; });
  meta.appendChild(sel);

  card.appendChild(meta);
  return card;
}
function sortImages(){
  const arr = state.images; if (!arr.length) return;
  if (state.sortMode === 'default') arr.sort((a,b)=>(b.width*b.height)-(a.width*a.height));
  else {
    const areas = arr.map(i=>i.width*i.height), sizes = arr.map(i=>i.mb);
    const avgA = (areas.reduce((s,v)=>s+v,0)/areas.length)||1; const avgS = (sizes.reduce((s,v)=>s+v,0)/sizes.length)||1;
    for (const it of arr){ const area=it.width*it.height; const wA=area/avgA, wS=it.mb/avgS; it._smartScore=0.6*wA+0.4*wS; }
    arr.sort((a,b)=>b._smartScore-a._smartScore);
  }
}

/* ============== Download buttons ============== */
els.downloadSelectedZipBtn.addEventListener('click', async () => {
  const chosen = state.images.filter(i=>i.selected);
  if (!chosen.length) { alert('No images selected.'); return; }
  const zip = await buildZipFromImages(chosen);
  const a = document.createElement('a'); a.href = URL.createObjectURL(zip); a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove();
});
els.downloadAllZipBtn.addEventListener('click', async () => {
  const chosen = state.images.slice();
  if (!chosen.length) { alert('Nothing to download.'); return; }
  const zip = await buildZipFromImages(chosen);
  const a = document.createElement('a'); a.href = URL.createObjectURL(zip); a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove();
});
</script>

</body>
</html>
