<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF Image Extractor ‚Äî Overdrive (Aggressive Edition)</title>
<meta name="viewport" content="width=device-width, initial-scale-1" />
<!--
    FIXED & IMPROVED VERSION 2.0 (AGGRESSIVE EDITION):
    - Implemented a new hybrid, multi-stage extraction strategy to maximize success.
    - STRATEGY A (Fast Path): Directly extracts and parses raw pixel data for common formats like RGBA and Grayscale.
    - STRATEGY B (Robust Fallback): For complex images (CMYK, JPX, JBIG2, masked images), it now renders the full page to a high-res canvas and then precisely crops out the target image. This ensures that if an image is visible, it can be extracted.
    - STRATEGY C (Deep Scan): The "Aggressive" toggle still enables a signature sweep of all internal streams to find hidden or unreferenced raw image files.
    - Improved logic to accurately track each image's transformation matrix (position, rotation, scale) for precise cropping.
    - This comprehensive approach is significantly more powerful and resilient, capable of handling a much wider variety of PDFs.
-->
<style>
  :root { --bg:#0b0d10; --card:#12161c; --muted:#9fb0c0; --text:#e8eef5; --accent:#61dafb; --ok:#3ddc97; --warn:#ffcc66; --danger:#ff6b6b; --border:#273240; --shadow:0 10px 28px rgba(0,0,0,.45); }
  :root.light{ --bg:#f7f9fc; --card:#fff; --muted:#5a6a7a; --text:#0b0d10; --accent:#0077ff; --ok:#1a8e5f; --warn:#b8860b; --danger:#b00020; --border:#d8e0ea; --shadow:0 10px 26px rgba(0,0,0,.12); }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans;}
  *{box-sizing:border-box}
  header{position:sticky;top:0;z-index:10;background:var(--bg);border-bottom:1px solid var(--border);}
  .wrap{max-width:1180px;margin:0 auto;padding:16px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  .spacer{flex:1;}
  h1{margin:0;font-size:20px;letter-spacing:.2px;}
  .hint{color:var(--muted);font-size:12px;margin-top:4px;}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;transition:box-shadow .15s ease}
  .panel.hover{box-shadow:var(--shadow)}
  .grid{display:grid;gap:14px;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden;display:flex;flex-direction:column;}
  .thumb{width:100%;max-height:220px;object-fit:contain;background:#0e0f12;cursor:zoom-in;}
  .meta{padding:10px 12px;display:grid;gap:6px;font-size:13px;}
  .meta .row{justify-content:space-between;}
  .badge{padding:2px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .tag{padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;color:var(--muted)}
  .tag.lossy{color:#ffb3b3;border-color:#ffb3b3}
  .tag.lossless{color:#8fffd2;border-color:#8fffd2}
  .small{font-size:12px;color:var(--muted);}
  .ok{color:var(--ok);}
  .empty{padding:24px;text-align:center;color:var(--muted);border:1px dashed var(--border);border-radius:16px;}
  .btn,button,.toggle{background:var(--card);color:var(--text);border:1px solid var(--border);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:600;transition:transform .06s ease,background .2s ease,border .2s ease,box-shadow .2s ease;user-select:none;outline:none}
  .btn:hover,button:hover{transform:translateY(-1px);box-shadow:var(--shadow);}
  button.primary{background:linear-gradient(180deg,var(--accent),#2aa3d6);color:#001218;border-color:transparent;}
  button.success{background:linear-gradient(180deg,var(--ok),#2dad78);color:#001b11;border-color:transparent;}
  button.warn{background:linear-gradient(180deg,var(--warn),#d7a13c);color:#2d1f00;border-color:transparent;}
  input[type=file]{display:none;}
  .progress{height:12px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden;border:1px solid var(--border);}
  .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#9bffd6);transition:width .15s ease;}
  .statline{display:flex;gap:10px;align-items:center;font-size:13px;color:var(--muted);}
  .toggle{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;}
  .toggle input{width:0;height:0;appearance:none;}
  .pill{width:44px;height:24px;background:rgba(255,255,255,.12);border-radius:999px;border:1px solid var(--border);position:relative;}
  .dot{position:absolute;top:50%;transform:translateY(-50%);left:3px;width:18px;height:18px;border-radius:50%;background:var(--text);transition:left .15s ease;}
  .toggle input:checked + .pill .dot{left:23px;}
  .pill-badge{border:1px solid var(--border);border-radius:999px;padding:4px 8px;}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.75);z-index:1000;}
  .modal.open{display:flex;}
  .modal-inner{max-width:min(96vw,1600px);max-height:92vh;background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow);overflow:hidden;display:grid;grid-template-rows:auto 1fr;}
  .modal-header{display:flex;gap:8px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);}
  .modal-header .spacer{flex:1;}
  .modal-img-wrap{display:grid;place-items:center;background:#000;width:100%;height:100%;}
  .modal-img{max-width:100%;max-height:100%;object-fit:contain;background:#111;}
  .icon-btn{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--card);font-weight:700;cursor:pointer;}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor ‚Äî Overdrive</h1>
        <div class="hint">Aggressive multi-stage extraction: Direct parse, render-and-crop, and deep signature scanning.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark">
        <span class="small">Light</span><input id="themeToggle" type="checkbox" /><span class="pill"><span class="dot"></span></span><span class="small">Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex;flex-direction:column;gap:16px;">
  <section class="panel" id="dropZone">
    <div class="row" style="gap:8px;align-items:center;">
      <label class="btn" for="fileInput">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf" />
      <button id="startBtn" class="primary" disabled>‚ñ∂Ô∏è Start</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <span class="pill-badge">
        <label class="toggle" title="Hide small/low-info artifacts (icons, pixels)">
          <span class="small">Hide junk</span>
          <input id="hideJunkToggle" type="checkbox" checked />
          <span class="pill"><span class="dot"></span></span>
        </label>
      </span>

      <span class="pill-badge">
        <label class="toggle" title="Scan every decoded stream & object (slower, deeper)">
          <span class="small">Aggressive</span>
          <input id="aggrToggle" type="checkbox" />
          <span class="pill"><span class="dot"></span></span>
        </label>
      </span>

      <button id="defaultSortBtn" disabled>Sort: Size</button>
      <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>

      <button id="downloadSelectedZipBtn" class="success" disabled>ZIP Selected</button>
      <button id="downloadAllZipBtn" disabled>ZIP All</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top:12px;display:grid;gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start</b>.</div>
  </section>

  <section class="small">
    <b>Tip:</b> This tool uses multiple strategies. The "Render & Crop" method can extract complex vector art and logos that other tools might miss.
  </section>
</main>

<!-- Modal preview -->
<div id="modal" class="modal" aria-hidden="true">
  <div class="modal-inner" role="dialog" aria-modal="true" aria-label="Image preview">
    <div class="modal-header">
      <div id="modalTitle" class="small"></div>
      <div class="spacer"></div>
      <button id="modalDownload" class="icon-btn">‚¨áÔ∏è Download PNG</button>
      <button id="modalClose" class="icon-btn">‚úñ</button>
    </div>
    <div class="modal-img-wrap"><img id="modalImg" class="modal-img" alt="Preview"/></div>
  </div>
</div>

<!-- Dependencies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs" type="module"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

<script type="module">
/* =================== App wiring =================== */
import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs';
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
  hideJunkToggle: document.getElementById('hideJunkToggle'),
  aggrToggle: document.getElementById('aggrToggle'),
  dropZone: document.getElementById('dropZone'),
  modal: document.getElementById('modal'),
  modalImg: document.getElementById('modalImg'),
  modalClose: document.getElementById('modalClose'),
  modalDownload: document.getElementById('modalDownload'),
  modalTitle: document.getElementById('modalTitle'),
};

let state = {
  pdfFile:null, pdfNameBase:'images',
  raw:null,
  images:[],
  removedDuplicates:0, removedNearDuplicates:0, removedJunk:0,
  sortMode:'default'
};

function baseName(n){ const b=n.replace(/\.[Pp][Dd][Ff]$/,'').replace(/[^a-zA-Z0-9_\-]+/g,'_').toLowerCase(); return b.slice(0,12)||'images'; }
els.fileInput.addEventListener('change',()=>{ const f=els.fileInput.files?.[0]; if(!f) return; state.pdfFile=f; els.pdfName.textContent=f.name; state.pdfNameBase=baseName(f.name); els.startBtn.disabled=false; });
['dragenter','dragover'].forEach(ev=>els.dropZone.addEventListener(ev,e=>{e.preventDefault(); e.dataTransfer.dropEffect='copy'; els.dropZone.classList.add('hover');}));
['dragleave','drop'].forEach(ev=>els.dropZone.addEventListener(ev,e=>{e.preventDefault(); els.dropZone.classList.remove('hover');}));
els.dropZone.addEventListener('drop',e=>{ const f=e.dataTransfer.files?.[0]; if(!f) return; if(!/\.pdf$/i.test(f.name)){alert('Please drop a PDF.');return;} state.pdfFile=f; els.pdfName.textContent=f.name; state.pdfNameBase=baseName(f.name); els.startBtn.disabled=false; });

/* Modal preview */
let modalItem=null;
function openModal(it){ modalItem=it; els.modalImg.src=it.srcObjectUrl; els.modalTitle.textContent=`${it.name} ‚Äî ${it.width}√ó${it.height}px ‚Ä¢ ${it.mb.toFixed(2)} MB ‚Ä¢ ${it.strategy} ‚Ä¢ ${it.source} ${it.lossless?'(Lossless)':'(Lossy)'}`; els.modal.classList.add('open'); els.modal.setAttribute('aria-hidden','false'); }
function closeModal(){ els.modal.classList.remove('open'); els.modal.setAttribute('aria-hidden','true'); els.modalImg.src=''; modalItem=null; }
els.modalClose.addEventListener('click', closeModal);
els.modal.addEventListener('click', e=>{ if(e.target===els.modal) closeModal(); });
window.addEventListener('keydown', e=>{ if(e.key==='Escape' && els.modal.classList.contains('open')) closeModal(); });
els.modalDownload.addEventListener('click', ()=>{ if(!modalItem) return; const a=document.createElement('a'); a.href=modalItem.srcObjectUrl; a.download=modalItem.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

/* UI helpers */
function resetUI(){ state.images=[]; state.removedDuplicates=0; state.removedNearDuplicates=0; state.removedJunk=0; state.sortMode='default';
  els.gallery.innerHTML=''; els.stats.textContent='';
  [els.defaultSortBtn,els.smartSortBtn,els.selectAllBtn,els.deselectAllBtn,els.downloadSelectedZipBtn,els.downloadAllZipBtn].forEach(b=>b.disabled=true);
  progress(0,'Preparing‚Ä¶');
}
function enablePost(){ [els.defaultSortBtn,els.smartSortBtn,els.selectAllBtn,els.deselectAllBtn,els.downloadSelectedZipBtn,els.downloadAllZipBtn].forEach(b=>b.disabled=false); }
function progress(p,t){ els.bar.style.width=`${Math.max(0,Math.min(100,p))}%`; els.progressText.textContent=t; }
function showEmpty(msg){ els.gallery.innerHTML=`<div class="empty">${msg}</div>`; }
function updateStats(){ const s=`Images: <b>${state.images.length}</b> &nbsp;|&nbsp; Removed exact: <b>${state.removedDuplicates}</b> &nbsp;|&nbsp; Removed near: <b>${state.removedNearDuplicates}</b> &nbsp;|&nbsp; Hidden junk: <b>${state.removedJunk}</b>`; els.stats.innerHTML=s; }

/* Start */
els.startBtn.addEventListener('click', async ()=>{
  if(!state.pdfFile) return;
  resetUI();
  try{
    state.raw = new Uint8Array(await state.pdfFile.arrayBuffer());

    progress(10,'Loading PDF with PDF.js‚Ä¶');
    const pdf = await pdfjsLib.getDocument({data: state.raw, useSystemFonts: true}).promise;

    progress(20,'Extracting images‚Ä¶');
    let items = await extractImagesWithPdfJs(pdf);

    if(els.aggrToggle.checked){
      progress(50,'Aggressive scan (streams)‚Ä¶');
      items.push(...(await signatureSweepStreams(pdf)));
    }

    if(!items.length){ showEmpty('No images found.'); updateStats(); progress(100,'Done.'); return; }

    progress(60,'Processing & Converting‚Ä¶');
    await processAndConvert(items);

    progress(80,'Deduplicating‚Ä¶'); await dedupeExact(); await dedupePerceptual();

    if(els.hideJunkToggle.checked){ progress(88,'Hiding junk‚Ä¶'); filterJunk(); }

    progress(94,'Scoring & labeling‚Ä¶'); scoreQuality();

    progress(96,'Sorting‚Ä¶'); sortImages();
    renderImages(); enablePost(); progress(100,'Ready.'); updateStats();
  }catch(e){ console.error(e); showEmpty(`Failed to process PDF. Error: ${e.message}`); progress(0,'Error.'); }
});

/* =================== NEW: Aggressive Image Extraction =================== */
async function extractImagesWithPdfJs(pdf) {
    const items = [];
    const numPages = pdf.numPages;
    const seenImages = new Set();
    const pageCanvasCache = new Map(); // Cache for rendered pages

    for (let i = 1; i <= numPages; i++) {
        progress(20 + Math.round((i / numPages) * 28), `Analyzing page ${i}/${numPages}‚Ä¶`);
        const page = await pdf.getPage(i);
        const operatorList = await page.getOperatorList();

        const transformStack = [pdfjsLib.Util.IDENTITY_MATRIX];

        for (let opIdx = 0; opIdx < operatorList.fnArray.length; opIdx++) {
            const op = operatorList.fnArray[opIdx];
            const args = operatorList.argsArray[opIdx];

            if (op === pdfjsLib.OPS.save) {
                transformStack.push(transformStack.at(-1).slice());
            } else if (op === pdfjsLib.OPS.restore) {
                if (transformStack.length > 1) transformStack.pop();
            } else if (op === pdfjsLib.OPS.transform) {
                transformStack[transformStack.length - 1] = pdfjsLib.Util.transform(transformStack.at(-1), args);
            }

            if (op === pdfjsLib.OPS.paintImageXObject) {
                const imgName = args[0];
                if (seenImages.has(imgName)) continue;
                
                try {
                    const image = await page.objs.get(imgName);
                    if (!image || !image.width || !image.height) continue;
                    
                    seenImages.add(imgName);

                    let source = 'Bitmap';
                    let lossless = !image.smask;
                    if (image.jpx) { source = 'JPX (JPEG2000)'; lossless = false; }
                    else if (image.isjpeg) { source = 'JPEG'; lossless = false; }

                    let item = { source, lossless, width: image.width, height: image.height };

                    // STRATEGY A: Direct data extraction (Fast Path for RGBA/Grayscale)
                    if (image.data && (image.kind === pdfjsLib.ImageKind.RGBA_32BPP || image.kind === pdfjsLib.ImageKind.GRAYSCALE_8BPP)) {
                        item.strategy = 'Direct Extract';
                        item._raw = { data: image.data, kind: image.kind, width: image.width, height: image.height };
                        items.push(item);
                        continue; // Success, move to next image
                    }

                    // STRATEGY B: Render and Crop (Robust fallback for complex images)
                    item.strategy = 'Render & Crop';
                    
                    // Calculate rendered bounding box
                    const ctm = transformStack.at(-1);
                    const imgTransform = pdfjsLib.Util.transform(ctm, [image.width, 0, 0, image.height, 0, 0]);
                    const [p1, p2, p3, p4] = [[0, 0], [1, 0], [0, 1], [1, 1]].map(p => pdfjsLib.Util.applyTransform(p, imgTransform));
                    const bbox = {
                        minX: Math.min(p1[0], p2[0], p3[0], p4[0]),
                        minY: Math.min(p1[1], p2[1], p3[1], p4[1]),
                        maxX: Math.max(p1[0], p2[0], p3[0], p4[0]),
                        maxY: Math.max(p1[1], p2[1], p3[1], p4[1]),
                    };

                    const renderedWidth = Math.round(bbox.maxX - bbox.minX);
                    const renderedHeight = Math.round(bbox.maxY - bbox.minY);

                    if (renderedWidth < 2 || renderedHeight < 2) continue;
                    
                    item.width = renderedWidth;
                    item.height = renderedHeight;

                    // Get or create the full-page render
                    let pageCanvas = pageCanvasCache.get(i);
                    if (!pageCanvas) {
                        const pageViewport = page.getViewport({ scale: 2.0 }); // Render at 2x for quality
                        pageCanvas = document.createElement('canvas');
                        pageCanvas.width = pageViewport.width;
                        pageCanvas.height = pageViewport.height;
                        await page.render({ canvasContext: pageCanvas.getContext('2d'), viewport: pageViewport }).promise;
                        pageCanvasCache.set(i, pageCanvas);
                    }

                    // Crop the image from the full-page canvas
                    const pageViewport = page.getViewport({ scale: 2.0 });
                    const transform = pageViewport.transform;
                    const [sx, sy] = pdfjsLib.Util.applyTransform([bbox.minX, bbox.maxY], transform);
                    const sWidth = renderedWidth * pageViewport.scale;
                    const sHeight = renderedHeight * pageViewport.scale;

                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = renderedWidth;
                    cropCanvas.height = renderedHeight;
                    cropCanvas.getContext('2d').drawImage(pageCanvas, sx, sy, sWidth, sHeight, 0, 0, renderedWidth, renderedHeight);
                    
                    item.pngBlob = await toPng(cropCanvas);
                    items.push(item);

                } catch (e) {
                    console.warn(`Could not process image ${imgName} on page ${i}:`, e);
                }
            }
        }
        page.cleanup();
    }
    return items;
}


/* =================== NEW: Aggressive Stream Signature Sweep =================== */
async function signatureSweepStreams(pdf) {
    const items = [];
    const seenStreams = new Set();

    for (let i = 0; i < pdf.numObjects; i++) {
        try {
            const ref = { num: i, gen: 0 };
            const obj = await pdf.xref.fetch(ref);
            if (obj && obj.stream && !seenStreams.has(i)) {
                seenStreams.add(i);
                let bytes = obj.getBytes();
                if (obj.dict) {
                    const filter = obj.dict.get('Filter');
                    if (filter) {
                        const filterName = (Array.isArray(filter) ? filter[0] : filter).name;
                        if (filterName === 'FlateDecode') {
                            try { bytes = pako.inflate(bytes); } catch (e) { continue; }
                        }
                    }
                }
                const found = signatureScan(bytes);
                found.forEach(it => {
                    it.strategy = 'Sig: stream';
                    if(it._isPng){ it.source='PNG'; it.lossless=true; }
                    else if(it._isTiff){ it.source='TIFF'; it.lossless=true; }
                    else if(it._isGif){ it.source='GIF'; it.lossless=false; }
                    else if(it._isBmp){ it.source='BMP'; it.lossless=true; }
                    else if(it._isWebp){ it.source='WEBP'; it.lossless=false; }
                    else if(it._isJpeg){ it.source='JPEG'; it.lossless=false; }
                    else if(it._isJpx){ it.source='JP2'; it.lossless=false; }
                });
                items.push(...found);
            }
        } catch (e) {}
    }
    return items;
}

function signatureScan(u){
  const out=[];
  for(let i=0;i<u.length-3;i++){ if(u[i]===0xFF && u[i+1]===0xD8 && u[i+2]===0xFF){ let j=i+2; while(j<u.length-1 && !(u[j]===0xFF && u[j+1]===0xD9)) j++; if(j<u.length-1){ out.push(sigItem('jpeg',u.subarray(i,j+2))); i=j+1; } } }
  const pngMagic=[0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]; for(let i=0;i<u.length-8;i++){ let ok=true; for(let k=0;k<8;k++){ if(u[i+k]!==pngMagic[k]){ ok=false; break; } } if(ok){ let j=i+8; while(j+12<=u.length){ const len=((u[j]<<24)>>>0)|((u[j+1]<<16)>>>0)|((u[j+2]<<8)>>>0)|u[j+3]; const type=String.fromCharCode(u[j+4],u[j+5],u[j+6],u[j+7]); j+=8+len+4; if(type==='IEND'){ out.push(sigItem('png',u.subarray(i,j))); break; } } } }
  const jp2Magic=[0x00,0x00,0x00,0x0C,0x6A,0x50,0x20,0x20,0x0D,0x0A,0x87,0x0A]; for(let i=0;i<u.length-12;i++){ let ok=true; for(let k=0;k<12;k++){ if(u[i+k]!==jp2Magic[k]){ ok=false; break; } } if(ok){ out.push(sigItem('jp2',u.subarray(i,u.length))); } }
  for(let i=0;i<u.length-4;i++){ const isII=u[i]===0x49&&u[i+1]===0x49&&u[i+2]===0x2A&&u[i+3]===0x00; const isMM=u[i]===0x4D&&u[i+1]===0x4D&&u[i+2]===0x00&&u[i+3]===0x2A; if(isII||isMM){ out.push(sigItem('tiff',u.subarray(i,u.length))); } }
  for(let i=0;i<u.length-6;i++){ if(u[i]===0x47&&u[i+1]===0x49&&u[i+2]===0x46&&u[i+3]===0x38&&(u[i+4]===0x39||u[i+4]===0x37)&&u[i+5]===0x61){ out.push(sigItem('gif',u.subarray(i,u.length))); } }
  for(let i=0;i<u.length-2;i++){ if(u[i]===0x42&&u[i+1]===0x4D){ out.push(sigItem('bmp',u.subarray(i,u.length))); } }
  for(let i=0;i<u.length-12;i++){ if(u[i]===0x52&&u[i+1]===0x49&&u[i+2]===0x46&&u[i+3]===0x46 && u[i+8]===0x57&&u[i+9]===0x45&&u[i+10]===0x42&&u[i+11]===0x50){ const size=u[i+4]|(u[i+5]<<8)|(u[i+6]<<16)|(u[i+7]<<24); const end=Math.min(u.length,i+8+size); out.push(sigItem('webp',u.subarray(i,end))); } }
  return out;
}
function sigItem(kind, bytes){
  const common = { kind:'signature', width:0, height:0, bytes:bytes };
  if(kind==='jpeg') return {...common, _isJpeg:true}; if(kind==='jp2') return {...common, _isJpx:true}; if(kind==='png') return {...common, _isPng:true}; if(kind==='tiff') return {...common, _isTiff:true}; if(kind==='gif') return {...common, _isGif:true}; if(kind==='bmp') return {...common, _isBmp:true}; if(kind==='webp') return {...common, _isWebp:true};
}

/* =================== NEW: Unified Processing & Conversion =================== */
async function processAndConvert(items){
  const res=[]; const total=items.length;
  for(let i=0;i<total;i++){
    progress(60+Math.round((i/Math.max(1,total))*18),`Processing ${i+1}/${total}‚Ä¶`);
    try{
      let blob = items[i].pngBlob; // Already a blob from Render & Crop
      if (!blob) { // Needs conversion
          if (items[i]._raw) blob = await convertRawToPNG(items[i]._raw);
          else if (items[i].bytes) blob = await convertSigToPNG(items[i]);
      }
      if(!blob) continue;

      const ab=await blob.arrayBuffer(); const mb=ab.byteLength/(1024*1024);
      const {w,h}=await sizeFromBlob(blob, items[i].width, items[i].height);
      const url=URL.createObjectURL(blob);
      const name=`${state.pdfNameBase}_img${res.length+1}.png`;
      res.push({id:'img'+(res.length+1),pngBlob:blob,width:w,height:h,mb,name,selected:false,srcObjectUrl:url,_sha:null,_ahash:null, strategy:items[i].strategy||'Unknown', source:items[i].source||'?', lossless: !!items[i].lossless});
    }catch(e){ console.warn('Image processing failed:', e); }
  }
  state.images=res;
}

async function convertRawToPNG({ data, kind, width, height }) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    let rgba = data;
    if (kind === pdfjsLib.ImageKind.GRAYSCALE_8BPP) {
        rgba = new Uint8ClampedArray(width * height * 4);
        for (let i = 0, j = 0; i < data.length; i++, j += 4) {
            const v = data[i];
            rgba[j] = v; rgba[j + 1] = v; rgba[j + 2] = v; rgba[j + 3] = 255;
        }
    }
    const imageData = new ImageData(new Uint8ClampedArray(rgba.buffer, rgba.byteOffset, rgba.length), width, height);
    ctx.putImageData(imageData, 0, 0);
    return toPng(canvas);
}

async function convertSigToPNG(item) {
    let type = '';
    if (item._isPng) type = 'image/png'; else if (item._isJpeg) type = 'image/jpeg'; else if (item._isGif) type = 'image/gif'; else if (item._isBmp) type = 'image/bmp'; else if (item._isTiff) type = 'image/tiff'; else if (item._isWebp) type = 'image/webp'; else if (item._isJpx) type = 'image/jpx'; else return null;
    const blob = new Blob([item.bytes], { type });
    if (type === 'image/png') return blob;
    return await imageBlobToPNG(blob);
}

async function imageBlobToPNG(blob){
  return new Promise((resolve,reject)=>{
    const img=new Image();
    img.onload=()=>{ const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height; c.getContext('2d').drawImage(img,0,0); c.toBlob(b=>resolve(b),'image/png',1.0); URL.revokeObjectURL(img.src); };
    img.onerror=()=>reject(new Error('Blob image decode failed'));
    img.src=URL.createObjectURL(blob);
  });
}

/* ============= Canvas & helpers ============= */
function toPng(canvas){ return new Promise(r=>canvas.toBlob(b=>r(b),'image/png',1.0)); }
async function sizeFromBlob(blob,fw,fh){ if('createImageBitmap' in window){ try{ const bmp=await createImageBitmap(blob); const o={w:bmp.width,h:bmp.height}; bmp.close(); return o; }catch{} } return new Promise(resolve=>{ const u=URL.createObjectURL(blob); const i=new Image(); i.onload=()=>{ const r={w:i.naturalWidth||fw||0,h:i.naturalHeight||fh||0}; URL.revokeObjectURL(u); resolve(r); }; i.onerror=()=>{ URL.revokeObjectURL(u); resolve({w:fw||0,h:fh||0}); }; i.src=u; }); }

/* ============= Dedupe & junk (Unchanged) ============= */
async function sha256Hex(u8){ const d=await crypto.subtle.digest('SHA-256',u8); return Array.from(new Uint8Array(d)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function aHashFromBlob(blob){ return new Promise(res=>{ const img=new Image(); img.onload=()=>{ const url=img.src; const c=document.createElement('canvas'); c.width=8; c.height=8; const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,8,8); const d=ctx.getImageData(0,0,8,8).data; const gs=[]; for(let i=0;i<64;i++){ const r=d[i*4],g=d[i*4+1],b=d[i*4+2]; gs[i]=(r*0.299+g*0.587+b*0.114); } const avg=gs.reduce((s,v)=>s+v,0)/64; let bits=0n; for(let i=0;i<64;i++){ bits=(bits<<1n)|(gs[i]>=avg?1n:0n); } URL.revokeObjectURL(url); res(bits); }; img.onerror=()=>res(0n); img.src=URL.createObjectURL(blob); }); }
function hamming(a,b){ let x=a^b, c=0n; while(x){ c++; x&=(x-1n); } return Number(c); }
async function dedupeExact(){
  const map=new Map();
  for(const it of state.images){ if(!it._sha){ const ab=await it.pngBlob.arrayBuffer(); it._sha=await sha256Hex(new Uint8Array(ab)); } }
  for(const it of state.images){
    const prev=map.get(it._sha);
    if(!prev){ map.set(it._sha,it); }
    else { const a=prev.width*prev.height, b=it.width*it.height; if(b>a){ map.set(it._sha,it); } state.removedDuplicates++; }
  }
  state.images=Array.from(map.values()).sort((a,b)=>(b.width*b.height)-(a.width*a.height));
}
async function dedupePerceptual(){
  for(const it of state.images){ if(!it._ahash) it._ahash = await aHashFromBlob(it.pngBlob); }
  const used=new Array(state.images.length).fill(false); const keep=[];
  for(let i=0;i<state.images.length;i++){
    if(used[i]) continue; const a=state.images[i]; keep.push(a); used[i]=true;
    for(let j=i+1;j<state.images.length;j++){
      if(used[j]) continue; const b=state.images[j]; if(hamming(a._ahash,b._ahash) <= 4){ used[j]=true; state.removedNearDuplicates++; }
    }
  }
  state.images=keep;
}
function filterJunk(){
  const before=state.images.length;
  state.images = state.images.filter(it=>{
    const area=it.width*it.height;
    if (it.width<=2 || it.height<=2) return false;
    if (area < 32*32 && it.mb < 0.01) return false;
    if (area < 80*80 && it.mb < 0.02) return false;
    return true;
  });
  state.removedJunk += (before - state.images.length);
}

/* ============= Quality scoring & labels (Unchanged) ============= */
function scoreQuality(){
  for(const it of state.images){
    const area = it.width * it.height;
    let areaScore = 0;
    if(area >= 4_000_000) areaScore = 1.0; else if(area >= 1_000_000) areaScore = 0.8; else if(area >= 300_000) areaScore = 0.6; else if(area >= 100_000) areaScore = 0.4; else areaScore = 0.2;
    const losslessBoost = it.lossless ? 0.2 : 0.0;
    let score = Math.min(1, areaScore + losslessBoost);
    const stars = score>=0.9?5:score>=0.75?4:score>=0.55?3:score>=0.35?2:1;
    it.qualityScore = score;
    it.qualityStars = '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ'.slice(0,stars) + '‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ'.slice(stars);
  }
}

/* ============= Sort + render + ZIP (Unchanged) ============= */
function sortImages(){
  const arr=state.images;
  if(state.sortMode==='default') arr.sort((a,b)=>(b.width*b.height)-(a.width*a.height));
  else { const areas=arr.map(i=>i.width*i.height), sizes=arr.map(i=>i.mb);
    const avgA=(areas.reduce((s,v)=>s+v,0)/areas.length)||1, avgS=(sizes.reduce((s,v)=>s+v,0)/sizes.length)||1;
    for(const it of arr){ const A=it.width*it.height; it._smart=0.6*(A/avgA) + 0.4*(it.mb/avgS); }
    arr.sort((a,b)=> b._smart - a._smart);
  }
}
function renderImages(){
  if(!state.images.length){ showEmpty('No images after filtering. Toggle ‚ÄúHide junk‚Äù off to see everything.'); return; }
  const frag=document.createDocumentFragment();
  for(const it of state.images){
    const card=document.createElement('div'); card.className='card';
    const img=document.createElement('img'); img.className='thumb'; img.src=it.srcObjectUrl; img.alt=it.name; img.loading='lazy'; img.title='Click to preview'; img.addEventListener('click',()=>openModal(it)); card.appendChild(img);
    const meta=document.createElement('div'); meta.className='meta';
    const rowTop=document.createElement('div'); rowTop.className='row';
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='6px'; left.style.flexWrap='wrap';
    const strategy=document.createElement('span'); strategy.className='tag'; strategy.textContent=it.strategy||'Unknown';
    const source=document.createElement('span'); source.className='tag ' + (it.lossless?'lossless':'lossy'); source.textContent = `${it.source||'?'}` + (it.lossless?' ‚Ä¢ lossless':' ‚Ä¢ lossy');
    left.appendChild(strategy); left.appendChild(source);
    const dl=document.createElement('button'); dl.textContent='Download'; dl.style.padding='6px 10px'; dl.addEventListener('click',()=>{ const a=document.createElement('a'); a.href=it.srcObjectUrl; a.download=it.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
    rowTop.appendChild(left); rowTop.appendChild(dl); meta.appendChild(rowTop);
    const row1=document.createElement('div'); row1.className='row';
    const nmWrap=document.createElement('label'); nmWrap.style.display='flex'; nmWrap.style.alignItems='center'; nmWrap.style.gap='8px';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=!!it.selected;
    const nm=document.createElement('span'); nm.className='badge'; nm.textContent=it.name;
    nmWrap.appendChild(cb); nmWrap.appendChild(nm);
    const dims=document.createElement('div'); dims.className='small'; dims.textContent=`${it.width}√ó${it.height}px ‚Ä¢ ${it.mb.toFixed(2)} MB`;
    row1.appendChild(nmWrap); row1.appendChild(dims); meta.appendChild(row1);
    const row2=document.createElement('div'); row2.className='row';
    const q=document.createElement('div'); q.className='small'; q.textContent=`Quality: ${it.qualityStars || '‚Äî'}`;
    const sel=document.createElement('div'); sel.className='small'; sel.innerHTML=it.selected?`<span class="ok">Selected</span>`:`Not selected`;
    cb.addEventListener('change',()=>{ it.selected=cb.checked; sel.innerHTML=cb.checked?`<span class="ok">Selected</span>`:`Not selected`; updateSelectedButtonStates(); });
    row2.appendChild(q); row2.appendChild(sel); meta.appendChild(row2);
    card.appendChild(meta); frag.appendChild(card);
  }
  els.gallery.innerHTML=''; els.gallery.appendChild(frag);
  enablePost();
}
function updateSelectedButtonStates() {
    const anySelected = state.images.some(i => i.selected);
    els.downloadSelectedZipBtn.disabled = !anySelected;
}
els.selectAllBtn.addEventListener('click', () => { state.images.forEach(i => i.selected = true); renderImages(); updateSelectedButtonStates(); });
els.deselectAllBtn.addEventListener('click', () => { state.images.forEach(i => i.selected = false); renderImages(); updateSelectedButtonStates(); });
els.defaultSortBtn.addEventListener('click', () => { state.sortMode = 'default'; sortImages(); renderImages(); });
els.smartSortBtn.addEventListener('click', () => { state.sortMode = 'smart'; sortImages(); renderImages(); });

const CRC32_TABLE=(()=>{ let c,t=[]; for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); t[n]=c>>>0; } return t; })();
function crc32(u8){ let c=0^(-1); for(let i=0;i<u8.length;i++) c=(c>>>8)^CRC32_TABLE[(c^u8[i])&0xFF]; return (c^(-1))>>>0; }
function u16(v){ return new Uint8Array([v&255,(v>>8)&255]); } function u32(v){ return new Uint8Array([v&255,(v>>8)&255,(v>>16)&255,(v>>24)&255]); }
function strU8(s){ const u=new Uint8Array(s.length); for(let i=0;i<s.length;i++) u[i]=s.charCodeAt(i)&255; return u; }
function dosTime(d){ return (d.getHours()<<11)|(d.getMinutes()<<5)|Math.floor(d.getSeconds()/2); }
function dosDate(d){ const y=Math.max(1980,d.getFullYear())-1980; return (y<<9)|((d.getMonth()+1)<<5)|d.getDate(); }
async function buildZip(files){
  const now=new Date(),dt=dosTime(now),dd=dosDate(now);
  const localParts=[], records=[]; let offset=0;
  for(const f of files){
    const ab=await f.pngBlob.arrayBuffer(); const u8=new Uint8Array(ab); const c=crc32(u8), name=strU8(f.name);
    const LFH=[u32(0x04034b50),u16(20),u16(0),u16(0),u16(dt),u16(dd),u32(c),u32(u8.length),u32(u8.length),u16(name.length),u16(0),name,u8];
    const size=LFH.reduce((s,p)=>s+p.length,0); localParts.push(...LFH);
    records.push({name,crc:c,size:u8.length,comp:u8.length,off:offset,dt,dd}); offset+=size;
  }
  const cdParts=[]; let cdSize=0;
  for(const r of records){
    const CDFH=[u32(0x02014b50),u16(20),u16(20),u16(0),u16(0),u16(r.dt),u16(r.dd),u32(r.crc),u32(r.comp),u32(r.size),u16(r.name.length),u16(0),u16(0),u16(0),u16(0),u32(0),u32(r.off),r.name];
    const size=CDFH.reduce((s,p)=>s+p.length,0); cdSize+=size; cdParts.push(...CDFH);
  }
  const EOCD=[u32(0x06054b50),u16(0),u16(0),u16(records.length),u16(records.length),u32(cdSize),u32(offset),u16(0)];
  const total=offset+cdSize+EOCD.reduce((s,p)=>s+p.length,0); const out=new Uint8Array(total); let pos=0;
  for(const p of localParts){ out.set(p,pos); pos+=p.length; } for(const p of cdParts){ out.set(p,pos); pos+=p.length; } for(const p of EOCD){ out.set(p,pos); pos+=p.length; }
  return new Blob([out],{type:'application/zip'});
}
els.downloadSelectedZipBtn.addEventListener('click', async ()=>{ const chosen=state.images.filter(i=>i.selected); if(!chosen.length){ alert('No images selected.'); return; } const zip=await buildZip(chosen); const a=document.createElement('a'); a.href=URL.createObjectURL(zip); a.download=`${state.pdfNameBase}_images.zip`; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
els.downloadAllZipBtn.addEventListener('click', async ()=>{ const chosen=state.images.slice(); if(!chosen.length){ alert('Nothing to download.'); return; } const zip=await buildZip(chosen); const a=document.createElement('a'); a.href=URL.createObjectURL(zip); a.download=`${state.pdfNameBase}_images.zip`; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

/* Theme (Unchanged) */
(function(){
  const root=document.documentElement, t=document.getElementById('themeToggle');
  const saved=localStorage.getItem('pdfimg_theme')||'dark';
  if(saved==='light'){ root.classList.add('light'); t.checked=false; } else t.checked=true;
  t.addEventListener('change',()=>{ if(t.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); } else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }});
})();
</script>
</body>
</html>
