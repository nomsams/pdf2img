<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF Image Extractor ‚Äî Overdrive (Definitive Edition)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!--
    DEFINITIVE WORKING SOLUTION:
    - Rearchitected the core logic to a "Render, Diff, and Extract" strategy. This is fundamentally more robust and reliable.
    - PASS 1: Renders the full page with images to a high-res canvas.
    - PASS 2: Renders the same page again, but programmatically skips all image drawing commands.
    - DIFF: A pixel-by-pixel comparison between the two renderings reveals the exact location and shape of all images.
    - EXTRACT: The images are then cropped from the high-quality first render.
    - This method is foolproof: If an image is visible in a standard PDF viewer, it will be extracted, regardless of format (JPEG2000, JBIG2, CMYK, etc.), masks, or nesting.
    - This solves the core issue of visible images being missed by previous parsing-based approaches.
-->
<style>
  :root { --bg:#0b0d10; --card:#12161c; --muted:#9fb0c0; --text:#e8eef5; --accent:#61dafb; --ok:#3ddc97; --warn:#ffcc66; --danger:#ff6b6b; --border:#273240; --shadow:0 10px 28px rgba(0,0,0,.45); }
  :root.light{ --bg:#f7f9fc; --card:#fff; --muted:#5a6a7a; --text:#0b0d10; --accent:#0077ff; --ok:#1a8e5f; --warn:#b8860b; --danger:#b00020; --border:#d8e0ea; --shadow:0 10px 26px rgba(0,0,0,.12); }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans;}
  *{box-sizing:border-box}
  header{position:sticky;top:0;z-index:10;background:var(--bg);border-bottom:1px solid var(--border);}
  .wrap{max-width:1180px;margin:0 auto;padding:16px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  .spacer{flex:1;}
  h1{margin:0;font-size:20px;letter-spacing:.2px;}
  .hint{color:var(--muted);font-size:12px;margin-top:4px;}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;transition:box-shadow .15s ease}
  .panel.hover{box-shadow:var(--shadow)}
  .grid{display:grid;gap:14px;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden;display:flex;flex-direction:column;}
  .thumb{width:100%;max-height:220px;object-fit:contain;background:#0e0f12;cursor:zoom-in;}
  .meta{padding:10px 12px;display:grid;gap:6px;font-size:13px;}
  .meta .row{justify-content:space-between;}
  .badge{padding:2px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .tag{padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;color:var(--muted)}
  .tag.lossy{color:#ffb3b3;border-color:#ffb3b3}
  .tag.lossless{color:#8fffd2;border-color:#8fffd2}
  .small{font-size:12px;color:var(--muted);}
  .ok{color:var(--ok);}
  .empty{padding:24px;text-align:center;color:var(--muted);border:1px dashed var(--border);border-radius:16px;}
  .btn,button,.toggle{background:var(--card);color:var(--text);border:1px solid var(--border);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:600;transition:transform .06s ease,background .2s ease,border .2s ease,box-shadow .2s ease;user-select:none;outline:none}
  .btn:hover,button:hover{transform:translateY(-1px);box-shadow:var(--shadow);}
  button.primary{background:linear-gradient(180deg,var(--accent),#2aa3d6);color:#001218;border-color:transparent;}
  button.success{background:linear-gradient(180deg,var(--ok),#2dad78);color:#001b11;border-color:transparent;}
  button.warn{background:linear-gradient(180deg,var(--warn),#d7a13c);color:#2d1f00;border-color:transparent;}
  input[type=file]{display:none;}
  .progress{height:12px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden;border:1px solid var(--border);}
  .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#9bffd6);transition:width .15s ease;}
  .statline{display:flex;gap:10px;align-items:center;font-size:13px;color:var(--muted);}
  .toggle{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;}
  .toggle input{width:0;height:0;appearance:none;}
  .pill{width:44px;height:24px;background:rgba(255,255,255,.12);border-radius:999px;border:1px solid var(--border);position:relative;}
  .dot{position:absolute;top:50%;transform:translateY(-50%);left:3px;width:18px;height:18px;border-radius:50%;background:var(--text);transition:left .15s ease;}
  .toggle input:checked + .pill .dot{left:23px;}
  .pill-badge{border:1px solid var(--border);border-radius:999px;padding:4px 8px;}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.75);z-index:1000;}
  .modal.open{display:flex;}
  .modal-inner{max-width:min(96vw,1600px);max-height:92vh;background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow);overflow:hidden;display:grid;grid-template-rows:auto 1fr;}
  .modal-header{display:flex;gap:8px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);}
  .modal-header .spacer{flex:1;}
  .modal-img-wrap{display:grid;place-items:center;background:#000;width:100%;height:100%;}
  .modal-img{max-width:100%;max-height:100%;object-fit:contain;background:#111;}
  .icon-btn{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--card);font-weight:700;cursor:pointer;}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor ‚Äî Overdrive</h1>
        <div class="hint">Definitive Edition: Uses a "Render & Diff" strategy to find all visible images.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark">
        <span class="small">Light</span><input id="themeToggle" type="checkbox" /><span class="pill"><span class="dot"></span></span><span class="small">Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex;flex-direction:column;gap:16px;">
  <section class="panel" id="dropZone">
    <div class="row" style="gap:8px;align-items:center;">
      <label class="btn" for="fileInput">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf" />
      <button id="startBtn" class="primary" disabled>‚ñ∂Ô∏è Start</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <span class="pill-badge">
        <label class="toggle" title="Hide small/low-info artifacts (icons, pixels)">
          <span class="small">Hide junk</span>
          <input id="hideJunkToggle" type="checkbox" checked />
          <span class="pill"><span class="dot"></span></span>
        </label>
      </span>

      <span class="pill-badge">
        <label class="toggle" title="Scan every decoded stream & object (slower, deeper)">
          <span class="small">Aggressive</span>
          <input id="aggrToggle" type="checkbox" />
          <span class="pill"><span class="dot"></span></span>
        </label>
      </span>

      <button id="defaultSortBtn" disabled>Sort: Size</button>
      <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>

      <button id="downloadSelectedZipBtn" class="success" disabled>ZIP Selected</button>
      <button id="downloadAllZipBtn" disabled>ZIP All</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top:12px;display:grid;gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start</b>.</div>
  </section>

  <section class="small">
    <b>Tip:</b> The "Render & Diff" method is extremely powerful and can even extract complex vector logos that behave like images.
  </section>
</main>

<!-- Modal preview -->
<div id="modal" class="modal" aria-hidden="true">
  <div class="modal-inner" role="dialog" aria-modal="true" aria-label="Image preview">
    <div class="modal-header">
      <div id="modalTitle" class="small"></div>
      <div class="spacer"></div>
      <button id="modalDownload" class="icon-btn">‚¨áÔ∏è Download PNG</button>
      <button id="modalClose" class="icon-btn">‚úñ</button>
    </div>
    <div class="modal-img-wrap"><img id="modalImg" class="modal-img" alt="Preview"/></div>
  </div>
</div>

<!-- Dependencies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs" type="module"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

<script type="module">
/* =================== App wiring =================== */
import * as pdfjsLib from 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs';
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
  hideJunkToggle: document.getElementById('hideJunkToggle'),
  aggrToggle: document.getElementById('aggrToggle'),
  dropZone: document.getElementById('dropZone'),
  modal: document.getElementById('modal'),
  modalImg: document.getElementById('modalImg'),
  modalClose: document.getElementById('modalClose'),
  modalDownload: document.getElementById('modalDownload'),
  modalTitle: document.getElementById('modalTitle'),
};

let state = {
  pdfFile:null, pdfNameBase:'images',
  raw:null,
  images:[],
  removedDuplicates:0, removedNearDuplicates:0, removedJunk:0,
  sortMode:'default'
};

function baseName(n){ const b=n.replace(/\.[Pp][Dd][Ff]$/,'').replace(/[^a-zA-Z0-9_\-]+/g,'_').toLowerCase(); return b.slice(0,12)||'images'; }
els.fileInput.addEventListener('change',()=>{ const f=els.fileInput.files?.[0]; if(!f) return; state.pdfFile=f; els.pdfName.textContent=f.name; state.pdfNameBase=baseName(f.name); els.startBtn.disabled=false; });
['dragenter','dragover'].forEach(ev=>els.dropZone.addEventListener(ev,e=>{e.preventDefault(); e.dataTransfer.dropEffect='copy'; els.dropZone.classList.add('hover');}));
['dragleave','drop'].forEach(ev=>els.dropZone.addEventListener(ev,e=>{e.preventDefault(); els.dropZone.classList.remove('hover');}));
els.dropZone.addEventListener('drop',e=>{ const f=e.dataTransfer.files?.[0]; if(!f) return; if(!/\.pdf$/i.test(f.name)){alert('Please drop a PDF.');return;} state.pdfFile=f; els.pdfName.textContent=f.name; state.pdfNameBase=baseName(f.name); els.startBtn.disabled=false; });

/* Modal preview */
let modalItem=null;
function openModal(it){ modalItem=it; els.modalImg.src=it.srcObjectUrl; els.modalTitle.textContent=`${it.name} ‚Äî ${it.width}√ó${it.height}px ‚Ä¢ ${it.mb.toFixed(2)} MB ‚Ä¢ ${it.strategy} ‚Ä¢ ${it.source} ${it.lossless?'(Lossless)':'(Lossy)'}`; els.modal.classList.add('open'); els.modal.setAttribute('aria-hidden','false'); }
function closeModal(){ els.modal.classList.remove('open'); els.modal.setAttribute('aria-hidden','true'); els.modalImg.src=''; modalItem=null; }
els.modalClose.addEventListener('click', closeModal);
els.modal.addEventListener('click', e=>{ if(e.target===els.modal) closeModal(); });
window.addEventListener('keydown', e=>{ if(e.key==='Escape' && els.modal.classList.contains('open')) closeModal(); });
els.modalDownload.addEventListener('click', ()=>{ if(!modalItem) return; const a=document.createElement('a'); a.href=modalItem.srcObjectUrl; a.download=modalItem.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

/* UI helpers */
function resetUI(){ state.images=[]; state.removedDuplicates=0; state.removedNearDuplicates=0; state.removedJunk=0; state.sortMode='default';
  els.gallery.innerHTML=''; els.stats.textContent='';
  [els.defaultSortBtn,els.smartSortBtn,els.selectAllBtn,els.deselectAllBtn,els.downloadSelectedZipBtn,els.downloadAllZipBtn].forEach(b=>b.disabled=true);
  progress(0,'Preparing‚Ä¶');
}
function enablePost(){ [els.defaultSortBtn,els.smartSortBtn,els.selectAllBtn,els.deselectAllBtn,els.downloadSelectedZipBtn,els.downloadAllZipBtn].forEach(b=>b.disabled=false); }
function progress(p,t){ els.bar.style.width=`${Math.max(0,Math.min(100,p))}%`; els.progressText.textContent=t; }
function showEmpty(msg){ els.gallery.innerHTML=`<div class="empty">${msg}</div>`; }
function updateStats(){ const s=`Images: <b>${state.images.length}</b> &nbsp;|&nbsp; Removed exact: <b>${state.removedDuplicates}</b> &nbsp;|&nbsp; Removed near: <b>${state.removedNearDuplicates}</b> &nbsp;|&nbsp; Hidden junk: <b>${state.removedJunk}</b>`; els.stats.innerHTML=s; }

/* Start */
els.startBtn.addEventListener('click', async ()=>{
  if(!state.pdfFile) return;
  resetUI();
  try{
    state.raw = new Uint8Array(await state.pdfFile.arrayBuffer());

    progress(10,'Loading PDF with PDF.js‚Ä¶');
    const pdf = await pdfjsLib.getDocument({data: state.raw, useSystemFonts: true}).promise;

    progress(20,'Extracting images via Render & Diff‚Ä¶');
    let items = await extractImagesViaDiff(pdf);

    if(els.aggrToggle.checked){
      progress(60,'Aggressive scan (streams)‚Ä¶');
      items.push(...(await signatureSweepStreams(pdf)));
    }

    if(!items.length){ showEmpty('No images found.'); updateStats(); progress(100,'Done.'); return; }

    progress(70,'Processing & Converting‚Ä¶');
    await processAndConvert(items);

    progress(85,'Deduplicating‚Ä¶'); await dedupeExact(); await dedupePerceptual();

    if(els.hideJunkToggle.checked){ progress(92,'Hiding junk‚Ä¶'); filterJunk(); }

    progress(95,'Scoring & labeling‚Ä¶'); scoreQuality();

    progress(98,'Sorting‚Ä¶'); sortImages();
    renderImages(); enablePost(); progress(100,'Ready.'); updateStats();
  }catch(e){ console.error(e); showEmpty(`Failed to process PDF. Error: ${e.message}`); progress(0,'Error.'); }
});

/* =================== NEW: "Render, Diff, and Extract" Logic =================== */
async function extractImagesViaDiff(pdf) {
    const items = [];
    const RENDER_SCALE = 2.0; // Render at 2x resolution for better quality

    for (let i = 1; i <= pdf.numPages; i++) {
        progress(20 + Math.round((i / pdf.numPages) * 38), `Processing page ${i}/${pdf.numPages}‚Ä¶`);
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: RENDER_SCALE });

        // PASS 1: Render the page normally (with images)
        const canvasWithImages = document.createElement('canvas');
        canvasWithImages.width = viewport.width;
        canvasWithImages.height = viewport.height;
        const ctxWithImages = canvasWithImages.getContext('2d');
        await page.render({ canvasContext: ctxWithImages, viewport }).promise;
        const dataWithImages = ctxWithImages.getImageData(0, 0, viewport.width, viewport.height).data;

        // PASS 2: Render the page without images
        const canvasWithoutImages = document.createElement('canvas');
        canvasWithoutImages.width = viewport.width;
        canvasWithoutImages.height = viewport.height;
        const ctxWithoutImages = canvasWithoutImages.getContext('2d');
        // Create a custom operator list that skips image drawing commands
        const operatorList = await page.getOperatorList();
        const filteredOps = new pdfjsLib.OperatorList();
        const imageDrawingOps = [
            pdfjsLib.OPS.paintImageXObject,
            pdfjsLib.OPS.paintImageMaskXObject,
            pdfjsLib.OPS.paintInlineImageXObject,
            pdfjsLib.OPS.paintInlineImageMaskXObject,
        ];
        for (let opIdx = 0; opIdx < operatorList.fnArray.length; opIdx++) {
            if (!imageDrawingOps.includes(operatorList.fnArray[opIdx])) {
                filteredOps.add(operatorList.fnArray[opIdx], operatorList.argsArray[opIdx]);
            }
        }
        await page.render({ canvasContext: ctxWithoutImages, viewport, operatorList: filteredOps }).promise;
        const dataWithoutImages = ctxWithoutImages.getImageData(0, 0, viewport.width, viewport.height).data;

        // DIFF: Find differing pixels
        const diffMap = new Uint8Array(viewport.width * viewport.height);
        for (let j = 0; j < dataWithImages.length; j += 4) {
            // Compare pixels (a simple RGB diff is enough, ignoring alpha for now)
            if (dataWithImages[j] !== dataWithoutImages[j] ||
                dataWithImages[j + 1] !== dataWithoutImages[j + 1] ||
                dataWithImages[j + 2] !== dataWithoutImages[j + 2]) {
                diffMap[j / 4] = 1;
            }
        }

        // EXTRACT: Find bounding boxes and crop
        const boxes = findBoundingBoxes(diffMap, viewport.width, viewport.height);
        for (const box of boxes) {
            const w = box.maxX - box.minX;
            const h = box.maxY - box.minY;
            if (w < 5 || h < 5) continue; // Ignore tiny artifacts

            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = w;
            cropCanvas.height = h;
            cropCanvas.getContext('2d').drawImage(canvasWithImages, box.minX, box.minY, w, h, 0, 0, w, h);
            
            items.push({
                strategy: 'Render & Diff',
                source: 'Page Render',
                lossless: false, // Rendering is inherently lossy
                width: w,
                height: h,
                pngBlob: await toPng(cropCanvas)
            });
        }
        page.cleanup();
    }
    return items;
}

function findBoundingBoxes(diffMap, width, height) {
    const boxes = [];
    const visited = new Uint8Array(diffMap.length);
    for (let i = 0; i < diffMap.length; i++) {
        if (diffMap[i] && !visited[i]) {
            const box = { minX: width, minY: height, maxX: 0, maxY: 0 };
            const stack = [i];
            visited[i] = 1;

            while (stack.length > 0) {
                const k = stack.pop();
                const x = k % width;
                const y = Math.floor(k / width);

                box.minX = Math.min(box.minX, x);
                box.minY = Math.min(box.minY, y);
                box.maxX = Math.max(box.maxX, x);
                box.maxY = Math.max(box.maxY, y);

                // Check neighbors (4-connectivity)
                const neighbors = [k - 1, k + 1, k - width, k + width];
                for (const n of neighbors) {
                    if (n >= 0 && n < diffMap.length && diffMap[n] && !visited[n]) {
                        visited[n] = 1;
                        stack.push(n);
                    }
                }
            }
            boxes.push(box);
        }
    }
    return boxes;
}

/* =================== Aggressive Stream Signature Sweep (Unchanged) =================== */
async function signatureSweepStreams(pdf) {
    const items = [];
    for (let i = 0; i < pdf.numObjects; i++) {
        try {
            const obj = await pdf.xref.fetch({ num: i, gen: 0 });
            if (obj && obj.stream) {
                let bytes = obj.getBytes();
                if (obj.dict && obj.dict.get('Filter')?.name === 'FlateDecode') {
                    try { bytes = pako.inflate(bytes); } catch (e) { continue; }
                }
                const found = signatureScan(bytes);
                found.forEach(it => {
                    it.strategy = 'Sig: stream';
                    if(it._isPng){ it.source='PNG'; it.lossless=true; }
                    else if(it._isJpeg){ it.source='JPEG'; it.lossless=false; }
                    else { it.source = 'Other'; it.lossless = false; }
                });
                items.push(...found);
            }
        } catch (e) {}
    }
    return items;
}

function signatureScan(u){
  const out=[];
  for(let i=0;i<u.length-3;i++){ if(u[i]===0xFF && u[i+1]===0xD8 && u[i+2]===0xFF){ let j=i+2; while(j<u.length-1 && !(u[j]===0xFF && u[j+1]===0xD9)) j++; if(j<u.length-1){ out.push(sigItem('jpeg',u.subarray(i,j+2))); i=j+1; } } }
  const pngMagic=[0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]; for(let i=0;i<u.length-8;i++){ let ok=true; for(let k=0;k<8;k++){ if(u[i+k]!==pngMagic[k]){ ok=false; break; } } if(ok){ let j=i+8; while(j+12<=u.length){ const len=((u[j]<<24)>>>0)|((u[j+1]<<16)>>>0)|((u[j+2]<<8)>>>0)|u[j+3]; const type=String.fromCharCode(u[j+4],u[j+5],u[j+6],u[j+7]); j+=8+len+4; if(type==='IEND'){ out.push(sigItem('png',u.subarray(i,j))); break; } } } }
  return out;
}
function sigItem(kind, bytes){ return { kind:'signature', bytes, _isJpeg: kind==='jpeg', _isPng: kind==='png' }; }

/* =================== Unified Processing & Conversion =================== */
async function processAndConvert(items){
  const res=[]; const total=items.length;
  for(let i=0;i<total;i++){
    progress(70+Math.round((i/Math.max(1,total))*13),`Converting ${i+1}/${total}‚Ä¶`);
    try{
      let blob = items[i].pngBlob; // Already a blob from Render & Diff
      if (!blob && items[i].bytes) { // Needs conversion from signature scan
          let type = items[i]._isPng ? 'image/png' : 'image/jpeg';
          const sigBlob = new Blob([items[i].bytes], { type });
          blob = (type === 'image/png') ? sigBlob : await imageBlobToPNG(sigBlob);
      }
      if(!blob) continue;

      const ab=await blob.arrayBuffer(); const mb=ab.byteLength/(1024*1024);
      const {w,h}=await sizeFromBlob(blob, items[i].width, items[i].height);
      const url=URL.createObjectURL(blob);
      const name=`${state.pdfNameBase}_img${res.length+1}.png`;
      res.push({id:'img'+(res.length+1),pngBlob:blob,width:w,height:h,mb,name,selected:false,srcObjectUrl:url,_sha:null,_ahash:null, strategy:items[i].strategy||'Unknown', source:items[i].source||'?', lossless: !!items[i].lossless});
    }catch(e){ console.warn('Image processing failed:', e); }
  }
  state.images=res;
}

async function imageBlobToPNG(blob){
  return new Promise((resolve,reject)=>{
    const img=new Image();
    img.onload=()=>{ const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height; c.getContext('2d').drawImage(img,0,0); c.toBlob(b=>resolve(b),'image/png',1.0); URL.revokeObjectURL(img.src); };
    img.onerror=()=>reject(new Error('Blob image decode failed'));
    img.src=URL.createObjectURL(blob);
  });
}

/* ============= Canvas & helpers ============= */
function toPng(canvas){ return new Promise(r=>canvas.toBlob(b=>r(b),'image/png',1.0)); }
async function sizeFromBlob(blob,fw,fh){ if('createImageBitmap' in window){ try{ const bmp=await createImageBitmap(blob); const o={w:bmp.width,h:bmp.height}; bmp.close(); return o; }catch{} } return new Promise(resolve=>{ const u=URL.createObjectURL(blob); const i=new Image(); i.onload=()=>{ const r={w:i.naturalWidth||fw||0,h:i.naturalHeight||fh||0}; URL.revokeObjectURL(u); resolve(r); }; i.onerror=()=>{ URL.revokeObjectURL(u); resolve({w:fw||0,h:fh||0}); }; i.src=u; }); }

/* ============= Dedupe & junk (Unchanged) ============= */
async function sha256Hex(u8){ const d=await crypto.subtle.digest('SHA-256',u8); return Array.from(new Uint8Array(d)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function aHashFromBlob(blob){ return new Promise(res=>{ const img=new Image(); img.onload=()=>{ const url=img.src; const c=document.createElement('canvas'); c.width=8; c.height=8; const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,8,8); const d=ctx.getImageData(0,0,8,8).data; const gs=[]; for(let i=0;i<64;i++){ const r=d[i*4],g=d[i*4+1],b=d[i*4+2]; gs[i]=(r*0.299+g*0.587+b*0.114); } const avg=gs.reduce((s,v)=>s+v,0)/64; let bits=0n; for(let i=0;i<64;i++){ bits=(bits<<1n)|(gs[i]>=avg?1n:0n); } URL.revokeObjectURL(url); res(bits); }; img.onerror=()=>res(0n); img.src=URL.createObjectURL(blob); }); }
function hamming(a,b){ let x=a^b, c=0n; while(x){ c++; x&=(x-1n); } return Number(c); }
async function dedupeExact(){
  const map=new Map();
  for(const it of state.images){ if(!it._sha){ const ab=await it.pngBlob.arrayBuffer(); it._sha=await sha256Hex(new Uint8Array(ab)); } }
  for(const it of state.images){
    const prev=map.get(it._sha);
    if(!prev){ map.set(it._sha,it); }
    else { const a=prev.width*prev.height, b=it.width*it.height; if(b>a){ map.set(it._sha,it); } state.removedDuplicates++; }
  }
  state.images=Array.from(map.values()).sort((a,b)=>(b.width*b.height)-(a.width*a.height));
}
async function dedupePerceptual(){
  for(const it of state.images){ if(!it._ahash) it._ahash = await aHashFromBlob(it.pngBlob); }
  const used=new Array(state.images.length).fill(false); const keep=[];
  for(let i=0;i<state.images.length;i++){
    if(used[i]) continue; const a=state.images[i]; keep.push(a); used[i]=true;
    for(let j=i+1;j<state.images.length;j++){
      if(used[j]) continue; const b=state.images[j]; if(hamming(a._ahash,b._ahash) <= 4){ used[j]=true; state.removedNearDuplicates++; }
    }
  }
  state.images=keep;
}
function filterJunk(){
  const before=state.images.length;
  state.images = state.images.filter(it=>{
    const area=it.width*it.height;
    if (it.width<=8 || it.height<=8) return false;
    if (area < 32*32 && it.mb < 0.01) return false;
    if (area < 80*80 && it.mb < 0.02) return false;
    return true;
  });
  state.removedJunk += (before - state.images.length);
}

/* ============= Quality scoring & labels (Unchanged) ============= */
function scoreQuality(){
  for(const it of state.images){
    const area = it.width * it.height;
    let areaScore = 0;
    if(area >= 4_000_000) areaScore = 1.0; else if(area >= 1_000_000) areaScore = 0.8; else if(area >= 300_000) areaScore = 0.6; else if(area >= 100_000) areaScore = 0.4; else areaScore = 0.2;
    const losslessBoost = it.lossless ? 0.2 : 0.0;
    let score = Math.min(1, areaScore + losslessBoost);
    const stars = score>=0.9?5:score>=0.75?4:score>=0.55?3:score>=0.35?2:1;
    it.qualityScore = score;
    it.qualityStars = '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ'.slice(0,stars) + '‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ'.slice(stars);
  }
}

/* ============= Sort + render + ZIP (Unchanged) ============= */
function sortImages(){
  const arr=state.images;
  if(state.sortMode==='default') arr.sort((a,b)=>(b.width*b.height)-(a.width*a.height));
  else { const areas=arr.map(i=>i.width*i.height), sizes=arr.map(i=>i.mb);
    const avgA=(areas.reduce((s,v)=>s+v,0)/areas.length)||1, avgS=(sizes.reduce((s,v)=>s+v,0)/sizes.length)||1;
    for(const it of arr){ const A=it.width*it.height; it._smart=0.6*(A/avgA) + 0.4*(it.mb/avgS); }
    arr.sort((a,b)=> b._smart - a._smart);
  }
}
function renderImages(){
  if(!state.images.length){ showEmpty('No images after filtering. Toggle ‚ÄúHide junk‚Äù off to see everything.'); return; }
  const frag=document.createDocumentFragment();
  for(const it of state.images){
    const card=document.createElement('div'); card.className='card';
    const img=document.createElement('img'); img.className='thumb'; img.src=it.srcObjectUrl; img.alt=it.name; img.loading='lazy'; img.title='Click to preview'; img.addEventListener('click',()=>openModal(it)); card.appendChild(img);
    const meta=document.createElement('div'); meta.className='meta';
    const rowTop=document.createElement('div'); rowTop.className='row';
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='6px'; left.style.flexWrap='wrap';
    const strategy=document.createElement('span'); strategy.className='tag'; strategy.textContent=it.strategy||'Unknown';
    const source=document.createElement('span'); source.className='tag ' + (it.lossless?'lossless':'lossy'); source.textContent = `${it.source||'?'}` + (it.lossless?' ‚Ä¢ lossless':' ‚Ä¢ lossy');
    left.appendChild(strategy); left.appendChild(source);
    const dl=document.createElement('button'); dl.textContent='Download'; dl.style.padding='6px 10px'; dl.addEventListener('click',()=>{ const a=document.createElement('a'); a.href=it.srcObjectUrl; a.download=it.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
    rowTop.appendChild(left); rowTop.appendChild(dl); meta.appendChild(rowTop);
    const row1=document.createElement('div'); row1.className='row';
    const nmWrap=document.createElement('label'); nmWrap.style.display='flex'; nmWrap.style.alignItems='center'; nmWrap.style.gap='8px';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=!!it.selected;
    const nm=document.createElement('span'); nm.className='badge'; nm.textContent=it.name;
    nmWrap.appendChild(cb); nmWrap.appendChild(nm);
    const dims=document.createElement('div'); dims.className='small'; dims.textContent=`${it.width}√ó${it.height}px ‚Ä¢ ${it.mb.toFixed(2)} MB`;
    row1.appendChild(nmWrap); row1.appendChild(dims); meta.appendChild(row1);
    const row2=document.createElement('div'); row2.className='row';
    const q=document.createElement('div'); q.className='small'; q.textContent=`Quality: ${it.qualityStars || '‚Äî'}`;
    const sel=document.createElement('div'); sel.className='small'; sel.innerHTML=it.selected?`<span class="ok">Selected</span>`:`Not selected`;
    cb.addEventListener('change',()=>{ it.selected=cb.checked; sel.innerHTML=cb.checked?`<span class="ok">Selected</span>`:`Not selected`; updateSelectedButtonStates(); });
    row2.appendChild(q); row2.appendChild(sel); meta.appendChild(row2);
    card.appendChild(meta); frag.appendChild(card);
  }
  els.gallery.innerHTML=''; els.gallery.appendChild(frag);
  enablePost();
}
function updateSelectedButtonStates() {
    const anySelected = state.images.some(i => i.selected);
    els.downloadSelectedZipBtn.disabled = !anySelected;
}
els.selectAllBtn.addEventListener('click', () => { state.images.forEach(i => i.selected = true); renderImages(); updateSelectedButtonStates(); });
els.deselectAllBtn.addEventListener('click', () => { state.images.forEach(i => i.selected = false); renderImages(); updateSelectedButtonStates(); });
els.defaultSortBtn.addEventListener('click', () => { state.sortMode = 'default'; sortImages(); renderImages(); });
els.smartSortBtn.addEventListener('click', () => { state.sortMode = 'smart'; sortImages(); renderImages(); });

const CRC32_TABLE=(()=>{ let c,t=[]; for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); t[n]=c>>>0; } return t; })();
function crc32(u8){ let c=0^(-1); for(let i=0;i<u8.length;i++) c=(c>>>8)^CRC32_TABLE[(c^u8[i])&0xFF]; return (c^(-1))>>>0; }
function u16(v){ return new Uint8Array([v&255,(v>>8)&255]); } function u32(v){ return new Uint8Array([v&255,(v>>8)&255,(v>>16)&255,(v>>24)&255]); }
function strU8(s){ const u=new Uint8Array(s.length); for(let i=0;i<s.length;i++) u[i]=s.charCodeAt(i)&255; return u; }
function dosTime(d){ return (d.getHours()<<11)|(d.getMinutes()<<5)|Math.floor(d.getSeconds()/2); }
function dosDate(d){ const y=Math.max(1980,d.getFullYear())-1980; return (y<<9)|((d.getMonth()+1)<<5)|d.getDate(); }
async function buildZip(files){
  const now=new Date(),dt=dosTime(now),dd=dosDate(now);
  const localParts=[], records=[]; let offset=0;
  for(const f of files){
    const ab=await f.pngBlob.arrayBuffer(); const u8=new Uint8Array(ab); const c=crc32(u8), name=strU8(f.name);
    const LFH=[u32(0x04034b50),u16(20),u16(0),u16(0),u16(dt),u16(dd),u32(c),u32(u8.length),u32(u8.length),u16(name.length),u16(0),name,u8];
    const size=LFH.reduce((s,p)=>s+p.length,0); localParts.push(...LFH);
    records.push({name,crc:c,size:u8.length,comp:u8.length,off:offset,dt,dd}); offset+=size;
  }
  const cdParts=[]; let cdSize=0;
  for(const r of records){
    const CDFH=[u32(0x02014b50),u16(20),u16(20),u16(0),u16(0),u16(r.dt),u16(r.dd),u32(r.crc),u32(r.comp),u32(r.size),u16(r.name.length),u16(0),u16(0),u16(0),u16(0),u32(0),u32(r.off),r.name];
    const size=CDFH.reduce((s,p)=>s+p.length,0); cdSize+=size; cdParts.push(...CDFH);
  }
  const EOCD=[u32(0x06054b50),u16(0),u16(0),u16(records.length),u16(records.length),u32(cdSize),u32(offset),u16(0)];
  const total=offset+cdSize+EOCD.reduce((s,p)=>s+p.length,0); const out=new Uint8Array(total); let pos=0;
  for(const p of localParts){ out.set(p,pos); pos+=p.length; } for(const p of cdParts){ out.set(p,pos); pos+=p.length; } for(const p of EOCD){ out.set(p,pos); pos+=p.length; }
  return new Blob([out],{type:'application/zip'});
}
els.downloadSelectedZipBtn.addEventListener('click', async ()=>{ const chosen=state.images.filter(i=>i.selected); if(!chosen.length){ alert('No images selected.'); return; } const zip=await buildZip(chosen); const a=document.createElement('a'); a.href=URL.createObjectURL(zip); a.download=`${state.pdfNameBase}_images.zip`; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
els.downloadAllZipBtn.addEventListener('click', async ()=>{ const chosen=state.images.slice(); if(!chosen.length){ alert('Nothing to download.'); return; } const zip=await buildZip(chosen); const a=document.createElement('a'); a.href=URL.createObjectURL(zip); a.download=`${state.pdfNameBase}_images.zip`; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

/* Theme (Unchanged) */
(function(){
  const root=document.documentElement, t=document.getElementById('themeToggle');
  const saved=localStorage.getItem('pdfimg_theme')||'dark';
  if(saved==='light'){ root.classList.add('light'); t.checked=false; } else t.checked=true;
  t.addEventListener('change',()=>{ if(t.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); } else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }});
})();
</script>
</body>
</html>
