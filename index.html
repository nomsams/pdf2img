<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF Image Extractor ‚Äî Overdrive (Offline, Single-File)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b0d10; --card:#12161c; --muted:#9fb0c0; --text:#e8eef5; --accent:#61dafb; --ok:#3ddc97; --warn:#ffcc66; --danger:#ff6b6b; --border:#273240; --shadow:0 10px 28px rgba(0,0,0,.45); }
  :root.light{ --bg:#f7f9fc; --card:#fff; --muted:#5a6a7a; --text:#0b0d10; --accent:#0077ff; --ok:#1a8e5f; --warn:#b8860b; --danger:#b00020; --border:#d8e0ea; --shadow:0 10px 26px rgba(0,0,0,.12); }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans;}
  *{box-sizing:border-box}
  header{position:sticky;top:0;z-index:10;background:var(--bg);border-bottom:1px solid var(--border);}
  .wrap{max-width:1180px;margin:0 auto;padding:16px;}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  .spacer{flex:1;}
  h1{margin:0;font-size:20px;letter-spacing:.2px;}
  .hint{color:var(--muted);font-size:12px;margin-top:4px;}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;transition:box-shadow .15s ease}
  .panel.hover{box-shadow:var(--shadow)}
  .grid{display:grid;gap:14px;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;overflow:hidden;display:flex;flex-direction:column;}
  .thumb{width:100%;max-height:220px;object-fit:contain;background:#0e0f12;cursor:zoom-in;}
  .meta{padding:10px 12px;display:grid;gap:6px;font-size:13px;}
  .meta .row{justify-content:space-between;}
  .badge{padding:2px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .tag{padding:2px 8px;border-radius:999px;border:1px solid var(--border);font-size:11px;color:var(--muted)}
  .tag.lossy{color:#ffb3b3;border-color:#ffb3b3}
  .tag.lossless{color:#8fffd2;border-color:#8fffd2}
  .small{font-size:12px;color:var(--muted);}
  .ok{color:var(--ok);}
  .empty{padding:24px;text-align:center;color:var(--muted);border:1px dashed var(--border);border-radius:16px;}
  .btn,button,.toggle{background:var(--card);color:var(--text);border:1px solid var(--border);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:600;transition:transform .06s ease,background .2s ease,border .2s ease,box-shadow .2s ease;user-select:none;outline:none}
  .btn:hover,button:hover{transform:translateY(-1px);box-shadow:var(--shadow);}
  button.primary{background:linear-gradient(180deg,var(--accent),#2aa3d6);color:#001218;border-color:transparent;}
  button.success{background:linear-gradient(180deg,var(--ok),#2dad78);color:#001b11;border-color:transparent;}
  button.warn{background:linear-gradient(180deg,var(--warn),#d7a13c);color:#2d1f00;border-color:transparent;}
  input[type=file]{display:none;}
  .progress{height:12px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden;border:1px solid var(--border);}
  .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#9bffd6);transition:width .15s ease;}
  .statline{display:flex;gap:10px;align-items:center;font-size:13px;color:var(--muted);}
  .toggle{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;}
  .toggle input{width:0;height:0;appearance:none;}
  .pill{width:44px;height:24px;background:rgba(255,255,255,.12);border-radius:999px;border:1px solid var(--border);position:relative;}
  .dot{position:absolute;top:50%;transform:translateY(-50%);left:3px;width:18px;height:18px;border-radius:50%;background:var(--text);transition:left .15s ease;}
  .toggle input:checked + .pill .dot{left:23px;}
  .pill-badge{border:1px solid var(--border);border-radius:999px;padding:4px 8px;}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.75);z-index:1000;}
  .modal.open{display:flex;}
  .modal-inner{max-width:min(96vw,1600px);max-height:92vh;background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow);overflow:hidden;display:grid;grid-template-rows:auto 1fr;}
  .modal-header{display:flex;gap:8px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);}
  .modal-header .spacer{flex:1;}
  .modal-img-wrap{display:grid;place-items:center;background:#000;width:100%;height:100%;}
  .modal-img{max-width:100%;max-height:100%;object-fit:contain;background:#111;}
  .icon-btn{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--card);font-weight:700;cursor:pointer;}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor ‚Äî Overdrive</h1>
        <div class="hint">Embedded + inline + signature sweeps + attachments. Lossless decodes (Flate/LZW/CCITT/Indexed/Lab/CMYK), lossy originals (JPEG/JP2), and strategy/quality labels. 100% local.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark">
        <span class="small">Light</span><input id="themeToggle" type="checkbox" /><span class="pill"><span class="dot"></span></span><span class="small">Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex;flex-direction:column;gap:16px;">
  <section class="panel" id="dropZone">
    <div class="row" style="gap:8px;align-items:center;">
      <label class="btn" for="fileInput">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf" />
      <button id="startBtn" class="primary" disabled>‚ñ∂Ô∏è Start</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <span class="pill-badge">
        <label class="toggle" title="Hide small/low-info artifacts (icons, pixels)">
          <span class="small">Hide junk</span>
          <input id="hideJunkToggle" type="checkbox" checked />
          <span class="pill"><span class="dot"></span></span>
        </label>
      </span>

      <span class="pill-badge">
        <label class="toggle" title="Scan every decoded stream & object (slower, deeper)">
          <span class="small">Aggressive</span>
          <input id="aggrToggle" type="checkbox" />
          <span class="pill"><span class="dot"></span></span>
        </label>
      </span>

      <button id="defaultSortBtn" disabled>Sort: Size</button>
      <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>

      <button id="downloadSelectedZipBtn" class="success" disabled>ZIP Selected</button>
      <button id="downloadAllZipBtn" disabled>ZIP All</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top:12px;display:grid;gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start</b>.</div>
  </section>

  <section class="small">
    <b>Tip:</b> If anything still seems missing, toggle <b>Aggressive</b> and run again‚Äîthis hunts inside decoded content streams too. Attachments are also scanned.
  </section>
</main>

<!-- Modal preview -->
<div id="modal" class="modal" aria-hidden="true">
  <div class="modal-inner" role="dialog" aria-modal="true" aria-label="Image preview">
    <div class="modal-header">
      <div id="modalTitle" class="small"></div>
      <div class="spacer"></div>
      <button id="modalDownload" class="icon-btn">‚¨áÔ∏è Download PNG</button>
      <button id="modalClose" class="icon-btn">‚úñ</button>
    </div>
    <div class="modal-img-wrap"><img id="modalImg" class="modal-img" alt="Preview"/></div>
  </div>
</div>

<script>
/* Theme */
(function(){
  const root=document.documentElement, t=document.getElementById('themeToggle');
  const saved=localStorage.getItem('pdfimg_theme')||'dark';
  if(saved==='light'){ root.classList.add('light'); t.checked=false; } else t.checked=true;
  t.addEventListener('change',()=>{ if(t.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); } else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }});
})();
</script>

<script>
/* =================== App wiring =================== */
const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
  hideJunkToggle: document.getElementById('hideJunkToggle'),
  aggrToggle: document.getElementById('aggrToggle'),
  dropZone: document.getElementById('dropZone'),
  modal: document.getElementById('modal'),
  modalImg: document.getElementById('modalImg'),
  modalClose: document.getElementById('modalClose'),
  modalDownload: document.getElementById('modalDownload'),
  modalTitle: document.getElementById('modalTitle'),
};

let state = {
  pdfFile:null, pdfNameBase:'images',
  raw:null, text:null,
  objects:[], objMap:new Map(),
  images:[],
  removedDuplicates:0, removedNearDuplicates:0, removedJunk:0,
  sortMode:'default'
};

function baseName(n){ const b=n.replace(/\.[Pp][Dd][Ff]$/,'').replace(/[^a-zA-Z0-9_\-]+/g,'_').toLowerCase(); return b.slice(0,12)||'images'; }
els.fileInput.addEventListener('change',()=>{ const f=els.fileInput.files?.[0]; if(!f) return; state.pdfFile=f; els.pdfName.textContent=f.name; state.pdfNameBase=baseName(f.name); els.startBtn.disabled=false; });
['dragenter','dragover'].forEach(ev=>els.dropZone.addEventListener(ev,e=>{e.preventDefault(); e.dataTransfer.dropEffect='copy'; els.dropZone.classList.add('hover');}));
['dragleave','drop'].forEach(ev=>els.dropZone.addEventListener(ev,e=>{e.preventDefault(); els.dropZone.classList.remove('hover');}));
els.dropZone.addEventListener('drop',e=>{ const f=e.dataTransfer.files?.[0]; if(!f) return; if(!/\.pdf$/i.test(f.name)){alert('Please drop a PDF.');return;} state.pdfFile=f; els.pdfName.textContent=f.name; state.pdfNameBase=baseName(f.name); els.startBtn.disabled=false; });

/* Modal preview */
let modalItem=null;
function openModal(it){ modalItem=it; els.modalImg.src=it.srcObjectUrl; els.modalTitle.textContent=`${it.name} ‚Äî ${it.width}√ó${it.height}px ‚Ä¢ ${it.mb.toFixed(2)} MB ‚Ä¢ ${it.strategy} ‚Ä¢ ${it.source} ${it.lossless?'(Lossless)':'(Lossy)'}`; els.modal.classList.add('open'); els.modal.setAttribute('aria-hidden','false'); }
function closeModal(){ els.modal.classList.remove('open'); els.modal.setAttribute('aria-hidden','true'); els.modalImg.src=''; modalItem=null; }
els.modalClose.addEventListener('click', closeModal);
els.modal.addEventListener('click', e=>{ if(e.target===els.modal) closeModal(); });
window.addEventListener('keydown', e=>{ if(e.key==='Escape' && els.modal.classList.contains('open')) closeModal(); });
els.modalDownload.addEventListener('click', ()=>{ if(!modalItem) return; const a=document.createElement('a'); a.href=modalItem.srcObjectUrl; a.download=modalItem.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

/* UI helpers */
function resetUI(){ state.images=[]; state.removedDuplicates=0; state.removedNearDuplicates=0; state.removedJunk=0; state.sortMode='default';
  els.gallery.innerHTML=''; els.stats.textContent='';
  [els.defaultSortBtn,els.smartSortBtn,els.selectAllBtn,els.deselectAllBtn,els.downloadSelectedZipBtn,els.downloadAllZipBtn].forEach(b=>b.disabled=true);
  progress(0,'Preparing‚Ä¶');
}
function enablePost(){ [els.defaultSortBtn,els.smartSortBtn,els.selectAllBtn,els.deselectAllBtn,els.downloadSelectedZipBtn,els.downloadAllZipBtn].forEach(b=>b.disabled=false); }
function progress(p,t){ els.bar.style.width=`${Math.max(0,Math.min(100,p))}%`; els.progressText.textContent=t; }
function showEmpty(msg){ els.gallery.innerHTML=`<div class="empty">${msg}</div>`; }
function updateStats(){ const s=`Images: <b>${state.images.length}</b> &nbsp;|&nbsp; Removed exact: <b>${state.removedDuplicates}</b> &nbsp;|&nbsp; Removed near: <b>${state.removedNearDuplicates}</b> &nbsp;|&nbsp; Hidden junk: <b>${state.removedJunk}</b>`; els.stats.innerHTML=s; }

/* Start */
els.startBtn.addEventListener('click', async ()=>{
  if(!state.pdfFile) return;
  resetUI();
  try{
    state.raw = new Uint8Array(await state.pdfFile.arrayBuffer());
    state.text = new TextDecoder('latin1').decode(state.raw);

    progress(6,'Indexing‚Ä¶'); indexObjectsSafe();
    progress(14,'Expanding object streams‚Ä¶'); await expandObjectStreams();

    progress(24,'Scanning embedded/inline‚Ä¶');
    let items = await collectAllImages(); // embedded + inline

    progress(34,'Signature sweep (file)‚Ä¶');
    items.push(...signatureSweepWholeFile());

    if(els.aggrToggle.checked){
      progress(42,'Signature sweep (decoded streams)‚Ä¶');
      items.push(...(await signatureSweepDecodedStreams()));
    }

    progress(50,'Attachments (EmbeddedFile)‚Ä¶');
    items.push(...(await collectEmbeddedFiles()));

    if(!items.length){ showEmpty('No images found.'); updateStats(); progress(100,'Done.'); return; }

    progress(58,'Decoding & converting‚Ä¶');
    await convertAllToPNG(items);

    progress(78,'Deduplicating‚Ä¶'); await dedupeExact(); await dedupePerceptual();

    if(els.hideJunkToggle.checked){ progress(86,'Hiding junk‚Ä¶'); filterJunk(); }

    progress(92,'Scoring & labeling‚Ä¶'); scoreQuality();

    progress(96,'Sorting‚Ä¶'); sortImages();
    renderImages(); enablePost(); progress(100,'Ready.'); updateStats();
  }catch(e){ console.error(e); showEmpty('Failed to process PDF (corrupt/unsupported).'); progress(0,'Error.'); }
});

/* =================== Robust object indexer =================== */
function indexObjectsSafe(){
  state.objects=[]; state.objMap.clear();
  const s=state.text;
  const re = /(\d+)\s+(\d+)\s+obj\b/g;
  let m;
  while((m=re.exec(s))!==null){
    const obj=+m[1], gen=+m[2];
    let dictRange=findBalancedDictRangeFrom(s, re.lastIndex);
    let dictStr='', dictEndIdx=m.index;
    if(dictRange){ dictStr=s.slice(dictRange[0]+2, dictRange[1]-2); dictEndIdx=dictRange[1]; }
    const endobjIdx = s.indexOf('endobj', dictEndIdx);
    let streamStart=-1, streamEnd=-1;
    if(endobjIdx!==-1){
      const si = s.indexOf('stream', dictEndIdx);
      if(si!==-1 && si<endobjIdx){
        let ds=si+6;
        if(s[ds]==='\r'&&s[ds+1]==='\n') ds+=2; else if(s[ds]==='\n'||s[ds]==='\r') ds+=1;
        streamStart = ds;
        let len = pickInt(dictStr, /\/Length\s+(\d+)/);
        if(len==null){
          const r = rxRef(dictStr,'Length');
          if(r){ len = Math.floor(findNumericObjectValue(r.obj, r.gen)); }
        }
        if(Number.isFinite(len) && len>=0) streamEnd = streamStart + len;
        else { const es = s.indexOf('endstream', ds); if(es!==-1) streamEnd = es; }
        if(streamEnd>state.raw.length) streamEnd = state.raw.length;
      }
    }
    const endIndex = endobjIdx!==-1 ? endobjIdx+6 : (streamEnd>0?streamEnd:dictEndIdx);
    const rec={kind:'normal',obj,gen,startIndex:m.index,endIndex,dictStr,streamStart,streamEnd};
    state.objects.push(rec);
    state.objMap.set(`${obj} ${gen}`, rec);
    re.lastIndex = endIndex;
  }
}
function findBalancedDictRangeFrom(src, from){
  const i = src.indexOf('<<', from);
  if(i<0) return null;
  let j=i, depth=0, inStr=false, par=0, inHex=false, inComment=false;
  const n=src.length;
  while(j<n-1){
    const a=src[j], b=src[j+1];
    if(!inStr && !inHex && a==='%' && !inComment){ inComment=true; j++; continue; }
    if(inComment){ if(a==='\n'||a==='\r') inComment=false; j++; continue; }
    if(!inHex && a==='('){ inStr=true; par=1; j++; continue; }
    if(inStr){ if(a==='\\'){ j+=2; continue; } if(a==='(') par++; if(a===')'){ if(--par===0) inStr=false; } j++; continue; }
    if(!inHex && a==='<' && b!=='<'){ inHex=true; j++; continue; }
    if(inHex){ if(a==='>') inHex=false; j++; continue; }
    if(a==='<' && b==='<' ){ depth++; j+=2; continue; }
    if(a==='>' && b==='>' ){ depth--; j+=2; if(depth===0) return [i,j]; continue; }
    j++;
  }
  return null;
}
function pickInt(s, re){ const m=re.exec(s); return m ? parseInt(m[1],10) : null; }
function rxRef(s,key){ const m=new RegExp(`/${key}\\s+(\\d+)\\s+(\\d+)\\s+R`).exec(s); return m?{obj:+m[1],gen:+m[2]}:null; }
function findNumericObjectValue(obj,gen){
  const re=new RegExp(String.raw`${obj}\s+${gen}\s+obj\s+(-?\d+(?:\.\d+)?)\s+endobj`);
  const m=re.exec(state.text);
  if(m) return parseFloat(m[1]);
  return null;
}

/* ============= Expand object streams ============= */
function rxArrayNames(s,key){ const m=new RegExp(`/${key}\\s*\\[([^\\]]+)\\]`).exec(s||''); if(!m) return []; return (m[1].match(/\/[A-Za-z0-9]+/g)||[]).map(x=>x.slice(1)); }
function rxName(s,key){ const m=new RegExp(`/${key}\\s*/([A-Za-z0-9]+)`).exec(s||''); return m?m[1]:null; }
function rxLastInt(src,key){ const re=new RegExp(`/${key}\\s+(-?\\d+)`,'g'); let m,v=null; while((m=re.exec(src||''))!==null) v=parseInt(m[1],10); return v; }
async function expandObjectStreams(){
  for(const rec of state.objects){
    const d=rec.dictStr||''; if(!/\/Type\s*\/ObjStm\b/.test(d)) continue;
    if(!(rec.streamStart>=0 && rec.streamEnd>rec.streamStart)) continue;
    let data=state.raw.subarray(rec.streamStart,rec.streamEnd);
    let filters=rxArrayNames(d,'Filter'); if(!filters.length){ const s=rxName(d,'Filter'); if(s) filters=[s]; }
    for(const f of filters){
      if(/^ASCII85Decode$/i.test(f)) data=ascii85DecodeBytes(data);
      else if(/^ASCIIHexDecode$/i.test(f)) data=asciiHexDecodeBytes(data);
      else if(/^FlateDecode$/i.test(f)) data=await inflate(data);
      else if(/^RunLengthDecode$/i.test(f)) data=runLength(data);
      else if(/^LZWDecode$/i.test(f)) data=lzw(data);
    }
    const N=rxLastInt(d,'N')||0, First=rxLastInt(d,'First')||0;
    const head=new TextDecoder('latin1').decode(data.subarray(0,First));
    const toks=head.trim().split(/\s+/).map(x=>parseInt(x,10)).filter(Number.isFinite);
    if(toks.length<2*N) continue;
    for(let i=0;i<N;i++){
      const obj=toks[2*i], off=toks[2*i+1];
      const start=First+off, end=(i===N-1?data.length:First+toks[2*(i+1)+1]);
      const bytes=data.subarray(start,end);
      const content=new TextDecoder('latin1').decode(bytes);
      const r=findBalancedDictRangeFrom(content, 0); let dictStr='', sStart=-1, sEnd=-1;
      if(r){ const [a,b]=r; dictStr=content.slice(a+2,b-2); const si=content.indexOf('stream',b);
        if(si!==-1){ let ds=si+6; if(content[ds]==='\r'&&content[ds+1]==='\n') ds+=2; else if(content[ds]==='\n'||content[ds]==='\r') ds+=1;
          const rel=content.indexOf('endstream',ds); if(rel!==-1){ sStart=start + ds; sEnd=start + rel; } }
      }
      state.objMap.set(`${obj} 0`, {kind:'objstm',obj,gen:0,content,dictStr,streamStart:sStart,streamEnd:sEnd,_bytes:data, parent:rec});
    }
  }
}
function getObjectBlock(ref){ return ref? state.objMap.get(`${ref.obj} ${ref.gen}`) || null : null; }
function getStreamBytes(rec){ if(!rec) return null; return rec.kind==='objstm' ? rec._bytes?.subarray(rec.streamStart, rec.streamEnd) : state.raw?.subarray(rec.streamStart, rec.streamEnd); }

/* ======= ColorSpace & palette resolution ======= */
function bracketRange(dictStr,key){ const re=new RegExp(`/${key}\\s*\\[`,'g'); const m=re.exec(dictStr||''); if(!m) return null; let i=m.index+m[0].length-1,depth=0; for(let j=i;j<dictStr.length;j++){ if(dictStr[j]=='[') depth++; else if(dictStr[j]==']'){ depth--; if(depth===0) return [i,j+1]; } } return null; }
function parseCSArrayTokens(arrStr){
  return (arrStr.match(/\/[A-Za-z0-9]+|<[^>]*>|(?:\d+\s+\d+\s+R)|-?\d+(?:\.\d+)?|\[|\]|<<[\s\S]*?>>/g)) || [];
}
function parseCSArray(arr){
  const toks=parseCSArrayTokens(arr);
  const head=toks[0];
  if(head==='/ICCBased') return {type:'DeviceRGB'};
  if(head==='/CalRGB') return {type:'CalRGB'};
  if(head==='/CalGray') return {type:'CalGray'};
  if(head==='/Lab') return {type:'Lab'};
  if(head==='/Separation'||head==='/DeviceN'){ const alt = toks[2]||''; if(alt?.startsWith('/')) return {type:alt.slice(1)}; return {type:'DeviceRGB'}; }
  if(head==='/Indexed'){
    let base='DeviceRGB'; if(toks[1]?.startsWith('/')){ const b=toks[1].slice(1); base=(b==='RGB'?'DeviceRGB':b==='G'?'DeviceGray':b); }
    const hival=parseInt(toks[2]||'255',10);
    const paletteToken=toks[3]||'';
    return {type:'Indexed', base, hival, _palTok:paletteToken};
  }
  if(head?.startsWith('/Device')) return {type:head.slice(1)};
  return null;
}
function resolveColorSpace(dictStr){
  let n=rxName(dictStr,'ColorSpace')||rxName(dictStr,'CS'); if(n){ if(n==='RGB') n='DeviceRGB'; if(n==='G') n='DeviceGray'; if(/^Device(RGB|Gray|CMYK)$/.test(n)) return {type:n}; if(/^Cal(RGB|Gray)$/.test(n)) return {type:n}; if(/^Lab$/.test(n)) return {type:'Lab'}; if(/^ICCBased$/.test(n)) return {type:'DeviceRGB'}; }
  const arr=bracketRange(dictStr,'ColorSpace')||bracketRange(dictStr,'CS'); if(arr){ const inner=dictStr.slice(arr[0]+1,arr[1]-1).trim(); const cs=parseCSArray(inner); if(cs) return cs; }
  const ref=rxRef(dictStr,'ColorSpace')||rxRef(dictStr,'CS'); if(ref){ const re=new RegExp(String.raw`${ref.obj}\s+${ref.gen}\s+obj\s+(\[.+?\])\s+endobj`, 's'); const m=re.exec(state.text); if(m){ const cs=parseCSArray(m[1]); if(cs) return cs; } }
  return {type:'DeviceRGB'};
}
function parseDecodeArray(dictStr){
  const r=bracketRange(dictStr,'Decode'); if(!r) return null;
  const inner=dictStr.slice(r[0]+1,r[1]-1).trim();
  const nums=(inner.match(/-?\d+(\.\d+)?/g)||[]).map(Number);
  return nums.length?nums:null;
}
function parseMaskColorArray(dictStr){
  const r=bracketRange(dictStr,'Mask'); if(!r) return null;
  if(/\d+\s+\d+\s+R/.test(dictStr.slice(r[0]+1,r[1]-1))) return null;
  const nums=(dictStr.slice(r[0]+1,r[1]-1).match(/-?\d+/g)||[]).map(Number);
  return nums.length?nums:null;
}
/* Palette for /Indexed (hex string or stream ref) */
async function resolveIndexedPaletteFromDict(dictStr){
  const r=bracketRange(dictStr,'ColorSpace')||bracketRange(dictStr,'CS'); if(!r) return null;
  const inner=dictStr.slice(r[0]+1,r[1]-1).trim();
  const cs=parseCSArray(inner); if(!cs || cs.type!=='Indexed') return null;
  const base=cs.base||'DeviceRGB', hival=cs.hival||255;
  let table=null;
  const palTok=cs._palTok||'';
  if(palTok.startsWith('<')){
    const hex=palTok.replace(/[<>\s]/g,'');
    const out=new Uint8Array(hex.length/2);
    for(let i=0;i<hex.length;i+=2) out[i/2]=parseInt(hex.slice(i,i+2),16)&255;
    table=out;
  } else if(/\d+\s+\d+\s+R/.test(palTok)){
    const m=/(\d+)\s+(\d+)\s+R/.exec(palTok); if(m){
      const ref={obj:+m[1],gen:+m[2]}; const rec=getObjectBlock(ref);
      if(rec && rec.streamStart>=0){
        let bytes=getStreamBytes(rec);
        let filters=rxArrayNames(rec.dictStr||'','Filter'); if(!filters.length){ const s=rxName(rec.dictStr||'','Filter'); if(s) filters=[s]; }
        for(const f of (filters||[])){
          if(/^ASCII85Decode$/i.test(f)) bytes=ascii85DecodeBytes(bytes);
          else if(/^ASCIIHexDecode$/i.test(f)) bytes=asciiHexDecodeBytes(bytes);
          else if(/^FlateDecode$/i.test(f)) bytes=await inflate(bytes);
          else if(/^RunLengthDecode$/i.test(f)) bytes=runLength(bytes);
          else if(/^LZWDecode$/i.test(f)) bytes=lzw(bytes);
        }
        table=bytes;
      }
    }
  }
  if(!table) return null;
  return {base, hival, table};
}

/* ============= /DecodeParms parser ============= */
function dictsForKey(dictStr, key){
  const r=bracketRange(dictStr,key);
  if(r){
    const inner=dictStr.slice(r[0]+1,r[1]-1);
    const out=[]; let idx=0;
    while(idx<inner.length){
      const s=inner.indexOf('<<', idx); if(s<0) break;
      const sub=findBalancedDictRangeFrom(inner, s); if(!sub) break;
      out.push(inner.slice(sub[0]+2, sub[1]-2));
      idx=sub[1];
    }
    return out.length?out:[];
  }
  const single=/\/DecodeParms\s*<<(.*?)>>/s.exec(dictStr);
  if(single) return [single[1]];
  return [];
}
function parseDecodeParms(dictStr, filters){
  const dicts = dictsForKey(dictStr,'DecodeParms');
  if(!dicts.length){
    const p = rxLastInt(dictStr,'Predictor') || 1;
    const cols = rxLastInt(dictStr,'Columns') || null;
    const colors = rxLastInt(dictStr,'Colors') || null;
    const bpc = rxLastInt(dictStr,'BitsPerComponent') || rxLastInt(dictStr,'BPC') || null;
    return {Predictor:p, Columns:cols, Colors:colors, BitsPerComponent:bpc};
  }
  let choose = dicts[dicts.length-1];
  if(filters && filters.length>1){
    const idxFl = filters.findIndex(f=>/^FlateDecode$/i.test(f) || /^LZWDecode$/i.test(f));
    if(idxFl>=0 && dicts[idxFl]) choose=dicts[idxFl];
  }
  const pred = rxLastInt(choose,'Predictor') || 1;
  const cols = rxLastInt(choose,'Columns') || null;
  const colors = rxLastInt(choose,'Colors') || null;
  const bpc = rxLastInt(choose,'BitsPerComponent') || rxLastInt(choose,'BPC') || null;
  return {Predictor:pred, Columns:cols, Colors:colors, BitsPerComponent:bpc};
}

/* ============= Image collection ============= */
async function collectAllImages(){
  const embedded=[], contentStreams=[];
  for(const rec of state.objMap.values()){
    if(!(rec.kind==='normal' || rec.kind==='objstm')) continue;
    const dict=rec.dictStr||''; const hasStream=rec.streamStart>=0 && rec.streamEnd>rec.streamStart; if(!hasStream) continue;

    if(/\/Subtype\s*\/Image\b/.test(dict) || /\/ImageMask\s+true\b/.test(dict)){
      const width=rxLastInt(dict,'Width'), height=rxLastInt(dict,'Height'), bits=(rxLastInt(dict,'BitsPerComponent')??1);
      const isMask = /\/ImageMask\s+true/.test(dict);
      const csInfo = isMask ? {type:'DeviceGray'} : resolveColorSpace(dict);
      let palette=null; if(!isMask){ const pal = await resolveIndexedPaletteFromDict(dict); if(pal) palette=pal; }
      let filters=rxArrayNames(dict,'Filter'); if(!filters.length){ const s=rxName(dict,'Filter'); if(s) filters=[s]; }
      const dp = parseDecodeParms(dict, filters);
      const predictor=dp.Predictor||1;
      const columns=(dp.Columns||width)||width;
      const colors=dp.Colors||null;
      const decodeArr=parseDecodeArray(dict);
      const maskColor=parseMaskColorArray(dict);
      let ccitt=null;
      if((filters||[]).some(f=>/^CCITTFaxDecode$/i.test(f))){
        const k=rxLastInt(dict,'K'); const cols=rxLastInt(dict,'Columns')||width; const rows=rxLastInt(dict,'Rows')||height;
        const blackIs1 = /\/BlackIs1\s+true/.test(dict);
        const endOfLine = /\/EndOfLine\s+true/.test(dict);
        const encodedByteAlign = /\/EncodedByteAlign\s+true/.test(dict);
        ccitt={K:(k??-1), Columns:cols, Rows:rows, BlackIs1:blackIs1, EndOfLine:endOfLine, EncodedByteAlign:encodedByteAlign};
      }
      const sm=rxRef(dict,'SMask');
      let smask=null;
      if(sm){
        const smob=getObjectBlock(sm); if(smob && smob.streamStart>=0){
          const sd=smob.dictStr||''; const sw=rxLastInt(sd,'Width'), sh=rxLastInt(sd,'Height'), sb=rxLastInt(sd,'BitsPerComponent')??8;
          let sfilters=rxArrayNames(sd,'Filter'); if(!sfilters.length){ const ss=rxName(sd,'Filter'); if(ss) sfilters=[ss]; }
          const sdp=parseDecodeParms(sd, sfilters);
          const spredictor=sdp.Predictor||1; const scol=sdp.Columns||sw; const sDecode=parseDecodeArray(sd);
          smask={ width:sw, height:sh, bits:sb, csInfo:{type:'DeviceGray'}, filters:sfilters, predictor:spredictor, columns:scol, bytes:getStreamBytes(smob), decode:sDecode };
        }
      }
      const bytes=getStreamBytes(rec);
      const source = (filters||[]).join('+') || 'raw';
      const lossless = !(filters || []).some(f=>/^DCTDecode$/i.test(f) || /^JPXDecode$/i.test(f));
      embedded.push({ kind:'embedded', strategy:'Embedded Image', source, lossless, width, height, bits, csInfo, filters, predictor, columns, decode:decodeArr, bytes, smask, ccitt, maskColor, imageMask:isMask, colorsHint:colors, palette });
    } else {
      contentStreams.push(rec);
    }
  }

  // Inline images inside decoded content streams (BI ... ID ... EI)
  const inline=[];
  for(const rec of contentStreams){
    let data=getStreamBytes(rec); if(!data) continue;
    let filters=rxArrayNames(rec.dictStr||'','Filter'); if(!filters.length){ const s=rxName(rec.dictStr||'','Filter'); if(s) filters=[s]; }
    for(const f of (filters||[])){
      if(/^ASCII85Decode$/i.test(f)) data=ascii85DecodeBytes(data);
      else if(/^ASCIIHexDecode$/i.test(f)) data=asciiHexDecodeBytes(data);
      else if(/^FlateDecode$/i.test(f)) data=await inflate(data);
      else if(/^RunLengthDecode$/i.test(f)) data=runLength(data);
      else if(/^LZWDecode$/i.test(f)) data=lzw(data);
    }
    const found = await extractInlineWithPalettes(data);
    found.forEach(f=>{ f.strategy='Inline BI'; f.source=(f.filters||[]).join('+')||'raw'; f.lossless = !(f.filters || []).some(x=>/^DCTDecode$/i.test(x) || /^JPXDecode$/i.test(x)); });
    inline.push(...found);
  }

  return embedded.concat(inline);
}
async function extractInlineWithPalettes(u8){
  const W=b=>b===9||b===10||b===12||b===13||b===32, out=[]; let i=0,n=u8.length;
  while(i<n-3){
    if(u8[i]===0x42 && u8[i+1]===0x49 && (i===0||W(u8[i-1])) && W(u8[i+2])){ // "BI"
      i+=2; while(i<n && W(u8[i])) i++; const dStart=i; let idPos=-1;
      for(let j=i;j<n-3;j++){ if(W(u8[j]) && u8[j+1]===0x49 && u8[j+2]===0x44 && W(u8[j+3])){ idPos=j+1; break; } } // " ID "
      if(idPos<0) break;
      const dictBytes=u8.subarray(dStart,idPos-1); i=idPos+2; if(i<n&&W(u8[i])) i++; const dataStart=i; let dataEnd=-1;
      for(let j=i;j<n-3;j++){ if(W(u8[j]) && u8[j+1]===0x45 && u8[j+2]===0x49 && (j+3>=n||W(u8[j+3]))){ dataEnd=j; break; } } // " EI"
      if(dataEnd<0) break;
      const data=u8.subarray(dataStart,dataEnd); i=dataEnd+3;
      const ds=new TextDecoder('latin1').decode(dictBytes);
      const width=rxLastInt(ds,'W')||rxLastInt(ds,'Width'); const height=rxLastInt(ds,'H')||rxLastInt(ds,'Height'); const bits=rxLastInt(ds,'BPC')||8;
      const isMask=/\/ImageMask\s+true/.test(ds);
      const csInfo=isMask?{type:'DeviceGray'}:resolveColorSpace(ds);
      let palette=null; const pal=await resolveIndexedPaletteFromDict(ds); if(pal) palette=pal;
      let filters=rxArrayNames(ds,'F')||rxArrayNames(ds,'Filter'); if(!filters.length){ const s=rxName(ds,'F')||rxName(ds,'Filter'); if(s) filters=[s]; }
      const dp=parseDecodeParms(ds, filters);
      const predictor=dp.Predictor||1; const columns=dp.Columns||width; const decode=parseDecodeArray(ds);
      out.push({kind:'inline', width,height,bits,csInfo,filters,predictor,columns,decode,bytes:data, smask:null, ccitt:null, maskColor:null, imageMask:isMask, palette});
      continue;
    }
    i++;
  }
  return out;
}

/* ============= Signature sweeps ============= */
function signatureSweepWholeFile(){ return tagStrategy(signatureScan(state.raw),'Sig: file'); }
async function signatureSweepDecodedStreams(){
  const out=[];
  for(const rec of state.objMap.values()){
    if(!(rec.streamStart>=0 && rec.streamEnd>rec.streamStart)) continue;
    let data=getStreamBytes(rec); if(!data) continue;
    let filters=rxArrayNames(rec.dictStr||'','Filter'); if(!filters.length){ const s=rxName(rec.dictStr||'','Filter'); if(s) filters=[s]; }
    for(const f of (filters||[])){
      if(/^ASCII85Decode$/i.test(f)) data=ascii85DecodeBytes(data);
      else if(/^ASCIIHexDecode$/i.test(f)) data=asciiHexDecodeBytes(data);
      else if(/^FlateDecode$/i.test(f)) data=await inflate(data);
      else if(/^RunLengthDecode$/i.test(f)) data=runLength(data);
      else if(/^LZWDecode$/i.test(f)) data=lzw(data);
    }
    out.push(...signatureScan(data));
  }
  return tagStrategy(out,'Sig: decoded stream');
}
function tagStrategy(list, strategy){
  list.forEach(it=>{
    it.strategy=strategy;
    if(it._isPng){ it.source='PNG'; it.lossless=true; }
    else if(it._isTiff){ it.source='TIFF'; it.lossless=true; }
    else if(it._isGif){ it.source='GIF'; it.lossless=false; }
    else if(it._isBmp){ it.source='BMP'; it.lossless=true; }
    else if(it._isWebp){ it.source='WEBP'; it.lossless=false; }
    else if(it.filters?.[0]==='DCTDecode'){ it.source='JPEG'; it.lossless=false; }
    else if(it.filters?.[0]==='JPXDecode'){ it.source='JP2'; it.lossless=false; }
  });
  return list;
}
function signatureScan(u){
  const out=[];
  // JPEG
  for(let i=0;i<u.length-3;i++){
    if(u[i]===0xFF && u[i+1]===0xD8 && u[i+2]===0xFF){
      let j=i+2; while(j<u.length-1 && !(u[j]===0xFF && u[j+1]===0xD9)) j++;
      if(j<u.length-1){ out.push(sigItem('jpeg',u.subarray(i,j+2))); i=j+1; }
    }
  }
  // JP2
  const jp2Magic=[0x00,0x00,0x00,0x0C,0x6A,0x50,0x20,0x20,0x0D,0x0A,0x87,0x0A];
  for(let i=0;i<u.length-12;i++){
    let ok=true; for(let k=0;k<12;k++){ if(u[i+k]!==jp2Magic[k]){ ok=false; break; } }
    if(ok){ const end=findBoxEnd(u,i); out.push(sigItem('jp2',u.subarray(i,Math.min(end,u.length)))); }
  }
  // PNG
  const pngMagic=[0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A];
  for(let i=0;i<u.length-8;i++){
    let ok=true; for(let k=0;k<8;k++){ if(u[i+k]!==pngMagic[k]){ ok=false; break; } }
    if(ok){
      let j=i+8;
      while(j+12<=u.length){
        const len=((u[j]<<24)>>>0)|((u[j+1]<<16)>>>0)|((u[j+2]<<8)>>>0)|u[j+3];
        const type=String.fromCharCode(u[j+4],u[j+5],u[j+6],u[j+7]);
        j+=8+len+4;
        if(type==='IEND'){ out.push(sigItem('png',u.subarray(i,j))); break; }
      }
    }
  }
  // TIFF
  for(let i=0;i<u.length-4;i++){
    const isII = u[i]===0x49&&u[i+1]===0x49&&u[i+2]===0x2A&&u[i+3]===0x00;
    const isMM = u[i]===0x4D&&u[i+1]===0x4D&&u[i+2]===0x00&&u[i+3]===0x2A;
    if(isII||isMM){ const end=i+8*1024*1024; out.push(sigItem('tiff',u.subarray(i,Math.min(end,u.length)))); }
  }
  // GIF
  for(let i=0;i<u.length-6;i++){
    if(u[i]===0x47&&u[i+1]===0x49&&u[i+2]===0x46&&u[i+3]===0x38&&(u[i+4]===0x39||u[i+4]===0x37)&&u[i+5]===0x61){
      const end=i+8*1024*1024; out.push(sigItem('gif',u.subarray(i,Math.min(end,u.length))));
    }
  }
  // BMP
  for(let i=0;i<u.length-2;i++){
    if(u[i]===0x42&&u[i+1]===0x4D){ const end=i+8*1024*1024; out.push(sigItem('bmp',u.subarray(i,Math.min(end,u.length)))); }
  }
  // WEBP
  for(let i=0;i<u.length-12;i++){
    if(u[i]===0x52&&u[i+1]===0x49&&u[i+2]===0x46&&u[i+3]===0x46 && u[i+8]===0x57&&u[i+9]===0x45&&u[i+10]===0x42&&u[i+11]===0x50){
      const size = u[i+4] | (u[i+5]<<8) | (u[i+6]<<16) | (u[i+7]<<24);
      const end = Math.min(u.length, i+8+size);
      out.push(sigItem('webp', u.subarray(i, end)));
    }
  }
  return out;
}
function sigItem(kind, bytes){
  const common = { kind:'signature', width:0, height:0, bits:8, csInfo:{type:'DeviceRGB'}, predictor:1, columns:0, decode:null, smask:null, ccitt:null, maskColor:null, imageMask:false, palette:null };
  if(kind==='jpeg') return {...common, filters:['DCTDecode'], bytes};
  if(kind==='jp2')  return {...common, filters:['JPXDecode'], bytes};
  if(kind==='png')  return {...common, _isPng:true, filters:[], bytes};
  if(kind==='tiff') return {...common, _isTiff:true, filters:[], bytes};
  if(kind==='gif')  return {...common, _isGif:true, filters:[], bytes};
  if(kind==='bmp')  return {...common, _isBmp:true, filters:[], bytes};
  if(kind==='webp') return {...common, _isWebp:true, filters:[], bytes};
}
function findBoxEnd(u, start){ return Math.min(u.length, start + 8*1024*1024); }

/* ============= Attachments (EmbeddedFile / Filespec) ============= */
async function collectEmbeddedFiles(){
  const found=[];
  for(const rec of state.objMap.values()){
    const d=rec.dictStr||'';
    const isEF = /\/Type\s*\/EmbeddedFile\b/.test(d);
    if(isEF && rec.streamStart>=0){
      let bytes=getStreamBytes(rec);
      let filters=rxArrayNames(d,'Filter'); if(!filters.length){ const s=rxName(d,'Filter'); if(s) filters=[s]; }
      for(const f of (filters||[])){
        if(/^ASCII85Decode$/i.test(f)) bytes=ascii85DecodeBytes(bytes);
        else if(/^ASCIIHexDecode$/i.test(f)) bytes=asciiHexDecodeBytes(bytes);
        else if(/^FlateDecode$/i.test(f)) bytes=await inflate(bytes);
        else if(/^RunLengthDecode$/i.test(f)) bytes=runLength(bytes);
        else if(/^LZWDecode$/i.test(f)) bytes=lzw(bytes);
      }
      // the file may itself be an image format
      const sigs=signatureScan(bytes);
      sigs.forEach(s=>{ s.strategy='Attachment'; if(s._isPng){ s.source='PNG'; s.lossless=true;} else if(s._isTiff){ s.source='TIFF'; s.lossless=true;} else if(s._isGif){ s.source='GIF'; s.lossless=false;} else if(s._isBmp){ s.source='BMP'; s.lossless=true;} else if(s._isWebp){ s.source='WEBP'; s.lossless=false;} else if(s.filters?.[0]==='DCTDecode'){ s.source='JPEG'; s.lossless=false;} else if(s.filters?.[0]==='JPXDecode'){ s.source='JP2'; s.lossless=false;} });
      found.push(...sigs);
    }
  }
  // Some PDFs use /Filespec with EF->F/UF references; but those EF objects will be covered above.
  return found;
}

/* ============= Filters ============= */
function ascii85DecodeBytes(u8){ const s=new TextDecoder('ascii').decode(u8); return ascii85DecodeString(s); }
function ascii85DecodeString(str){
  const s=str.replace(/<~/g,'').replace(/~>/g,'').replace(/\s+/g,''); const out=[]; let g=[];
  for(let i=0;i<s.length;i++){ const c=s[i]; if(c==='z' && g.length===0){ out.push(0,0,0,0); continue; }
    const code=s.charCodeAt(i); if(code<33||code>117) continue; g.push(code-33);
    if(g.length===5){ let v=0; for(let j=0;j<5;j++) v=v*85+g[j]; out.push((v>>>24)&255,(v>>>16)&255,(v>>>8)&255,v&255); g.length=0; } }
  if(g.length>0){ for(let k=g.length;k<5;k++) g.push(84); let v=0; for(let j=0;j<5;j++) v=v*85+g[j]; for(let j=0;j<g.length-1;j++) out.push((v>>>(24-8*j))&255); }
  return new Uint8Array(out);
}
function asciiHexDecodeBytes(u8){ let s=new TextDecoder('ascii').decode(u8); const end=s.indexOf('>'); if(end!==-1) s=s.slice(0,end); s=s.replace(/\s+/g,''); if(s.length%2===1) s+='0'; const out=new Uint8Array(s.length/2); for(let i=0;i<s.length;i+=2) out[i/2]=parseInt(s.substr(i,2),16)&255; return out; }
async function inflate(u8){ if('DecompressionStream' in window){ const ds=new DecompressionStream('deflate'); const out=await new Response(new Response(new Blob([u8])).body.pipeThrough(ds)).arrayBuffer(); return new Uint8Array(out); } throw new Error('Deflate not supported in this browser'); }
function runLength(u8){ const out=[]; for(let i=0;i<u8.length;){ const n=u8[i++]; if(n===128) break; if(n<128){ const c=n+1; for(let k=0;k<c;k++) out.push(u8[i+k]); i+=c; } else { const c=257-n; const b=u8[i++]; for(let k=0;k<c;k++) out.push(b); } } return new Uint8Array(out); }
function lzw(data){
  let pos=0,bit=0; const CLEAR=256,EOD=257; let codeSz=9,dict=[],prev=null,out=[];
  for(let i=0;i<256;i++) dict[i]=new Uint8Array([i]); dict[CLEAR]=dict[EOD]=null;
  function readBit(){ if(pos>=data.length) return null; const v=(data[pos]>>(7-bit))&1; bit++; if(bit===8){bit=0;pos++;} return v; }
  function readCode(n){ let v=0; for(let i=0;i<n;i++){ const b=readBit(); if(b===null) return null; v=(v<<1)|b; } return v; }
  function cat(a,b){ const r=new Uint8Array(a.length+b.length); r.set(a); r.set(b,a.length); return r; }
  while(true){ let code=readCode(codeSz); if(code===null) break; if(code===CLEAR){ dict=[]; for(let i=0;i<256;i++) dict[i]=new Uint8Array([i]); dict[CLEAR]=dict[EOD]=null; codeSz=9; prev=null; continue; } if(code===EOD) break;
    let entry=dict[code] ? dict[code] : (prev!=null? cat(dict[prev], new Uint8Array([dict[prev][0]])) : new Uint8Array([code]));
    out.push(...entry); if(prev!=null) dict.push(cat(dict[prev], new Uint8Array([entry[0]]))); prev=code; if(dict.length===(1<<codeSz) && codeSz<12) codeSz++; }
  return new Uint8Array(out);
}

/* ============= Convert ‚Üí PNG ============= */
async function convertAllToPNG(items){
  const res=[]; const total=items.length;
  for(let i=0;i<total;i++){
    progress(58+Math.round((i/Math.max(1,total))*18),`Decoding ${i+1}/${total}‚Ä¶`);
    try{
      const blob = await convertOne(items[i]);
      if(!blob) continue;
      const ab=await blob.arrayBuffer(); const mb=ab.byteLength/(1024*1024);
      const {w,h}=await sizeFromBlob(blob, items[i].width, items[i].height);
      const url=URL.createObjectURL(blob);
      const name=`${state.pdfNameBase}_img${res.length+1}.png`;
      res.push({id:'img'+(res.length+1),pngBlob:blob,width:w,height:h,mb,name,selected:false,srcObjectUrl:url,_sha:null,_ahash:null, strategy:items[i].strategy||'Unknown', source:items[i].source||inferSource(items[i]), lossless: !!items[i].lossless});
    }catch(e){ console.warn('Image failed:', e); }
  }
  state.images=res;
}
function inferSource(item){
  if(item._isPng) return 'PNG';
  if(item._isTiff) return 'TIFF';
  if(item._isGif) return 'GIF';
  if(item._isBmp) return 'BMP';
  if(item._isWebp) return 'WEBP';
  if(item.filters?.[0]==='DCTDecode') return 'JPEG';
  if(item.filters?.[0]==='JPXDecode') return 'JP2';
  const f=(item.filters||[]).join('+')||'raw'; return f;
}
async function convertOne(item){
  if(item._isPng){ item.lossless=true; return new Blob([item.bytes],{type:'image/png'}); }
  if(item._isTiff){ item.lossless=true; try{ return await imageBlobToPNG(new Blob([item.bytes],{type:'image/tiff'})); }catch{ return null; } }
  if(item._isGif){ item.lossless=false; try{ return await imageBlobToPNG(new Blob([item.bytes],{type:'image/gif'})); }catch{ return null; } }
  if(item._isBmp){ item.lossless=true; try{ return await imageBlobToPNG(new Blob([item.bytes],{type:'image/bmp'})); }catch{ return null; } }
  if(item._isWebp){ item.lossless=false; try{ return await imageBlobToPNG(new Blob([item.bytes],{type:'image/webp'})); }catch{ return null; } }

  if(item.filters && item.filters.length===1 && /^DCTDecode$/i.test(item.filters[0])){ item.lossless=false; return jpegToPng(item.bytes, item.width, item.height); }
  if(item.filters && item.filters.length===1 && /^JPXDecode$/i.test(item.filters[0])){ item.lossless=false; return jpxToPng(item.bytes, item.width, item.height); }

  if(item.filters?.some(f=>/^CCITTFaxDecode$/i.test(f)) && item.ccitt){
    item.lossless=true; return await ccittToPNG(item);
  }

  // Decode filter chain ‚Üí raw raster
  let data=item.bytes; const filters=item.filters||[];
  item.lossless = true;
  for(const f of filters){
    if(/^ASCII85Decode$/i.test(f)) data=ascii85DecodeBytes(data);
    else if(/^ASCIIHexDecode$/i.test(f)) data=asciiHexDecodeBytes(data);
    else if(/^FlateDecode$/i.test(f)) data=await inflate(data);
    else if(/^RunLengthDecode$/i.test(f)) data=runLength(data);
    else if(/^LZWDecode$/i.test(f)) data=lzw(data);
    else if(/^DCTDecode$/i.test(f)){ item.lossless=false; return jpegToPng(data, item.width, item.height); }
    else if(/^JPXDecode$/i.test(f)){ item.lossless=false; return jpxToPng(data, item.width, item.height); }
    else if(/^JBIG2Decode$/i.test(f)){ console.warn('JBIG2 image detected (unsupported in browsers).'); return null; }
    else { console.warn('Unknown filter', f, '‚Äî attempting to continue with current bytes'); }
  }
  return rasterToPng(item, data);
}

/* JPEG/JPX helpers */
async function jpegToPng(u8,w,h){ const blob=new Blob([u8],{type:'image/jpeg'}); const {canvas,img}=await draw(blob,w,h); const out=await toPng(canvas); try{URL.revokeObjectURL(img.src);}catch{} return out; }
async function jpxToPng(u8,w,h){ const blob=new Blob([u8],{type:'image/jp2'}); try{ const {canvas,img}=await draw(blob,w,h); const out=await toPng(canvas); try{URL.revokeObjectURL(img.src);}catch{} return out; }catch{ console.warn('JP2 unsupported'); return null; } }

/* Raster path (predictors, sub-byte, color spaces, masks, palette, padding) */
function bytesPerPixelBytes(bits, comps){ return Math.ceil((bits*comps)/8); }
function rowBytesPacked(width, bits, comps){ return Math.ceil((width*bits*comps)/8); }
function undoPngPredictionPacked(inflated, width, bits, comps, rows){
  const bpp = bytesPerPixelBytes(bits, comps);
  const rowBytes = rowBytesPacked(width, bits, comps);
  const out = new Uint8Array(rowBytes*rows);
  const prior = new Uint8Array(rowBytes);
  let src=0,dst=0;
  for(let y=0;y<rows;y++){
    const ft=inflated[src++]; switch(ft){
      case 0: out.set(inflated.subarray(src,src+rowBytes),dst); break;
      case 1: for(let x=0;x<rowBytes;x++){ const left=(x>=bpp)?out[dst+x-bpp]:0; out[dst+x]=(inflated[src+x]+left)&255; } break;
      case 2: for(let x=0;x<rowBytes;x++){ const up=prior[x]||0; out[dst+x]=(inflated[src+x]+up)&255; } break;
      case 3: for(let x=0;x<rowBytes;x++){ const left=(x>=bpp)?out[dst+x-bpp]:0, up=prior[x]||0; out[dst+x]=(inflated[src+x]+((left+up)>>1))&255; } break;
      case 4: for(let x=0;x<rowBytes;x++){ const left=(x>=bpp)?out[dst+x-bpp]:0, up=prior[x]||0, ul=(x>=bpp)?prior[x-bpp]:0; out[dst+x]=(inflated[src+x]+paeth(left,up,ul))&255; } break;
      default: out.set(inflated.subarray(src,src+rowBytes),dst);
    }
    prior.set(out.subarray(dst,dst+rowBytes)); src+=rowBytes; dst+=rowBytes;
  }
  return out;
}
function undoTiffPredictor2(bytes, width, bits, comps, rows){
  if(bits!==8) return bytes;
  const bpp = comps;
  const rowBytes = width * bpp;
  const out = new Uint8Array(bytes.length);
  let src=0, dst=0;
  for(let y=0;y<rows;y++){
    for(let x=0;x<rowBytes;x++){
      const left = (x>=bpp) ? out[dst + x - bpp] : 0;
      out[dst + x] = (bytes[src + x] + left) & 255;
    }
    src+=rowBytes; dst+=rowBytes;
  }
  return out;
}
function stripRowPadding8bit(bytes, width, comps, height){
  const row = width*comps;
  const stride = Math.floor(bytes.length/height);
  if(stride===row || stride<row) return bytes;
  const out=new Uint8Array(row*height);
  for(let y=0;y<height;y++){
    out.set(bytes.subarray(y*stride, y*stride+row), y*row);
  }
  return out;
}
function unpackSamples(packed, width, height, bits, comps){
  if(bits===8) return packed;
  const samples = new Uint8Array(width*height*comps);
  const maxv=(1<<bits)-1, scale = 255/maxv;
  if(bits===4){
    let idx=0;
    for(let y=0;y<height;y++){
      for(let x=0;x<width*comps;x+=2){
        const b=packed[idx++]; const hi=(b>>4)&0xF, lo=b&0xF;
        const i=(y*width*comps + x);
        samples[i]=Math.round(hi*scale);
        if(x+1<width*comps) samples[i+1]=Math.round(lo*scale);
      }
    }
  } else if(bits===2 || bits===1){
    let bitPos=0, byteIdx=0;
    for(let y=0;y<height;y++){
      for(let x=0;x<width*comps;x++){
        const b=packed[byteIdx]; const shift= (bits===2) ? (6-(bitPos&7)) : (7-(bitPos&7));
        const mask=(bits===2)?0x03:0x01;
        const v=(b>>shift)&mask; const i=(y*width*comps + x);
        samples[i]=Math.round((v*((1<<bits)-1))*scale);
        bitPos+=bits; if((bitPos&7)===0) byteIdx++;
      }
      if((bitPos&7)!==0){ byteIdx++; bitPos=0; }
    }
  } else {
    const view=new DataView(packed.buffer, packed.byteOffset, packed.byteLength);
    let di=0;
    for(let i=0;i<width*height*comps;i++){ const v=view.getUint16(i*2,false); samples[di++]=Math.round((v/65535)*255); }
  }
  return samples;
}
function applyDecodePerComponent(samples, comps, decode){
  if(!decode || !decode.length) return samples;
  const out=new Uint8Array(samples.length);
  const pairs=[];
  for(let i=0;i<comps;i++){ const a=decode[i*2] ?? 0, b=decode[i*2+1] ?? 1; pairs.push([a,b]); }
  for(let i=0;i<samples.length;i+=comps){
    for(let c=0;c<comps;c++){
      const [a,b]=pairs[c] || [0,1];
      const t = samples[i+c]/255;
      const v = a + (b-a)*t;
      out[i+c]=Math.max(0,Math.min(255,Math.round(v*255)));
    }
  }
  return out;
}
function labToSRGB(L,a,b){
  const y=(L+16)/116, x=a/500 + y, z=y - b/200;
  const X=95.047*labInv(x), Y=100.000*labInv(y), Z=108.883*labInv(z);
  let r =  3.2406*(X/100) -1.5372*(Y/100) -0.4986*(Z/100);
  let g = -0.9689*(X/100) +1.8758*(Y/100) +0.0415*(Z/100);
  let bl=  0.0557*(X/100) -0.2040*(Y/100) +1.0570*(Z/100);
  r = gamma(r); g = gamma(g); bl = gamma(bl);
  return [clamp255(r*255),clamp255(g*255),clamp255(bl*255)];
  function labInv(t){ const e=0.008856, k=7.787; return (t**3>e)? t**3 : (t-16/116)/k; }
  function gamma(c){ return c<=0.0031308 ? 12.92*c : 1.055*Math.pow(c,1/2.4)-0.055; }
  function clamp255(v){ return v<0?0:v>255?255:v|0; }
}
async function rasterToPng(item, raw){
  const {width,height,bits,csInfo,predictor,columns,decode,smask,maskColor,imageMask,colorsHint, palette} = item;
  let comps = (csInfo.type==='DeviceRGB')?3:(csInfo.type==='DeviceGray')?1:(csInfo.type==='DeviceCMYK')?4:(csInfo.type==='Indexed')?1:(csInfo.type==='CalRGB')?3:(csInfo.type==='CalGray')?1:(csInfo.type==='Lab')?3: (colorsHint||3);

  // predictor recovery
  let bytes;
  if(predictor===1){ bytes = raw; }
  else if(predictor===2){ if(bits===8) bytes=undoTiffPredictor2(raw, columns||width, bits, comps, height); else bytes=raw; }
  else if(predictor>=10 && predictor<=15){ bytes=undoPngPredictionPacked(raw, columns||width, bits, comps, height); }
  else { bytes=raw; }

  if(bits===8 && bytes.length !== width*height*comps){
    bytes = stripRowPadding8bit(bytes, width, comps, height);
  }

  let samples = (bits===8)? bytes : unpackSamples(bytes, width, height, bits, comps);
  samples = applyDecodePerComponent(samples, comps, decode);

  // Build RGBA
  let rgba = new Uint8ClampedArray(width*height*4);

  if(imageMask){
    const inv = decode && decode.length>=2 && decode[0]===1 && decode[1]===0;
    const alpha = samples;
    for(let i=0,di=0;i<width*height;i++,di+=4){
      const v = alpha[i];
      const a = inv ? (255 - v) : v;
      rgba[di]=255; rgba[di+1]=255; rgba[di+2]=255; rgba[di+3]=a;
    }
  }
  else if(csInfo.type==='DeviceRGB' || csInfo.type==='CalRGB'){
    let si=0, di=0, n=width*height; for(let i=0;i<n;i++){ rgba[di++]=samples[si++]; rgba[di++]=samples[si++]; rgba[di++]=samples[si++]; rgba[di++]=255; }
  } else if(csInfo.type==='DeviceGray' || csInfo.type==='CalGray'){
    let si=0, di=0, n=width*height; for(let i=0;i<n;i++){ const v=samples[si++]; rgba[di++]=v; rgba[di++]=v; rgba[di++]=v; rgba[di++]=255; }
  } else if(csInfo.type==='Lab'){
    let si=0, di=0, n=width*height; for(let i=0;i<n;i++){
      const L = samples[si++] * (100/255);
      const a = samples[si++] - 128;
      const b = samples[si++] - 128;
      const [r,g,bl]=labToSRGB(L,a,b);
      rgba[di++]=r; rgba[di++]=g; rgba[di++]=bl; rgba[di++]=255;
    }
  } else if(csInfo.type==='DeviceCMYK'){
    let si=0, di=0, n=width*height;
    for(let i=0;i<n;i++){
      const C=samples[si++]/255, M=samples[si++]/255, Y=samples[si++]/255, K=samples[si++]/255;
      const R = 255 * (1 - Math.min(1, C + K));
      const G = 255 * (1 - Math.min(1, M + K));
      const B = 255 * (1 - Math.min(1, Y + K));
      rgba[di++]=R|0; rgba[di++]=G|0; rgba[di++]=B|0; rgba[di++]=255;
    }
  } else if(csInfo.type==='Indexed'){
    let di=0;
    if(palette && palette.table){
      const table=palette.table; const hival=palette.hival||255; const step=(palette.base==='DeviceRGB')?3:1;
      for(let i=0;i<width*height;i++){
        const idx=Math.min(samples[i], hival);
        if(step===3){
          const ti=idx*3; rgba[di++]=table[ti]||0; rgba[di++]=table[ti+1]||0; rgba[di++]=table[ti+2]||0; rgba[di++]=255;
        } else {
          const v=table[idx]||0; rgba[di++]=v; rgba[di++]=v; rgba[di++]=v; rgba[di++]=255;
        }
      }
    } else {
      for(let i=0;i<width*height;i++){ const v=samples[i]; rgba[di++]=v; rgba[di++]=v; rgba[di++]=v; rgba[di++]=255; }
    }
  } else {
    let si=0, di=0, n=width*height; for(let i=0;i<n;i++){ const v=samples[si++]; rgba[di++]=v; rgba[di++]=v; rgba[di++]=v; rgba[di++]=255; }
  }

  // color-key transparency (if present)
  applyColorKeyMaskRGBA(rgba, width, height, maskColor, csInfo.type||'DeviceRGB');

  // soft mask alpha
  if(item.smask){ const alpha = await decodeGrayMask(item.smask); if(alpha && alpha.length===width*height){ for(let i=0,di=3;i<alpha.length;i++,di+=4) rgba[di]=alpha[i]; } }

  const canvas=document.createElement('canvas'); canvas.width=width; canvas.height=height;
  canvas.getContext('2d').putImageData(new ImageData(rgba,width,height),0,0);
  return toPng(canvas);
}
function applyColorKeyMaskRGBA(rgba, w, h, maskColor, csType){
  if(!maskColor || !maskColor.length) return;
  const comps = (csType==='DeviceRGB')?3:(csType==='DeviceGray')?1:(csType==='DeviceCMYK')?4:3;
  for(let i=0,px=0;i<w*h;i++,px+=4){
    let match=true;
    if(comps===1){
      const v = rgba[px]; match = (v>=maskColor[0] && v<=maskColor[1]);
    } else if(comps===3){
      const r=rgba[px], g=rgba[px+1], b=rgba[px+2];
      match = (r>=maskColor[0]&&r<=maskColor[1] && g>=maskColor[2]&&g<=maskColor[3] && b>=maskColor[4]&&b<=maskColor[5]);
    } else { match=false; }
    if(match) rgba[px+3]=0;
  }
}
async function decodeGrayMask(m){
  let data=m.bytes; for(const f of (m.filters||[])){
    if(/^ASCII85Decode$/i.test(f)) data=ascii85DecodeBytes(data);
    else if(/^ASCIIHexDecode$/i.test(f)) data=asciiHexDecodeBytes(data);
    else if(/^FlateDecode$/i.test(f)) data=await inflate(data);
    else if(/^RunLengthDecode$/i.test(f)) data=runLength(data);
    else if(/^LZWDecode$/i.test(f)) data=lzw(data);
    else if(/^DCTDecode$/i.test(f)){ const blob=await jpegToPng(data,m.width,m.height); const img=await createImageBitmap(blob); const c=document.createElement('canvas'); c.width=m.width; c.height=m.height; c.getContext('2d').drawImage(img,0,0); const id=c.getContext('2d').getImageData(0,0,m.width,m.height).data; const alpha=new Uint8Array(m.width*m.height); for(let i=0;i<alpha.length;i++) alpha[i]=id[i*4]; img.close(); return alpha; }
  }
  let bytes;
  if(m.predictor===1) bytes=data;
  else if(m.predictor===2 && m.bits===8) bytes=undoTiffPredictor2(data, m.columns||m.width, m.bits, 1, m.height);
  else if(m.predictor>=10 && m.predictor<=15) bytes = undoPngPredictionPacked(data, m.columns||m.width, m.bits, 1, m.height);
  else bytes=data;
  const gray = (m.bits===8)? bytes : unpackSamples(bytes, m.width, m.height, m.bits, 1);
  return applyDecodePerComponent(gray, 1, m.decode);
}

/* ============= CCITT ‚Üí PNG (TIFF wrap) ============= */
async function ccittToPNG(item){
  try{
    const tiff = buildTIFFfromCCITT(item.bytes, item.width, item.height, item.ccitt);
    const blob = new Blob([tiff], {type:'image/tiff'});
    const png = await imageBlobToPNG(blob, item.width, item.height);
    return png;
  }catch(e){ console.warn('CCITT wrap failed', e); return null; }
}
function buildTIFFfromCCITT(ccittBytes, width, height, opts){
  const LE = true;
  const compression = (opts?.K ?? -1) < 0 ? 4 : 3; // 4=Group4, 3=Group3
  const photometric = opts?.BlackIs1 ? 1 : 0;      // 0=WhiteIsZero, 1=BlackIsZero
  const bitsPerSample = 1;
  const rowsPerStrip = height;
  const stripByteCount = ccittBytes.length;

  function u16(v){ const a=new Uint8Array(2); const d=new DataView(a.buffer); d.setUint16(0,v,LE); return a; }
  function u32(v){ const a=new Uint8Array(4); const d=new DataView(a.buffer); d.setUint32(0,v,LE); return a; }
  function cat(...arrs){ let total=0; for(const a of arrs) total+=a.length; const out=new Uint8Array(total); let o=0; for(const a of arrs){ out.set(a,o); o+=a.length; } return out; }
  function entry(tag,type,count,val){ return cat(u16(tag),u16(type),u32(count),u32(val)); }

  const header = cat(new TextEncoder().encode('II'), u16(42), u32(8));
  const numEntries = 9;
  const stripOffset = header.length + 2 + 12*numEntries + 4;

  const ifd = cat(
    u16(numEntries),
    entry(256,4,1,width),             // ImageWidth (LONG)
    entry(257,4,1,height),            // ImageLength (LONG)
    entry(258,3,1,bitsPerSample),     // BitsPerSample (SHORT)
    entry(259,3,1,compression),       // Compression (SHORT)
    entry(262,3,1,photometric),       // PhotometricInterpretation (SHORT)
    entry(273,4,1,stripOffset),       // StripOffsets (LONG)
    entry(278,4,1,rowsPerStrip),      // RowsPerStrip (LONG)
    entry(279,4,1,stripByteCount),    // StripByteCounts (LONG)
    entry(296,3,1,2),                 // ResolutionUnit = inches
    u32(0)
  );

  return cat(header, ifd, ccittBytes);
}
async function imageBlobToPNG(blob){
  return new Promise((resolve,reject)=>{
    const img=new Image();
    img.onload=()=>{ const c=document.createElement('canvas'); c.width=img.naturalWidth||img.width; c.height=img.naturalHeight||img.height; c.getContext('2d').drawImage(img,0,0); c.toBlob(b=>resolve(b),'image/png',1.0); URL.revokeObjectURL(img.src); };
    img.onerror=()=>reject(new Error('Blob image decode failed'));
    img.src=URL.createObjectURL(blob);
  });
}

/* ============= Canvas & helpers ============= */
function paeth(a,b,c){ const p=a+b-c,pa=Math.abs(p-a),pb=Math.abs(p-b),pc=Math.abs(p-c); return (pa<=pb&&pa<=pc)?a:(pb<=pc)?b:c; }
function draw(blob,w,h){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>{ const cw=w||img.naturalWidth||img.width, ch=h||img.naturalHeight||img.height; const c=document.createElement('canvas'); c.width=cw; c.height=ch; c.getContext('2d').drawImage(img,0,0,cw,ch); res({canvas:c,img}); }; img.onerror=()=>rej(new Error('Image decode failed')); img.src=URL.createObjectURL(blob); }); }
function toPng(canvas){ return new Promise(r=>canvas.toBlob(b=>r(b),'image/png',1.0)); }
async function sizeFromBlob(blob,fw,fh){ if('createImageBitmap' in window){ try{ const bmp=await createImageBitmap(blob); const o={w:bmp.width,h:bmp.height}; bmp.close(); return o; }catch{} } return new Promise(resolve=>{ const u=URL.createObjectURL(blob); const i=new Image(); i.onload=()=>{ const r={w:i.naturalWidth||fw||0,h:i.naturalHeight||fh||0}; URL.revokeObjectURL(u); resolve(r); }; i.onerror=()=>{ URL.revokeObjectURL(u); resolve({w:fw||0,h:fh||0}); }; i.src=u; }); }

/* ============= Dedupe & junk ============= */
async function sha256Hex(u8){ const d=await crypto.subtle.digest('SHA-256',u8); return Array.from(new Uint8Array(d)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function aHashFromBlob(blob){ return new Promise(res=>{ const img=new Image(); img.onload=()=>{ const url=img.src; const c=document.createElement('canvas'); c.width=8; c.height=8; const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,8,8); const d=ctx.getImageData(0,0,8,8).data; const gs=[]; for(let i=0;i<64;i++){ const r=d[i*4],g=d[i*4+1],b=d[i*4+2]; gs[i]=(r*0.299+g*0.587+b*0.114); } const avg=gs.reduce((s,v)=>s+v,0)/64; let bits=0n; for(let i=0;i<64;i++){ bits=(bits<<1n)|(gs[i]>=avg?1n:0n); } URL.revokeObjectURL(url); res(bits); }; img.onerror=()=>res(0n); img.src=URL.createObjectURL(blob); }); }
function hamming(a,b){ let x=a^b, c=0n; while(x){ c++; x&=(x-1n); } return c; }
async function dedupeExact(){
  const map=new Map(); const out=[];
  for(const it of state.images){ if(!it._sha){ const ab=await it.pngBlob.arrayBuffer(); it._sha=await sha256Hex(new Uint8Array(ab)); } }
  for(const it of state.images){
    const prev=map.get(it._sha);
    if(!prev){ map.set(it._sha,it); out.push(it); }
    else { const a=prev.width*prev.height, b=it.width*it.height; if(b>a){ map.set(it._sha,it); const idx=out.indexOf(prev); if(idx>=0) out[idx]=it; } state.removedDuplicates++; }
  }
  state.images=Array.from(map.values()).sort((a,b)=>(b.width*b.height)-(a.width*a.height));
}
async function dedupePerceptual(){
  for(const it of state.images){ if(!it._ahash) it._ahash = await aHashFromBlob(it.pngBlob); }
  const used=new Array(state.images.length).fill(false); const keep=[];
  for(let i=0;i<state.images.length;i++){
    if(used[i]) continue; const a=state.images[i]; keep.push(a); used[i]=true;
    for(let j=i+1;j<state.images.length;j++){
      if(used[j]) continue; const b=state.images[j]; if(hamming(a._ahash,b._ahash) <= 4n){ used[j]=true; state.removedNearDuplicates++; }
    }
  }
  state.images=keep;
}
function filterJunk(){
  const before=state.images.length;
  state.images = state.images.filter(it=>{
    const area=it.width*it.height;
    if (it.width<=2 || it.height<=2) return false;
    if (area < 32*32 && it.mb < 0.01) return false;
    if (area < 80*80 && it.mb < 0.02) return false;
    return true;
  });
  state.removedJunk += (before - state.images.length);
}

/* ============= Quality scoring & labels ============= */
function scoreQuality(){
  for(const it of state.images){
    const area = it.width * it.height;
    // areaScore: 0..1
    let areaScore = 0;
    if(area >= 4_000_000) areaScore = 1.0;      // >= 4MP
    else if(area >= 1_000_000) areaScore = 0.8; // >= 1MP
    else if(area >= 300_000) areaScore = 0.6;   // >= 0.3MP
    else if(area >= 100_000) areaScore = 0.4;   // >= 0.1MP
    else areaScore = 0.2;

    const losslessBoost = it.lossless ? 0.2 : 0.0;
    let score = Math.min(1, areaScore + losslessBoost);
    const stars = score>=0.9?5:score>=0.75?4:score>=0.55?3:score>=0.35?2:1;
    it.qualityScore = score;
    it.qualityStars = '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ'.slice(0,stars) + '‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ'.slice(stars);
  }
}

/* ============= Sort + render + ZIP ============= */
function sortImages(){
  const arr=state.images;
  if(state.sortMode==='default') arr.sort((a,b)=>(b.width*b.height)-(a.width*a.height));
  else { const areas=arr.map(i=>i.width*i.height), sizes=arr.map(i=>i.mb);
    const avgA=(areas.reduce((s,v)=>s+v,0)/areas.length)||1, avgS=(sizes.reduce((s,v)=>s+v,0)/sizes.length)||1;
    for(const it of arr){ const A=it.width*it.height; it._smart=0.6*(A/avgA) + 0.4*(it.mb/avgS); }
    arr.sort((a,b)=> b._smart - a._smart);
  }
}
function renderImages(){
  if(!state.images.length){ showEmpty('No images after filtering. Toggle ‚ÄúHide junk‚Äù off to see everything.'); return; }
  const frag=document.createDocumentFragment();
  for(const it of state.images){
    const card=document.createElement('div'); card.className='card';
    const img=document.createElement('img'); img.className='thumb'; img.src=it.srcObjectUrl; img.alt=it.name; img.loading='lazy'; img.title='Click to preview'; img.addEventListener('click',()=>openModal(it)); card.appendChild(img);

    const meta=document.createElement('div'); meta.className='meta';

    const rowTop=document.createElement('div'); rowTop.className='row';
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='6px'; left.style.flexWrap='wrap';
    const strategy=document.createElement('span'); strategy.className='tag'; strategy.textContent=it.strategy||'Unknown';
    const source=document.createElement('span'); source.className='tag ' + (it.lossless?'lossless':'lossy'); source.textContent = `${it.source||'?'}` + (it.lossless?' ‚Ä¢ lossless':' ‚Ä¢ lossy');
    left.appendChild(strategy); left.appendChild(source);
    const dl=document.createElement('button'); dl.textContent='Download'; dl.style.padding='6px 10px'; dl.addEventListener('click',()=>{ const a=document.createElement('a'); a.href=it.srcObjectUrl; a.download=it.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
    rowTop.appendChild(left); rowTop.appendChild(dl); meta.appendChild(rowTop);

    const row1=document.createElement('div'); row1.className='row';
    const nmWrap=document.createElement('label'); nmWrap.style.display='flex'; nmWrap.style.alignItems='center'; nmWrap.style.gap='8px';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=!!it.selected;
    const nm=document.createElement('span'); nm.className='badge'; nm.textContent=it.name;
    nmWrap.appendChild(cb); nmWrap.appendChild(nm);
    const dims=document.createElement('div'); dims.className='small'; dims.textContent=`${it.width}√ó${it.height}px ‚Ä¢ ${it.mb.toFixed(2)} MB`;
    row1.appendChild(nmWrap); row1.appendChild(dims); meta.appendChild(row1);

    const row2=document.createElement('div'); row2.className='row';
    const q=document.createElement('div'); q.className='small'; q.textContent=`Quality: ${it.qualityStars || '‚Äî'}`;
    const sel=document.createElement('div'); sel.className='small'; sel.innerHTML=it.selected?`<span class="ok">Selected</span>`:`Not selected`;
    cb.addEventListener('change',()=>{ it.selected=cb.checked; sel.innerHTML=cb.checked?`<span class="ok">Selected</span>`:`Not selected`; });
    row2.appendChild(q); row2.appendChild(sel); meta.appendChild(row2);

    card.appendChild(meta); frag.appendChild(card);
  }
  els.gallery.innerHTML=''; els.gallery.appendChild(frag);
  enablePost();
}
const CRC32_TABLE=(()=>{ let c,t=[]; for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); t[n]=c>>>0; } return t; })();
function crc32(u8){ let c=0^(-1); for(let i=0;i<u8.length;i++) c=(c>>>8)^CRC32_TABLE[(c^u8[i])&0xFF]; return (c^(-1))>>>0; }
function u16(v){ return new Uint8Array([v&255,(v>>8)&255]); } function u32(v){ return new Uint8Array([v&255,(v>>8)&255,(v>>16)&255,(v>>24)&255]); }
function strU8(s){ const u=new Uint8Array(s.length); for(let i=0;i<s.length;i++) u[i]=s.charCodeAt(i)&255; return u; }
function dosTime(d){ return (d.getHours()<<11)|(d.getMinutes()<<5)|Math.floor(d.getSeconds()/2); }
function dosDate(d){ const y=Math.max(1980,d.getFullYear())-1980; return (y<<9)|((d.getMonth()+1)<<5)|d.getDate(); }
async function buildZip(files){
  const now=new Date(),dt=dosTime(now),dd=dosDate(now);
  const localParts=[], records=[]; let offset=0;
  for(const f of files){
    const ab=await f.pngBlob.arrayBuffer(); const u8=new Uint8Array(ab); const c=crc32(u8), name=strU8(f.name);
    const LFH=[u32(0x04034b50),u16(20),u16(0),u16(0),u16(dt),u16(dd),u32(c),u32(u8.length),u32(u8.length),u16(name.length),u16(0),name,u8];
    const size=LFH.reduce((s,p)=>s+p.length,0); localParts.push(...LFH);
    records.push({name,crc:c,size:u8.length,comp=u8.length,off:offset,dt,dd}); offset+=size;
  }
  const cdParts=[]; let cdSize=0;
  for(const r of records){
    const CDFH=[u32(0x02014b50),u16(20),u16(20),u16(0),u16(0),u16(r.dt),u16(r.dd),u32(r.crc),u32(r.comp),u32(r.size),u16(r.name.length),u16(0),u16(0),u16(0),u16(0),u32(0),u32(r.off),r.name];
    const size=CDFH.reduce((s,p)=>s+p.length,0); cdSize+=size; cdParts.push(...CDFH);
  }
  const EOCD=[u32(0x06054b50),u16(0),u16(0),u16(records.length),u16(records.length),u32(cdSize),u32(offset),u16(0)];
  const total=offset+cdSize+EOCD.reduce((s,p)=>s+p.length,0); const out=new Uint8Array(total); let pos=0;
  for(const p of localParts){ out.set(p,pos); pos+=p.length; } for(const p of cdParts){ out.set(p,pos); pos+=p.length; } for(const p of EOCD){ out.set(p,pos); pos+=p.length; }
  return new Blob([out],{type:'application/zip'});
}
els.downloadSelectedZipBtn.addEventListener('click', async ()=>{ const chosen=state.images.filter(i=>i.selected); if(!chosen.length){ alert('No images selected.'); return; } const zip=await buildZip(chosen); const a=document.createElement('a'); a.href=URL.createObjectURL(zip); a.download=`${state.pdfNameBase}_images.zip`; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
els.downloadAllZipBtn.addEventListener('click', async ()=>{ const chosen=state.images.slice(); if(!chosen.length){ alert('Nothing to download.'); return; } const zip=await buildZip(chosen); const a=document.createElement('a'); a.href=URL.createObjectURL(zip); a.download=`${state.pdfNameBase}_images.zip`; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });

/* Helpers used earlier */
function asciiHexDecodeString(s){ let t=s; const end=t.indexOf('>'); if(end!==-1) t=t.slice(0,end); t=t.replace(/\s+/g,''); if(t.length%2===1) t+='0'; const out=new Uint8Array(t.length/2); for(let i=0;i<t.length;i+=2) out[i/2]=parseInt(t.substr(i,2),16)&255; return out; }
</script>
</body>
</html>
