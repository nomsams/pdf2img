<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PDF Image Extractor ‚Äì Single-File (Offline)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0b0d10;
    --card: #12161c;
    --muted: #9fb0c0;
    --text: #e8eef5;
    --accent: #61dafb;
    --ok: #3ddc97;
    --warn: #ffcc66;
    --danger: #ff6b6b;
    --border: #273240;
  }
  :root.light {
    --bg: #f7f9fc;
    --card: #ffffff;
    --muted: #5a6a7a;
    --text: #0b0d10;
    --accent: #0077ff;
    --ok: #1a8e5f;
    --warn: #b8860b;
    --danger: #b00020;
    --border: #d8e0ea;
  }
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }
  header {
    position: sticky; top: 0; z-index: 10;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
  h1 { font-size: 20px; margin: 0 0 8px 0; letter-spacing: 0.3px; }
  .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .spacer { flex: 1; }

  /* Buttons */
  .btn, button, .toggle {
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 10px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    transition: transform .06s ease, background .2s ease, border .2s ease;
    user-select: none; text-decoration: none;
    outline: none; box-shadow: none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:hover, button:hover { transform: translateY(-1px); }
  button.primary { background: linear-gradient(180deg, var(--accent), #2aa3d6); color: #001218; border-color: transparent; }
  button.success { background: linear-gradient(180deg, var(--ok), #2dad78); color: #001b11; border-color: transparent; }
  button.warn { background: linear-gradient(180deg, var(--warn), #d7a13c); color: #2d1f00; border-color: transparent; }
  button:focus, button:focus-visible,
  .btn:focus, .btn:focus-visible,
  .btn:active, button:active { outline: none !important; box-shadow: none !important; }

  input[type="file"] { display:none; }
  .hint { color: var(--muted); font-size: 12px; margin-top: -4px; }

  .panel {
    background: var(--card); border: 1px solid var(--border);
    border-radius: 16px; padding: 14px;
  }
  .progress {
    height: 12px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; border: 1px solid var(--border);
  }
  .bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--accent), #9bffd6); transition: width .15s ease; }
  .statline { display: flex; gap: 10px; align-items:center; font-size: 13px; color: var(--muted); }

  .grid {
    display: grid; gap: 14px;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  }
  .card {
    background: var(--card); border: 1px solid var(--border); border-radius: 16px; overflow: hidden;
    display: flex; flex-direction: column;
  }
  .thumb {
    display: block; width: 100%; max-height: 200px; object-fit: contain; background: rgba(0,0,0,0.12);
  }
  .meta { padding: 10px 12px; display: grid; gap: 6px; font-size: 13px; }
  .meta .row { justify-content: space-between; }

  .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
  .tooltip { position: relative; display: inline-block; }
  .tooltip:hover::after {
    content: attr(data-tip);
    position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 8px 10px; border-radius: 10px; min-width: 180px; max-width: 260px;
    box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    white-space: normal; pointer-events: none; z-index: 20; font-size: 12px;
  }
  .empty {
    padding: 24px; text-align: center; color: var(--muted); border: 1px dashed var(--border); border-radius: 16px;
  }
  .small { font-size: 12px; color: var(--muted); }
  .ok { color: var(--ok); }

  .toggle {
    display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; font-weight: 600;
    outline: none; box-shadow: none;
  }
  .toggle input { width: 0; height: 0; appearance: none; }
  .pill {
    width: 44px; height: 24px; background: rgba(255,255,255,0.12); border-radius: 999px; position: relative; border: 1px solid var(--border);
  }
  .dot { position: absolute; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; border-radius: 50%; background: var(--text); left: 3px; transition: left .15s ease; }
  .toggle input:checked + .pill .dot { left: 23px; }

  .footer-note { margin-top: 30px; font-size: 12px; color: var(--muted); }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor</h1>
        <div class="hint">Single-file, offline. Extracts embedded images as high-quality PNG with sort, preview, and selective ZIP download.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark mode">
        <span>Light</span>
        <input id="themeToggle" type="checkbox" />
        <span class="pill"><span class="dot"></span></span>
        <span>Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex; flex-direction: column; gap: 16px;">

  <section class="panel">
    <div class="row" style="gap: 8px; align-items:center;">
      <label for="fileInput" class="btn tooltip" data-tip="Choose a PDF from your computer (processed 100% locally).">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf"/>

      <button id="startBtn" class="primary tooltip" disabled data-tip="Starts extraction. Processing progress shown below.">‚ñ∂Ô∏è Start Processing</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <div class="tooltip" data-tip="Default sorts by pixel area (width√óheight), largest first. Smart Sort also considers file size and pushes icons/tiny images last.">
        <button id="defaultSortBtn" disabled>Sort: Size (default)</button>
      </div>
      <div class="tooltip" data-tip="Smart Sort pushes probable icons and tiny images last by blending area and MB size against the average.">
        <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>
      </div>

      <button id="downloadSelectedZipBtn" class="success" disabled>Download Selected (ZIP)</button>
      <button id="downloadAllZipBtn" disabled>Download All (ZIP)</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top: 12px; display:grid; gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start Processing</b> to begin.<br/><span class="small">If the PDF has no images, you‚Äôll see a notice.</span></div>
  </section>

  <section class="footer-note">
    <div><b>Notes & Limitations:</b> Extracts embedded images. JPEG is fully supported. PNG/raw (FlateDecode) support depends on PDF encoding; PNG-style predictors (10‚Äì15) handled for 8bpc DeviceRGB/DeviceGray. Thumbnails are previews‚Äîdownloads are full-quality PNG.</div>
  </section>

</main>

<script>
/* =============================
   Utility: Theme (Light/Dark)
============================= */
(function initTheme(){
  const root = document.documentElement;
  const toggle = document.getElementById('themeToggle');
  const saved = localStorage.getItem('pdfimg_theme') || 'dark';
  if(saved === 'light'){ root.classList.add('light'); toggle.checked = false; }
  else { root.classList.remove('light'); toggle.checked = true; }
  toggle.addEventListener('change', () => {
    if(toggle.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); }
    else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }
  });
})();
</script>

<script>
/* ===========================================================
   PDF Image Extractor (Single-file, Client-side, Offline)
   No pdf.js usage. Directly parses /Subtype /Image objects.
=========================================================== */

const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
};

let state = {
  pdfFile: null,
  pdfNameBase: 'images',
  rawBytes: null,
  images: [],     // { id, pngBlob, width, height, mb, name, hashHex, selected, srcObjectUrl }
  removedDuplicates: 0,
  sortMode: 'default', // 'default' or 'smart'
};

function sanitizeBaseName(name) {
  const base = name.replace(/\.[Pp][Dd][Ff]$/, '');
  let s = base.replace(/[^a-zA-Z0-9_\-]+/g, '_');
  if (s.length > 12) s = s.slice(0, 12);
  if (!s) s = 'images';
  return s.toLowerCase();
}

// File selection
els.fileInput.addEventListener('change', () => {
  const f = els.fileInput.files && els.fileInput.files[0];
  if (!f) return;
  state.pdfFile = f;
  els.pdfName.textContent = f.name;
  state.pdfNameBase = sanitizeBaseName(f.name);
  els.startBtn.disabled = false;
});

// Buttons
els.startBtn.addEventListener('click', async () => {
  if (!state.pdfFile) return;
  resetUIForProcessing();
  try {
    state.rawBytes = await state.pdfFile.arrayBuffer();
    updateProgress(0, 'Scanning PDF‚Ä¶');
    const items = await extractImagesFromPDF(new Uint8Array(state.rawBytes));
    if (items.length === 0) {
      showEmpty('No images found in this PDF.');
      finalizeStats();
      return;
    }
    await convertAllToPNGAndDedup(items);
    renderImages();
    enablePostProcessButtons();
    finalizeStats();
  } catch (err) {
    console.error(err);
    showEmpty('Failed to process PDF (corrupt or unsupported).');
    updateProgress(0, 'Error.');
  }
});

els.selectAllBtn.addEventListener('click', () => {
  for (const it of state.images) it.selected = true;
  renderImages();
});
els.deselectAllBtn.addEventListener('click', () => {
  for (const it of state.images) it.selected = false;
  renderImages();
});

els.defaultSortBtn.addEventListener('click', () => {
  state.sortMode = 'default';
  sortImages();
  renderImages();
});
els.smartSortBtn.addEventListener('click', () => {
  state.sortMode = 'smart';
  sortImages();
  renderImages();
});

els.downloadSelectedZipBtn.addEventListener('click', async () => {
  const chosen = state.images.filter(i => i.selected);
  if (chosen.length === 0) { alert('No images selected.'); return; }
  const zipBlob = await buildZipFromImages(chosen);
  const a = document.createElement('a');
  a.href = URL.createObjectURL(zipBlob);
  a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 4000);
  a.remove();
});

els.downloadAllZipBtn.addEventListener('click', async () => {
  const chosen = state.images.slice();
  if (chosen.length === 0) { alert('Nothing to download.'); return; }
  const zipBlob = await buildZipFromImages(chosen);
  const a = document.createElement('a');
  a.href = URL.createObjectURL(zipBlob);
  a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 4000);
  a.remove();
});

// UI helpers
function resetUIForProcessing(){
  state.images = [];
  state.removedDuplicates = 0;
  state.sortMode = 'default';
  els.gallery.innerHTML = '';
  updateProgress(0, 'Preparing‚Ä¶');
  els.defaultSortBtn.disabled = true;
  els.smartSortBtn.disabled = true;
  els.selectAllBtn.disabled = true;
  els.deselectAllBtn.disabled = true;
  els.downloadSelectedZipBtn.disabled = true;
  els.downloadAllZipBtn.disabled = true;
  els.stats.textContent = '';
}
function enablePostProcessButtons(){
  els.defaultSortBtn.disabled = false;
  els.smartSortBtn.disabled = false;
  els.selectAllBtn.disabled = false;
  els.deselectAllBtn.disabled = false;
  els.downloadSelectedZipBtn.disabled = false;
  els.downloadAllZipBtn.disabled = false;
}
function showEmpty(msg){
  els.gallery.innerHTML = `<div class="empty">${msg}</div>`;
}
function updateProgress(pct, text){
  els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`;
  els.progressText.textContent = text;
}
function finalizeStats(){
  const n = state.images.length;
  const dup = state.removedDuplicates;
  els.stats.innerHTML = `Images: <b>${n}</b> &nbsp; | &nbsp; Removed duplicates: <b>${dup}</b>`;
}

// Rendering
function renderImages(){
  sortImages();
  if (state.images.length === 0) { showEmpty('No images found after processing.'); return; }
  const frag = document.createDocumentFragment();
  for (const it of state.images) frag.appendChild(renderCard(it));
  els.gallery.innerHTML = '';
  els.gallery.appendChild(frag);
}
function renderCard(it){
  const card = document.createElement('div');
  card.className = 'card';

  const img = document.createElement('img');
  img.className = 'thumb';
  img.src = it.srcObjectUrl;
  img.alt = it.name;
  img.loading = 'lazy';
  img.title = 'Click to open full-size in new tab';
  img.addEventListener('click', () => {
    const a = document.createElement('a');
    a.href = it.srcObjectUrl;
    a.target = '_blank';
    a.download = it.name;
    a.click();
  });
  card.appendChild(img);

  const meta = document.createElement('div');
  meta.className = 'meta';

  const row1 = document.createElement('div'); row1.className = 'row';
  const label = document.createElement('label');
  label.style.display = 'flex'; label.style.alignItems = 'center'; label.style.gap = '8px';
  const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = !!it.selected;
  cb.addEventListener('change', () => { it.selected = cb.checked; sel.innerHTML = cb.checked ? `<span class="ok">Selected</span>` : `Not selected`; });
  const bname = document.createElement('span'); bname.className = 'badge'; bname.textContent = it.name;
  label.appendChild(cb); label.appendChild(bname);

  const dlBtn = document.createElement('button');
  dlBtn.textContent = 'Download';
  dlBtn.style.padding = '6px 10px';
  dlBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.href = it.srcObjectUrl;
    a.download = it.name;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 4000);
    a.remove();
  });

  row1.appendChild(label);
  row1.appendChild(dlBtn);
  meta.appendChild(row1);

  const row2 = document.createElement('div'); row2.className = 'row';
  const dims = document.createElement('div'); dims.className = 'small'; dims.textContent = `Dimensions: ${it.width}√ó${it.height}px`;
  const size = document.createElement('div'); size.className = 'small'; size.textContent = `Size: ${it.mb.toFixed(2)} MB`;
  row2.appendChild(dims); row2.appendChild(size);
  meta.appendChild(row2);

  const sel = document.createElement('div');
  sel.className = 'small';
  sel.innerHTML = it.selected ? `<span class="ok">Selected</span>` : `Not selected`;
  meta.appendChild(sel);

  card.appendChild(meta);
  return card;
}

function sortImages(){
  const arr = state.images;
  if (!arr.length) return;
  if (state.sortMode === 'default') {
    arr.sort((a,b) => (b.width*b.height) - (a.width*a.height));
  } else {
    const areas = arr.map(i => i.width*i.height);
    const sizes = arr.map(i => i.mb);
    const avgA = (areas.reduce((s,v)=>s+v,0) / areas.length) || 1;
    const avgS = (sizes.reduce((s,v)=>s+v,0) / sizes.length) || 1;
    for (const it of arr) {
      const area = it.width*it.height;
      const wArea = area / avgA;
      const wSize = it.mb / avgS;
      it._smartScore = 0.6*wArea + 0.4*wSize;
    }
    arr.sort((a,b) => (b._smartScore - a._smartScore));
  }
}

/* ============================
   PDF Parsing & Extraction
============================ */

async function extractImagesFromPDF(u8){
  const text = new TextDecoder('latin1').decode(u8);
  const reObj = /(\d+)\s+(\d+)\s+obj([\s\S]*?)endobj/g;
  let m;
  const items = [];
  while ((m = reObj.exec(text)) !== null) {
    const objContent = m[3];
    if (!/\/Subtype\s*\/Image/.test(objContent)) continue;

    const dictMatch = /<<(.*?)>>/s.exec(objContent);
    if (!dictMatch) continue;
    const dictStr = dictMatch[1];

    const width = pickInt(dictStr, /\/Width\s+(\d+)/);
    const height = pickInt(dictStr, /\/Height\s+(\d+)/);
    const bits = pickInt(dictStr, /\/BitsPerComponent\s+(\d+)/) || 8;

    // ColorSpace can be /DeviceRGB, /DeviceGray, or array; we only handle simple names here
    let cs = pickName(dictStr, /\/ColorSpace\s+\/([A-Za-z0-9]+)/) || 'DeviceRGB';

    // Filter(s)
    let filter = pickName(dictStr, /\/Filter\s+\/([A-Za-z0-9]+)/) || null;
    const filterArr = pickArrayNames(dictStr, /\/Filter\s+\[([^\]]+)\]/);
    if (!filter && filterArr.length) filter = filterArr[0];

    // DecodeParms: Predictor, Colors, Columns
    const predictor = pickInt(dictStr, /\/DecodeParms[\s\S]*?\/Predictor\s+(\d+)/) || 1;
    const colors = pickInt(dictStr, /\/DecodeParms[\s\S]*?\/Colors\s+(\d+)/) || (cs==='DeviceRGB' ? 3 : 1);
    const columns = pickInt(dictStr, /\/DecodeParms[\s\S]*?\/Columns\s+(\d+)/) || width;

    // Locate stream..endstream
    const streamStart = objContent.indexOf('stream', dictMatch[0].length);
    const streamEnd = objContent.indexOf('endstream', streamStart);
    if (streamStart === -1 || streamEnd === -1) continue;

    let dataStartInObj = streamStart + 'stream'.length;
    if (objContent[dataStartInObj] === '\r' && objContent[dataStartInObj+1] === '\n') dataStartInObj += 2;
    else if (objContent[dataStartInObj] === '\n') dataStartInObj += 1;

    const objStartInFile = m.index;
    const start = objStartInFile + dataStartInObj;
    const end = objStartInFile + streamEnd;

    const bytes = u8.subarray(start, end);

    items.push({ index: items.length + 1, width, height, bits, cs, filter, predictor, colors, columns, bytes });
  }
  return items;
}

function pickInt(s, re){ const m = re.exec(s); return m ? parseInt(m[1],10) : null; }
function pickName(s, re){ const m = re.exec(s); return m ? m[1] : null; }
function pickArrayNames(s, re){
  const m = re.exec(s); if(!m) return [];
  const inner = m[1];
  return (inner.match(/\/([A-Za-z0-9]+)/g) || []).map(t => t.slice(1));
}

/* =======================================
   Convert to PNG & Deduplicate by SHA256
======================================= */
async function convertAllToPNGAndDedup(items){
  const total = items.length;
  const seen = new Set();
  const results = [];
  const base = state.pdfNameBase;

  for (let i=0;i<total;i++){
    updateProgress(Math.round((i/total)*100), `Processing image ${i+1}/${total}‚Ä¶`);
    const it = items[i];
    try {
      const pngBlob = await convertOneToPNG(it);
      if (!pngBlob) continue;

      const ab = await pngBlob.arrayBuffer();
      const hash = await sha256Hex(new Uint8Array(ab));
      if (seen.has(hash)) { state.removedDuplicates++; continue; }
      seen.add(hash);

      const { w:realW, h:realH } = await getImageSizeFromBlob(pngBlob, it.width, it.height);
      const url = URL.createObjectURL(pngBlob);

      const name = `${base}_img${results.length+1}.png`;
      results.push({
        id: 'img'+(results.length+1),
        pngBlob, hashHex: hash,
        width: realW, height: realH,
        mb: ab.byteLength/(1024*1024),
        name,
        selected: false,
        srcObjectUrl: url
      });
    } catch (e) {
      console.warn('Skipping an image due to error', e);
    }
  }
  updateProgress(100, `Done (${results.length} images).`);
  state.images = results;
}

/* Convert a single PDF image object to PNG Blob */
async function convertOneToPNG(item){
  const { bytes, filter, width, height, bits, cs, predictor, colors, columns } = item;

  // JPEG (DCTDecode)
  if (/^DCTDecode$/i.test(filter)) {
    const jpegBlob = new Blob([bytes], { type: 'image/jpeg' });
    const { canvas, ctx, img } = await drawToCanvas(jpegBlob, width, height);
    const png = await canvasToPNG(canvas);
    cleanupCanvas(canvas, ctx, img);
    return png;
  }

  // JPEG2000 (best-effort; may fail if browser lacks decoder)
  if (/^JPXDecode$/i.test(filter)) {
    const jpxBlob = new Blob([bytes], { type: 'image/jp2' });
    try {
      const { canvas, ctx, img } = await drawToCanvas(jpxBlob, width, height);
      const png = await canvasToPNG(canvas);
      cleanupCanvas(canvas, ctx, img);
      return png;
    } catch {
      console.warn('JPEG2000 not supported by this browser.');
      return null;
    }
  }

  // FlateDecode raw raster (basic DeviceRGB/DeviceGray, 8bpc)
  if (/^FlateDecode$/i.test(filter)) {
    if (!(bits===8 && (cs==='DeviceRGB' || cs==='DeviceGray'))) {
      console.warn('Skipping FlateDecode image (unsupported color space/bpc).');
      return null;
    }
    let inflated;
    try {
      inflated = await inflateZlib(bytes);
    } catch (e) {
      console.warn('Flate inflate failed: ', e);
      return null;
    }

    const comps = (cs==='DeviceRGB') ? 3 : 1;
    if (predictor === 1) {
      // No PNG filters
      const expected = width * height * comps;
      if (inflated.length !== expected) { console.warn('Raw length mismatch; skipping.'); return null; }
      return rawToPNG(inflated, width, height, comps);
    }

    if (predictor >= 10 && predictor <= 15) {
      // PNG filter method; rows start with a filter byte
      const rowBytes = columns * comps; // 8bpc
      const stride = 1 + rowBytes;
      if (inflated.length !== stride * height) {
        // Some PDFs set Columns != width; try fallback if Columns seems wrong
        if (columns !== width) {
          const altRowBytes = width * comps;
          const altStride = 1 + altRowBytes;
          if (inflated.length === altStride * height) {
            const unfiltered = undoPNGPrediction(inflated, altRowBytes, height, comps);
            return rawToPNG(unfiltered, width, height, comps);
          }
        }
        console.warn('Predictor data size mismatch; skipping.');
        return null;
      }
      const unfiltered = undoPNGPrediction(inflated, rowBytes, height, comps);
      return rawToPNG(unfiltered, columns, height, comps); // if Columns==width this matches; else it‚Äôs what PDF stated
    }

    console.warn('Unsupported Predictor:', predictor);
    return null;
  }

  console.warn('Unsupported filter: ', filter);
  return null;
}

/* Turn raw RGB/Gray bytes into PNG via canvas */
async function rawToPNG(raw, width, height, comps){
  const canvas = document.createElement('canvas');
  canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imgData = ctx.createImageData(width, height);
  const dst = imgData.data;
  if (comps === 3) {
    let si=0, di=0, n = width*height;
    for (let i=0;i<n;i++){
      dst[di++] = raw[si++]; // R
      dst[di++] = raw[si++]; // G
      dst[di++] = raw[si++]; // B
      dst[di++] = 255;       // A
    }
  } else {
    let si=0, di=0, n = width*height;
    for (let i=0;i<n;i++){
      const v = raw[si++];
      dst[di++] = v; dst[di++] = v; dst[di++] = v; dst[di++] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  return canvasToPNG(canvas);
}

/* PNG predictor undo (filters 0..4 per row) */
function undoPNGPrediction(inflated, rowBytes, rows, comps){
  const out = new Uint8Array(rowBytes * rows);
  const bpp = comps; // 8bpc => bytes per pixel = comps
  let src = 0, dst = 0;
  const priorRow = new Uint8Array(rowBytes);

  for (let y=0; y<rows; y++){
    const filterType = inflated[src++]; // 0 None,1 Sub,2 Up,3 Average,4 Paeth
    switch (filterType) {
      case 0: // None
        out.set(inflated.subarray(src, src+rowBytes), dst);
        break;
      case 1: // Sub
        for (let x=0; x<rowBytes; x++){
          const left = (x>=bpp) ? out[dst + x - bpp] : 0;
          out[dst + x] = (inflated[src + x] + left) & 0xFF;
        }
        break;
      case 2: // Up
        for (let x=0; x<rowBytes; x++){
          const up = priorRow[x] || 0;
          out[dst + x] = (inflated[src + x] + up) & 0xFF;
        }
        break;
      case 3: // Average
        for (let x=0; x<rowBytes; x++){
          const left = (x>=bpp) ? out[dst + x - bpp] : 0;
          const up = priorRow[x] || 0;
          out[dst + x] = (inflated[src + x] + ((left + up) >> 1)) & 0xFF;
        }
        break;
      case 4: // Paeth
        for (let x=0; x<rowBytes; x++){
          const left = (x>=bpp) ? out[dst + x - bpp] : 0;
          const up = priorRow[x] || 0;
          const upLeft = (x>=bpp) ? priorRow[x - bpp] : 0;
          out[dst + x] = (inflated[src + x] + paeth(left, up, upLeft)) & 0xFF;
        }
        break;
      default:
        // Unknown filter; pass-through as best-effort
        out.set(inflated.subarray(src, src+rowBytes), dst);
    }
    // update priorRow
    priorRow.set(out.subarray(dst, dst+rowBytes));
    src += rowBytes; dst += rowBytes;
  }
  return out;
}
function paeth(a,b,c){
  const p = a + b - c;
  const pa = Math.abs(p - a);
  const pb = Math.abs(p - b);
  const pc = Math.abs(p - c);
  if (pa <= pb && pa <= pc) return a;
  if (pb <= pc) return b;
  return c;
}

/* Draw blob to canvas to create PNG (for JPEG/JPX inputs) */
function drawToCanvas(blob, hintW, hintH){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const w = hintW || img.naturalWidth || img.width;
      const h = hintH || img.naturalHeight || img.height;
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha: true });
      ctx.drawImage(img, 0, 0, w, h);
      resolve({ canvas, ctx, img });
    };
    img.onerror = () => reject(new Error('Image decode failed'));
    img.src = URL.createObjectURL(blob);
  });
}
function canvasToPNG(canvas){
  return new Promise((resolve) => { canvas.toBlob(b => resolve(b), 'image/png', 1.0); });
}
function cleanupCanvas(canvas, ctx, img){
  try { URL.revokeObjectURL(img.src); } catch {}
}

/* Get size of PNG blob without revoking the URL we need later */
async function getImageSizeFromBlob(blob, fallbackW, fallbackH){
  // Fast path: createImageBitmap
  if ('createImageBitmap' in window) {
    try {
      const bmp = await createImageBitmap(blob);
      const w = bmp.width, h = bmp.height;
      bmp.close();
      return { w, h };
    } catch {}
  }
  // Fallback: HTMLImageElement
  return new Promise((resolve) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => { const w = img.naturalWidth||fallbackW||0, h = img.naturalHeight||fallbackH||0; URL.revokeObjectURL(url); resolve({ w, h }); };
    img.onerror = () => { URL.revokeObjectURL(url); resolve({ w: fallbackW||0, h: fallbackH||0 }); };
    img.src = url;
  });
}

/* Inflate zlib using DecompressionStream (Chrome/Edge/Firefox). */
async function inflateZlib(u8){
  if ('DecompressionStream' in window) {
    const ds = new DecompressionStream('deflate');
    const inStream = new Response(new Blob([u8])).body;
    const outStream = inStream.pipeThrough(ds);
    const out = await new Response(outStream).arrayBuffer();
    return new Uint8Array(out);
  } else {
    throw new Error('DecompressionStream not supported in this browser.');
  }
}

/* SHA-256 (WebCrypto) */
async function sha256Hex(u8){
  const buf = await crypto.subtle.digest('SHA-256', u8);
  const arr = Array.from(new Uint8Array(buf));
  return arr.map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* ===================
   ZIP (store method)
=================== */

// CRC32
const CRC32_TABLE = (() => {
  let c, table = [];
  for (let n =0; n < 256; n++) {
    c = n;
    for (let k=0; k<8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    table[n] = c >>> 0;
  }
  return table;
})();
function crc32(u8){
  let c = 0 ^ (-1);
  for (let i=0;i<u8.length;i++){
    c = (c >>> 8) ^ CRC32_TABLE[(c ^ u8[i]) & 0xFF];
  }
  return (c ^ (-1)) >>> 0;
}
function strToU8(s){ const u = new Uint8Array(s.length); for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i) & 0xFF; return u; }
function writeUint16LE(v){ return new Uint8Array([v & 0xFF, (v>>8) & 0xFF]); }
function writeUint32LE(v){ return new Uint8Array([v & 0xFF, (v>>8)&0xFF, (v>>16)&0xFF, (v>>24)&0xFF]); }

async function buildZipFromImages(files){
  // files: [{name, pngBlob}]
  const fileRecords = [];
  let localOffset = 0;
  const localParts = [];

  const now = new Date();
  const dosTime = toDosTime(now);
  const dosDate = toDosDate(now);

  for (const f of files) {
    const ab = await f.pngBlob.arrayBuffer();
    const u8 = new Uint8Array(ab);
    const c = crc32(u8);
    const nameU8 = strToU8(f.name);

    const LFH = [
      writeUint32LE(0x04034b50),       // signature
      writeUint16LE(20),               // version needed
      writeUint16LE(0),                // general purpose bit
      writeUint16LE(0),                // compression (0 = store)
      writeUint16LE(dosTime),          // mod time
      writeUint16LE(dosDate),          // mod date
      writeUint32LE(c),                // CRC32
      writeUint32LE(u8.length),        // compressed size
      writeUint32LE(u8.length),        // uncompressed size
      writeUint16LE(nameU8.length),    // filename length
      writeUint16LE(0),                // extra length
      nameU8,
      u8
    ];
    const lfhSize = LFH.reduce((s,part)=> s + part.length, 0);
    localParts.push(...LFH);

    fileRecords.push({
      nameU8,
      crc: c,
      size: u8.length,
      compSize: u8.length,
      offset: localOffset,
      time: dosTime,
      date: dosDate
    });
    localOffset += lfhSize;
  }

  const cdParts = [];
  let cdSize = 0;
  for (const rec of fileRecords) {
    const CDFH = [
      writeUint32LE(0x02014b50),
      writeUint16LE(20),               // version made by
      writeUint16LE(20),               // version needed
      writeUint16LE(0),                // general bit
      writeUint16LE(0),                // compression
      writeUint16LE(rec.time),
      writeUint16LE(rec.date),
      writeUint32LE(rec.crc),
      writeUint32LE(rec.compSize),
      writeUint32LE(rec.size),
      writeUint16LE(rec.nameU8.length),
      writeUint16LE(0),                // extra
      writeUint16LE(0),                // comment
      writeUint16LE(0),                // disk number start
      writeUint16LE(0),                // internal attrs
      writeUint32LE(0),                // external attrs
      writeUint32LE(rec.offset),
      rec.nameU8
    ];
    const size = CDFH.reduce((s, part)=> s + part.length, 0);
    cdSize += size;
    cdParts.push(...CDFH);
  }

  const cdOffset = localOffset;
  const EOCD = [
    writeUint32LE(0x06054b50),
    writeUint16LE(0), writeUint16LE(0),                 // disk numbers
    writeUint16LE(fileRecords.length),                  // entries on this disk
    writeUint16LE(fileRecords.length),                  // total entries
    writeUint32LE(cdSize),
    writeUint32LE(cdOffset),
    writeUint16LE(0)                                    // comment length
  ];

  const totalSize = localOffset + cdSize + EOCD.reduce((s,part)=> s+part.length, 0);
  const out = new Uint8Array(totalSize);
  let pos = 0;
  for (const p of localParts) { out.set(p, pos); pos += p.length; }
  for (const p of cdParts)    { out.set(p, pos); pos += p.length; }
  for (const p of EOCD)       { out.set(p, pos); pos += p.length; }

  return new Blob([out], { type: 'application/zip' });
}

function toDosTime(d){
  let h = d.getHours();
  let m = d.getMinutes();
  let s = Math.floor(d.getSeconds()/2);
  return (h<<11) | (m<<5) | s;
}
function toDosDate(d){
  let year = d.getFullYear();
  if (year < 1980) year = 1980;
  let y = year - 1980;
  let mon = d.getMonth()+1;
  let day = d.getDate();
  return (y<<9) | (mon<<5) | day;
}
</script>
</body>
</html>
