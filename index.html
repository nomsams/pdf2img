<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üöÄ PDF Image Extractor ‚Äì Single-File (Offline)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0b0d10;
    --card: #12161c;
    --muted: #9fb0c0;
    --text: #e8eef5;
    --accent: #61dafb;
    --ok: #3ddc97;
    --warn: #ffcc66;
    --danger: #ff6b6b;
    --border: #273240;
    --shadow: 0 10px 30px rgba(0,0,0,.5);
  }
  :root.light {
    --bg: #f7f9fc;
    --card: #ffffff;
    --muted: #5a6a7a;
    --text: #0b0d10;
    --accent: #0077ff;
    --ok: #1a8e5f;
    --warn: #b8860b;
    --danger: #b00020;
    --border: #d8e0ea;
    --shadow: 0 10px 30px rgba(0,0,0,.15);
  }
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
  }
  header {
    position: sticky; top: 0; z-index: 10; background: var(--bg);
    border-bottom: 1px solid var(--border);
  }
  .wrap { max-width: 1150px; margin: 0 auto; padding: 16px; }
  h1 { font-size: 20px; margin: 0 0 8px 0; letter-spacing: .3px; }
  .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  .spacer { flex: 1; }

  .btn, button, .toggle {
    background: var(--card); color: var(--text); border: 1px solid var(--border);
    padding: 10px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    transition: transform .06s ease, background .2s ease, border .2s ease, box-shadow .2s ease;
    user-select: none; text-decoration: none; outline: none; box-shadow: none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:hover, button:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
  button.primary { background: linear-gradient(180deg, var(--accent), #2aa3d6); color: #001218; border-color: transparent; }
  button.success { background: linear-gradient(180deg, var(--ok), #2dad78); color: #001b11; border-color: transparent; }
  button.warn { background: linear-gradient(180deg, var(--warn), #d7a13c); color: #2d1f00; border-color: transparent; }
  input[type="file"] { display:none; }
  .hint { color: var(--muted); font-size: 12px; margin-top: -4px; }

  .panel {
    background: var(--card); border: 1px solid var(--border);
    border-radius: 16px; padding: 14px;
  }
  .progress {
    height: 12px; background: rgba(255,255,255,0.08);
    border-radius: 999px; overflow: hidden; border: 1px solid var(--border);
  }
  .bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--accent), #9bffd6); transition: width .15s ease; }
  .statline { display: flex; gap: 10px; align-items:center; font-size: 13px; color: var(--muted); }

  .grid { display: grid; gap: 14px; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 16px; overflow: hidden; display: flex; flex-direction: column; }
  .thumb { display: block; width: 100%; max-height: 220px; object-fit: contain; background: rgba(0,0,0,0.12); cursor: zoom-in; }
  .meta { padding: 10px 12px; display: grid; gap: 6px; font-size: 13px; }
  .meta .row { justify-content: space-between; }
  .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
  .small { font-size: 12px; color: var(--muted); }
  .ok { color: var(--ok); }
  .empty { padding: 24px; text-align: center; color: var(--muted); border: 1px dashed var(--border); border-radius: 16px; }

  .toggle { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; font-weight: 600; }
  .toggle input { width: 0; height: 0; appearance: none; }
  .pill { width: 44px; height: 24px; background: rgba(255,255,255,0.12); border-radius: 999px; position: relative; border: 1px solid var(--border); }
  .dot { position: absolute; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; border-radius: 50%; background: var(--text); left: 3px; transition: left .15s ease; }
  .toggle input:checked + .pill .dot { left: 23px; }

  .footer-note { margin-top: 30px; font-size: 12px; color: var(--muted); }

  /* Fullscreen preview modal */
  .modal {
    position: fixed; inset: 0; background: rgba(0,0,0,.75);
    display: none; align-items: center; justify-content: center;
    z-index: 1000;
  }
  .modal.open { display: flex; }
  .modal-inner {
    max-width: min(96vw, 1600px);
    max-height: 92vh; padding: 0; border-radius: 14px;
    background: var(--card); border: 1px solid var(--border);
    box-shadow: var(--shadow); position: relative; display: grid; grid-template-rows: auto 1fr;
    overflow: hidden;
  }
  .modal-header {
    display: flex; align-items: center; gap: 8px; padding: 10px 12px; border-bottom: 1px solid var(--border);
  }
  .modal-header .spacer { flex: 1; }
  .modal-img-wrap {
    display: grid; place-items: center; background: #000; /* better contrast */
    width: 100%; height: 100%;
  }
  .modal-img {
    max-width: 100%; max-height: 100%;
    object-fit: contain; image-rendering: auto;
    background: #111;
  }
  .icon-btn {
    padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border);
    background: var(--card); cursor: pointer; font-weight: 700;
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>üìÑ PDF Image Extractor</h1>
        <div class="hint">Single-file, offline. Finds embedded & inline images, resolves object streams, supports RGB/Gray/CMYK/Indexed, exports PNG in full quality.</div>
      </div>
      <div class="spacer"></div>
      <label class="toggle" title="Light/Dark mode">
        <span>Light</span>
        <input id="themeToggle" type="checkbox" />
        <span class="pill"><span class="dot"></span></span>
        <span>Dark</span>
      </label>
    </div>
  </div>
</header>

<main class="wrap" style="display:flex; flex-direction: column; gap: 16px;">

  <section class="panel">
    <div class="row" style="gap: 8px; align-items:center;">
      <label for="fileInput" class="btn" title="Choose a PDF from your computer (processed 100% locally).">üì• Upload PDF</label>
      <input id="fileInput" type="file" accept="application/pdf,.pdf"/>

      <button id="startBtn" class="primary" disabled title="Starts extraction. Processing progress shown below.">‚ñ∂Ô∏è Start Processing</button>

      <button id="selectAllBtn" disabled>Select All</button>
      <button id="deselectAllBtn" disabled>Deselect All</button>

      <button id="defaultSortBtn" disabled>Sort: Size (default)</button>
      <button id="smartSortBtn" class="warn" disabled>Smart Sort</button>

      <button id="downloadSelectedZipBtn" class="success" disabled>Download Selected (ZIP)</button>
      <button id="downloadAllZipBtn" disabled>Download All (ZIP)</button>

      <div class="spacer"></div>
      <div class="small" id="pdfName">No file chosen</div>
    </div>

    <div style="margin-top: 12px; display:grid; gap:8px;">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div class="statline">
        <div id="progressText">Waiting‚Ä¶</div>
        <div class="spacer"></div>
        <div id="stats" class="small"></div>
      </div>
    </div>
  </section>

  <section id="gallery" class="grid">
    <div class="empty">No images yet. Upload a PDF and click <b>Start Processing</b> to begin.<br/><span class="small">If the PDF has no images, you‚Äôll see a notice.</span></div>
  </section>

  <section class="footer-note">
    <div><b>Notes:</b> Supports embedded & inline images; filter chains; PNG predictors; ColorSpaces (RGB, Gray, CMYK, Indexed, ICCBased fallback). CCITTFax bitonal is not decoded (rare for photos).</div>
  </section>

</main>

<!-- Fullscreen Preview Modal -->
<div id="modal" class="modal" aria-hidden="true">
  <div class="modal-inner" role="dialog" aria-modal="true" aria-label="Image preview">
    <div class="modal-header">
      <div id="modalTitle" class="small"></div>
      <div class="spacer"></div>
      <button id="modalDownload" class="icon-btn">‚¨áÔ∏è Download PNG</button>
      <button id="modalClose" class="icon-btn">‚úñ</button>
    </div>
    <div class="modal-img-wrap">
      <img id="modalImg" class="modal-img" alt="Preview"/>
    </div>
  </div>
</div>

<script>
/* =============================
   Utility: Theme (Light/Dark)
============================= */
(function initTheme(){
  const root = document.documentElement;
  const toggle = document.getElementById('themeToggle');
  const saved = localStorage.getItem('pdfimg_theme') || 'dark';
  if(saved === 'light'){ root.classList.add('light'); toggle.checked = false; }
  else { root.classList.remove('light'); toggle.checked = true; }
  toggle.addEventListener('change', () => {
    if(toggle.checked){ localStorage.setItem('pdfimg_theme','dark'); root.classList.remove('light'); }
    else { localStorage.setItem('pdfimg_theme','light'); root.classList.add('light'); }
  });
})();
</script>

<script>
/* ===========================================================
   PDF Image Extractor ‚Äì super-robust, offline
   - Balanced dict parsing
   - Stream slicing via /Length (+ indirect)
   - Filter chain: ASCII85, ASCIIHex, Flate, RunLength, LZW, DCT, JPX
   - PNG predictors 10‚Äì15
   - ColorSpace: DeviceRGB, DeviceGray, DeviceCMYK, Indexed (+table), ICCBased fallback
   - Inline images (BI/ID/EI)
   - Object streams (/ObjStm) parsing to resolve referenced ColorSpaces/etc.
=========================================================== */

const els = {
  fileInput: document.getElementById('fileInput'),
  startBtn: document.getElementById('startBtn'),
  selectAllBtn: document.getElementById('selectAllBtn'),
  deselectAllBtn: document.getElementById('deselectAllBtn'),
  defaultSortBtn: document.getElementById('defaultSortBtn'),
  smartSortBtn: document.getElementById('smartSortBtn'),
  downloadSelectedZipBtn: document.getElementById('downloadSelectedZipBtn'),
  downloadAllZipBtn: document.getElementById('downloadAllZipBtn'),
  gallery: document.getElementById('gallery'),
  bar: document.getElementById('bar'),
  progressText: document.getElementById('progressText'),
  stats: document.getElementById('stats'),
  pdfName: document.getElementById('pdfName'),
  modal: document.getElementById('modal'),
  modalImg: document.getElementById('modalImg'),
  modalClose: document.getElementById('modalClose'),
  modalDownload: document.getElementById('modalDownload'),
  modalTitle: document.getElementById('modalTitle'),
};

let state = {
  pdfFile: null,
  pdfNameBase: 'images',
  raw: null,      // Uint8Array
  text: null,     // latin1 text
  objects: [],    // all top-level objects with ranges
  objMap: new Map(),   // key "obj gen" -> { kind: 'normal'|'objstm', content, dictStr, streamStart, streamEnd, ... }
  images: [],
  removedDuplicates: 0,
  sortMode: 'default',
};

function sanitizeBaseName(name) {
  const base = name.replace(/\.[Pp][Dd][Ff]$/, '');
  let s = base.replace(/[^a-zA-Z0-9_\-]+/g, '_');
  if (s.length > 12) s = s.slice(0, 12);
  if (!s) s = 'images';
  return s.toLowerCase();
}

els.fileInput.addEventListener('change', () => {
  const f = els.fileInput.files && els.fileInput.files[0];
  if (!f) return;
  state.pdfFile = f;
  els.pdfName.textContent = f.name;
  state.pdfNameBase = sanitizeBaseName(f.name);
  els.startBtn.disabled = false;
});

els.startBtn.addEventListener('click', async () => {
  if (!state.pdfFile) return;
  resetUIForProcessing();
  try {
    state.raw = new Uint8Array(await state.pdfFile.arrayBuffer());
    state.text = new TextDecoder('latin1').decode(state.raw);

    indexObjects(state.text);
    await expandObjectStreams();     // NEW: parse /ObjStm to resolve referenced arrays, ColorSpaces, etc.

    const items = await collectAllImages();
    if (!items.length) {
      showEmpty('No images found in this PDF.');
      finalizeStats();
      return;
    }
    await convertAllToPNGAndDedup(items);
    renderImages();
    enablePostProcessButtons();
    finalizeStats();
  } catch (err) {
    console.error(err);
    showEmpty('Failed to process PDF (corrupt or unsupported).');
    updateProgress(0, 'Error.');
  }
});

els.selectAllBtn.addEventListener('click', () => { for (const it of state.images) it.selected = true; renderImages(); });
els.deselectAllBtn.addEventListener('click', () => { for (const it of state.images) it.selected = false; renderImages(); });
els.defaultSortBtn.addEventListener('click', () => { state.sortMode = 'default'; sortImages(); renderImages(); });
els.smartSortBtn.addEventListener('click', () => { state.sortMode = 'smart'; sortImages(); renderImages(); });

/* ---------- Modal preview ---------- */
let modalCurrent = null;
function openModal(item){
  modalCurrent = item;
  els.modalImg.src = item.srcObjectUrl;
  els.modalTitle.textContent = `${item.name} ‚Äî ${item.width}√ó${item.height}px ‚Ä¢ ${item.mb.toFixed(2)} MB`;
  els.modal.classList.add('open');
  els.modal.setAttribute('aria-hidden','false');
}
function closeModal(){
  els.modal.classList.remove('open');
  els.modal.setAttribute('aria-hidden','true');
  els.modalImg.src = '';
  modalCurrent = null;
}
els.modalClose.addEventListener('click', closeModal);
els.modal.addEventListener('click', (e)=>{ if (e.target === els.modal) closeModal(); });
window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && els.modal.classList.contains('open')) closeModal(); });
els.modalDownload.addEventListener('click', ()=>{
  if (!modalCurrent) return;
  const a = document.createElement('a');
  a.href = modalCurrent.srcObjectUrl;
  a.download = modalCurrent.name;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
  a.remove();
});

/* ---------- UI helpers ---------- */
function resetUIForProcessing(){
  state.images = [];
  state.removedDuplicates = 0;
  state.sortMode = 'default';
  els.gallery.innerHTML = '';
  updateProgress(0, 'Preparing‚Ä¶');
  els.defaultSortBtn.disabled = true;
  els.smartSortBtn.disabled = true;
  els.selectAllBtn.disabled = true;
  els.deselectAllBtn.disabled = true;
  els.downloadSelectedZipBtn.disabled = true;
  els.downloadAllZipBtn.disabled = true;
  els.stats.textContent = '';
}
function enablePostProcessButtons(){
  els.defaultSortBtn.disabled = false;
  els.smartSortBtn.disabled = false;
  els.selectAllBtn.disabled = false;
  els.deselectAllBtn.disabled = false;
  els.downloadSelectedZipBtn.disabled = false;
  els.downloadAllZipBtn.disabled = false;
}
function showEmpty(msg){ els.gallery.innerHTML = `<div class="empty">${msg}</div>`; }
function updateProgress(pct, text){ els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`; els.progressText.textContent = text; }
function finalizeStats(){
  els.stats.innerHTML = `Images: <b>${state.images.length}</b> &nbsp; | &nbsp; Removed duplicates: <b>${state.removedDuplicates}</b>`;
}

/* ============================
   Balanced dictionary parsing
============================ */
function findBalancedDictRange(block, fromIdx=0){
  const n = block.length;
  let i = block.indexOf('<<', fromIdx);
  if (i < 0) return null;
  let depth = 0, j = i;
  let inStr = false, strParen = 0, inHexStr = false, inComment = false;
  while (j < n - 1){
    const a = block[j], b = block[j+1];
    if (!inStr && !inHexStr && a === '%' && !inComment) { inComment = true; j++; continue; }
    if (inComment) { if (a === '\n' || a === '\r') inComment = false; j++; continue; }

    if (!inHexStr && a === '('){ inStr = true; strParen = 1; j++; continue; }
    if (inStr){ if (a === '\\') { j += 2; continue; } if (a === '(') strParen++; if (a === ')'){ if (--strParen===0) inStr=false; } j++; continue; }

    if (!inHexStr && a === '<' && b !== '<'){ inHexStr = true; j++; continue; }
    if (inHexStr){ if (a === '>') inHexStr = false; j++; continue; }

    if (a === '<' && b === '<'){ depth++; j += 2; continue; }
    if (a === '>' && b === '>'){ depth--; j += 2; if (depth === 0) return [i, j]; continue; }
    j++;
  }
  return null;
}

/* ============================
   Index objects (top-level)
============================ */
function indexObjects(text){
  state.objects = [];
  state.objMap.clear();
  const reObj = /(\d+)\s+(\d+)\s+obj\b/g;
  let m;
  while ((m = reObj.exec(text)) !== null) {
    const obj = parseInt(m[1],10), gen = parseInt(m[2],10);
    const start = m.index;
    const endObjIdx = text.indexOf('endobj', start);
    if (endObjIdx === -1) break;
    const block = text.slice(start, endObjIdx + 6);

    const dictRange = findBalancedDictRange(block);
    let dictStr = '';
    let streamStart = -1, streamEnd = -1;
    if (dictRange){
      const [a,b] = dictRange;
      dictStr = block.slice(a+2, b-2);
      const streamIdx = block.indexOf('stream', b);
      if (streamIdx !== -1){
        let dataStart = streamIdx + 6;
        if (block[dataStart] === '\r' && block[dataStart+1] === '\n') dataStart += 2;
        else if (block[dataStart] === '\n') dataStart += 1;
        const absStart = start + dataStart;

        let length = pickLastInt(dictStr, 'Length');
        if (length == null) {
          const lenRef = pickRef(dictStr, 'Length');
          length = getObjectNumericValue(lenRef);
        }
        if (length != null && Number.isFinite(length) && length >= 0){
          streamStart = absStart;
          streamEnd = Math.min(absStart + length, state.raw.length);
        } else {
          const relEnd = block.indexOf('endstream', dataStart);
          if (relEnd !== -1) { streamStart = absStart; streamEnd = start + relEnd; }
        }
      }
    }

    const rec = { kind: 'normal', obj, gen, startIndex: start, endIndex: endObjIdx+6, dictRange, dictStr, streamStart, streamEnd };
    state.objMap.set(`${obj} ${gen}`, rec);
    state.objects.push(rec);
    reObj.lastIndex = endObjIdx + 6;
  }
}

/* ============================
   Object Streams (/ObjStm)
============================ */
async function expandObjectStreams(){
  // Find all /ObjStm, decode them, extract N embedded objects, and register them into objMap
  for (const rec of state.objects) {
    const d = rec.dictStr || '';
    if (!/\/Type\s*\/ObjStm\b/.test(d)) continue;
    // Decode the stream
    if (!(rec.streamStart >= 0 && rec.streamEnd > rec.streamStart)) continue;

    let data = state.raw.subarray(rec.streamStart, rec.streamEnd);
    let filters = pickArrayNames(d, 'Filter');
    if (!filters.length) { const single = pickName(d, 'Filter'); if (single) filters = [single]; }
    for (const f of (filters || [])) {
      if (/^ASCII85Decode$/i.test(f)) { data = ascii85DecodeToBytes(data); continue; }
      if (/^ASCIIHexDecode$/i.test(f)) { data = asciiHexDecodeToBytes(data); continue; }
      if (/^FlateDecode$/i.test(f)) { data = await inflateZlib(data); continue; }
      if (/^RunLengthDecode$/i.test(f)) { data = runLengthDecode(data); continue; }
      if (/^LZWDecode$/i.test(f)) { data = lzwDecode(data); continue; }
    }

    const N = pickLastInt(d, 'N') || 0;
    const First = pickLastInt(d, 'First') || 0;
    const header = new TextDecoder('latin1').decode(data.subarray(0, First));
    const tokens = header.trim().split(/\s+/).map(x => parseInt(x,10)).filter(x => Number.isFinite(x));
    if (tokens.length < 2*N) continue;

    const pairs = [];
    for (let i=0;i<N;i++) pairs.push({ obj: tokens[2*i], gen: 0, offset: tokens[2*i+1] });

    for (let i=0;i<pairs.length;i++){
      const cur = pairs[i], next = pairs[i+1];
      const start = First + cur.offset;
      const end = next ? First + next.offset : data.length;
      const content = new TextDecoder('latin1').decode(data.subarray(start, end)).trim();
      // Register as lightweight object (no separate stream; content is raw object content)
      const dictRange = findBalancedDictRange(content);
      let dictStr = '';
      let streamStart = -1, streamEnd = -1;
      if (dictRange){
        const [a,b] = dictRange;
        dictStr = content.slice(a+2, b-2);
        const sIdx = content.indexOf('stream', b);
        if (sIdx !== -1) {
          let ds = sIdx + 6;
          if (content[ds] === '\r' && content[ds+1] === '\n') ds+=2; else if (content[ds] === '\n') ds+=1;
          // We cannot rely on /Length for these, but usually object streams don't include sub-streams; still guard
          const relEnd = content.indexOf('endstream', ds);
          if (relEnd !== -1) { streamStart = ds; streamEnd = relEnd; } // relative to this content string; we won't use raw bytes here
        }
      }
      const orec = { kind:'objstm', obj: cur.obj, gen: cur.gen, content, dictStr, streamStart, streamEnd };
      state.objMap.set(`${cur.obj} ${cur.gen}`, orec);
    }
  }
}

/* ============================
   Small parsing helpers
============================ */
function pickLastInt(source, name){
  const re = new RegExp(`/${name}\\s+(\\d+)`, 'g');
  let m, val = null;
  while ((m = re.exec(source)) !== null) val = parseInt(m[1],10);
  return val;
}
function pickRef(source, name){
  const re = new RegExp(`/${name}\\s+(\\d+)\\s+(\\d+)\\s+R`);
  const m = re.exec(source);
  return m ? { obj: parseInt(m[1],10), gen: parseInt(m[2],10) } : null;
}
function pickArrayNames(source, key){
  const re = new RegExp(`/${key}\\s+\\[([^\\]]+)\\]`);
  const m = re.exec(source);
  if (!m) return [];
  return (m[1].match(/\/([A-Za-z0-9]+)/g) || []).map(s => s.slice(1));
}
function pickName(source, key){
  const re = new RegExp(`/${key}\\s+/([A-Za-z0-9]+)`);
  const m = re.exec(source);
  return m ? m[1] : null;
}

function getObjectBlock(ref){
  if (!ref) return null;
  const hit = state.objMap.get(`${ref.obj} ${ref.gen}`);
  return hit || null;
}
function getObjectText(ref){
  const hit = getObjectBlock(ref);
  if (!hit) return null;
  if (hit.kind === 'normal') {
    return state.text.slice(hit.startIndex, hit.endIndex);
  } else {
    return hit.content;
  }
}
function getObjectNumericValue(ref){
  const t = getObjectText(ref);
  if (!t) return null;
  const m = t.match(/(\d+)/);
  return m ? parseInt(m[1],10) : null;
}

/* ============================
   ColorSpace resolution
============================ */
// Finds /ColorSpace as name | ref | array; returns {type:'DeviceRGB'|'DeviceGray'|'DeviceCMYK'|'Indexed'|'ICCBased', base?, hival?, table?}
function resolveColorSpace(dictStr){
  // Try direct name
  let csName = pickName(dictStr, 'ColorSpace') || pickName(dictStr, 'CS');
  if (csName) {
    if (csName === 'RGB') csName = 'DeviceRGB';
    if (csName === 'G') csName = 'DeviceGray';
    if (/^Device(RGB|Gray|CMYK)$/.test(csName)) return { type: csName };
  }

  // Try array inline: /ColorSpace [ ... ]
  const arrayRange = findBracketRange(dictStr, 'ColorSpace') || findBracketRange(dictStr, 'CS');
  if (arrayRange) {
    const arr = dictStr.slice(arrayRange[0]+1, arrayRange[1]-1).trim();
    const info = parseColorSpaceArray(arr);
    if (info) return info;
  }

  // Try indirect reference: /ColorSpace n 0 R
  const csRef = pickRef(dictStr, 'ColorSpace') || pickRef(dictStr, 'CS');
  if (csRef) {
    const content = getObjectText(csRef);
    if (content) {
      // Might be an array object, e.g., " [/Indexed /DeviceRGB 255 13 0 R ] "
      const trimmed = content.trim();
      if (trimmed.startsWith('[')) {
        const inside = trimmed.slice(1, trimmed.lastIndexOf(']')).trim();
        const info = parseColorSpaceArray(inside);
        if (info) return info;
      } else {
        // Might be ICCBased array in object stream, e.g., "<<...>> stream (profile) endstream" with /N
        const dictR = findBalancedDictRange(trimmed);
        if (dictR) {
          const d = trimmed.slice(dictR[0]+2, dictR[1]-2);
          const N = pickLastInt(d, 'N') || 3;
          if (N === 1) return { type:'DeviceGray' };
          if (N === 3) return { type:'DeviceRGB' };
          if (N === 4) return { type:'DeviceCMYK' };
        }
      }
    }
  }

  // Fallback default RGB
  return { type: 'DeviceRGB' };
}

function parseColorSpaceArray(arrStr){
  // Tokenize simple: names (/Indexed, /ICCBased, /DeviceRGB ...), numbers, refs
  const toks = arrStr.match(/\/[A-Za-z0-9]+|\d+\s+\d+\s+R|\d+|<[^>]*>/g) || [];
  if (!toks.length) return null;

  if (toks[0] === '/ICCBased') {
    // [/ICCBased n 0 R]
    const refTok = toks[1] || '';
    const m = refTok.match(/(\d+)\s+(\d+)\s+R/);
    if (m) {
      const ref = { obj: parseInt(m[1],10), gen: parseInt(m[2],10) };
      const obj = getObjectBlock(ref);
      if (obj) {
        const d = obj.dictStr || '';
        const N = pickLastInt(d, 'N') || 3;
        if (N === 1) return { type:'DeviceGray' };
        if (N === 3) return { type:'DeviceRGB' };
        if (N === 4) return { type:'DeviceCMYK' };
      }
    }
    return { type:'DeviceRGB' }; // sensible fallback
  }

  if (toks[0] === '/Indexed') {
    // [/Indexed <base> <hival> <lookup>]
    // base can be /DeviceRGB or ICCBased/ref; lookup can be hex <...> or ref
    let base = 'DeviceRGB';
    // base in toks[1]
    if (toks[1] && toks[1].startsWith('/')) {
      const b = toks[1].slice(1);
      if (b === 'RGB') base = 'DeviceRGB';
      else if (b === 'G') base = 'DeviceGray';
      else base = b;
    } else if (toks[1] && /\d+\s+\d+\s+R/.test(toks[1])) {
      const m = toks[1].match(/(\d+)\s+(\d+)\s+R/);
      if (m) {
        const ref = { obj: parseInt(m[1],10), gen: parseInt(m[2],10) };
        const obj = getObjectBlock(ref);
        if (obj) {
          // If it's ICCBased array object, derive /N
          const t = getObjectText(ref) || '';
          if (t.trim().startsWith('[')) {
            const inner = t.trim().slice(1, t.trim().lastIndexOf(']')).trim();
            const cs = parseColorSpaceArray(inner);
            if (cs && (cs.type==='DeviceRGB' || cs.type==='DeviceGray' || cs.type==='DeviceCMYK')) base = cs.type;
          } else if (obj.dictStr) {
            const N = pickLastInt(obj.dictStr, 'N') || 3;
            base = (N===1)?'DeviceGray':(N===3)?'DeviceRGB':(N===4)?'DeviceCMYK':'DeviceRGB';
          }
        }
      }
    }
    const hival = toks[2] ? parseInt(toks[2],10) : 255;

    // lookup toks[3]
    let table = null;
    if (toks[3]) {
      if (/<[^>]*>/.test(toks[3])) {
        // Hex string lookup
        const hex = toks[3].replace(/[<>\s]/g,'');
        const out = new Uint8Array(hex.length/2);
        for (let i=0;i<out.length;i++) out[i] = parseInt(hex.substr(i*2,2),16)&255;
        table = out;
      } else if (/\d+\s+\d+\s+R/.test(toks[3])) {
        const m2 = toks[3].match(/(\d+)\s+(\d+)\s+R/);
        if (m2) {
          const ref = { obj: parseInt(m2[1],10), gen: parseInt(m2[2],10) };
          const obj = getObjectBlock(ref);
          if (obj && obj.kind === 'normal' && obj.streamStart >= 0) {
            const bytes = state.raw.subarray(obj.streamStart, obj.streamEnd);
            let data = bytes;
            let filters = pickArrayNames(obj.dictStr||'', 'Filter');
            if (!filters.length) { const single = pickName(obj.dictStr||'', 'Filter'); if (single) filters = [single]; }
            for (const f of (filters||[])) {
              if (/^ASCII85Decode$/i.test(f)) { data = ascii85DecodeToBytes(data); continue; }
              if (/^ASCIIHexDecode$/i.test(f)) { data = asciiHexDecodeToBytes(data); continue; }
              if (/^FlateDecode$/i.test(f)) { data = awaitInflateSync(data); continue; }
              if (/^RunLengthDecode$/i.test(f)) { data = runLengthDecode(data); continue; }
              if (/^LZWDecode$/i.test(f)) { data = lzwDecode(data); continue; }
            }
            table = data;
          }
        }
      }
    }
    return { type:'Indexed', base, hival, table };
  }

  // Device*
  if (toks[0] && toks[0].startsWith('/Device')) {
    const t = toks[0].slice(1);
    if (/^Device(RGB|Gray|CMYK)$/.test(t)) return { type: t };
  }
  return null;
}

function findBracketRange(dictStr, key){
  // Find /key [ .... ] with nested brackets (rare), returns [startIdx, endIdx) of whole [..]
  const re = new RegExp(`/${key}\\s*\\[`, 'g');
  const m = re.exec(dictStr);
  if (!m) return null;
  let i = m.index + m[0].length - 1; // at '['
  let depth = 0;
  let j = i;
  while (j < dictStr.length){
    if (dictStr[j] === '[') depth++;
    else if (dictStr[j] === ']'){ depth--; if (depth===0) return [i, j+1]; }
    j++;
  }
  return null;
}

/* ============================
   Collect images (embedded + inline)
============================ */
async function collectAllImages(){
  const embedded = [];
  const inlineCandidates = [];

  for (const rec of state.objMap.values()) {
    if (rec.kind !== 'normal') continue; // embedded images are normal top-level objects (streams)
    const dict = rec.dictStr || '';
    const hasStream = rec.streamStart >= 0 && rec.streamEnd > rec.streamStart;
    if (!hasStream) { continue; }

    if (/\/Subtype\s*\/Image\b/.test(dict)) {
      const width  = pickLastInt(dict, 'Width');
      const height = pickLastInt(dict, 'Height');
      const bits   = pickLastInt(dict, 'BitsPerComponent') || 8;

      const csInfo = resolveColorSpace(dict); // NEW: robust CS parsing
      if (!csInfo) continue;

      let filters = pickArrayNames(dict, 'Filter');
      if (!filters.length) { const single = pickName(dict, 'Filter'); if (single) filters = [single]; }

      const predictor = pickLastInt(dict, 'Predictor') || 1;
      const columns = pickLastInt(dict, 'Columns') || width;

      const bytes = state.raw.subarray(rec.streamStart, rec.streamEnd);
      embedded.push({ kind:'embedded', width, height, bits, csInfo, filters, predictor, columns, bytes });
    } else {
      inlineCandidates.push(rec);
    }
  }

  // Inline images from decoded content streams
  const inlineFound = [];
  for (const rec of inlineCandidates) {
    let data = state.raw.subarray(rec.streamStart, rec.streamEnd);
    const dict = rec.dictStr || '';
    let filters = pickArrayNames(dict, 'Filter');
    if (!filters.length) { const single = pickName(dict, 'Filter'); if (single) filters = [single]; }
    for (const f of (filters || [])) {
      if (/^ASCII85Decode$/i.test(f)) { data = ascii85DecodeToBytes(data); continue; }
      if (/^ASCIIHexDecode$/i.test(f)) { data = asciiHexDecodeToBytes(data); continue; }
      if (/^FlateDecode$/i.test(f)) { data = await inflateZlib(data); continue; }
      if (/^RunLengthDecode$/i.test(f)) { data = runLengthDecode(data); continue; }
      if (/^LZWDecode$/i.test(f)) { data = lzwDecode(data); continue; }
    }
    const inlines = extractInlineImagesFromContent(data);
    inlineFound.push(...inlines);
  }

  return embedded.concat(inlineFound);
}

/* ============================
   Inline image parser (BI/ID/EI)
============================ */
function extractInlineImagesFromContent(u8){
  const isWs = b => b===9||b===10||b===12||b===13||b===32;
  const out = [];
  let i = 0, n = u8.length;

  while (i < n - 3) {
    if (u8[i]===0x42 && u8[i+1]===0x49 && (i===0 || isWs(u8[i-1])) && isWs(u8[i+2])) { // 'BI'
      i += 2; while (i<n && isWs(u8[i])) i++;

      const dictStart = i;
      let idPos = -1;
      for (let j=i; j<n-3; j++){
        if (isWs(u8[j]) && u8[j+1]===0x49 && u8[j+2]===0x44 && isWs(u8[j+3])) { idPos = j+1; break; } // ' ID '
      }
      if (idPos === -1) break;

      const dictBytes = u8.subarray(dictStart, idPos-1);
      i = idPos + 2;
      if (i<n && isWs(u8[i])) i++;

      const dataStart = i;
      let dataEnd = -1;
      for (let j=i; j<n-3; j++){
        if (isWs(u8[j]) && u8[j+1]===0x45 && u8[j+2]===0x49 && (j+3>=n || isWs(u8[j+3]))) { dataEnd = j; break; } // ' EI'
      }
      if (dataEnd === -1) break;

      const dataBytes = u8.subarray(dataStart, dataEnd);
      i = dataEnd + 3;

      const dictStr = new TextDecoder('latin1').decode(dictBytes);

      const width  = pickLastInt(dictStr, 'W') || pickLastInt(dictStr, 'Width');
      const height = pickLastInt(dictStr, 'H') || pickLastInt(dictStr, 'Height');
      const bits   = pickLastInt(dictStr, 'BPC') || pickLastInt(dictStr, 'BitsPerComponent') || 8;

      const csInfo = resolveColorSpace(dictStr);

      let filters = pickArrayNames(dictStr, 'F') || pickArrayNames(dictStr, 'Filter');
      if (!filters.length) {
        const singleF = pickName(dictStr, 'F') || pickName(dictStr, 'Filter');
        if (singleF) filters = [singleF];
      }
      const predictor = pickLastInt(dictStr, 'Predictor') || 1;
      const columns = pickLastInt(dictStr, 'Columns') || width;

      out.push({ kind:'inline', width, height, bits, csInfo, filters, predictor, columns, bytes: dataBytes });
      continue;
    }
    i++;
  }
  return out;
}

/* ============================
   Filter decoders
============================ */
function ascii85DecodeToBytes(u8){ const s = new TextDecoder('ascii').decode(u8); return ascii85DecodeString(s); }
function ascii85DecodeString(str){
  const s = str.replace(/<~/g,'').replace(/~>/g,'').replace(/\s+/g,''); const out = []; let group = [];
  for (let i=0;i<s.length;i++){
    const c = s[i];
    if (c==='z' && group.length===0){ out.push(0,0,0,0); continue; }
    const code = s.charCodeAt(i);
    if (code < 33 || code > 117) continue;
    group.push(code - 33);
    if (group.length===5){
      let v=0; for (let j=0;j<5;j++) v = v*85 + group[j];
      out.push((v>>>24)&255, (v>>>16)&255, (v>>>8)&255, v&255);
      group.length=0;
    }
  }
  if (group.length>0){
    for (let k=group.length; k<5; k++) group.push(84);
    let v=0; for (let j=0;j<5;j++) v = v*85 + group[j];
    for (let j=0;j<group.length-1;j++) out.push((v >>> (24 - 8*j)) & 255);
  }
  return new Uint8Array(out);
}
function asciiHexDecodeToBytes(u8){
  let s = new TextDecoder('ascii').decode(u8);
  const end = s.indexOf('>'); if (end !== -1) s = s.slice(0,end);
  s = s.replace(/\s+/g,''); if (s.length % 2 === 1) s += '0';
  const out = new Uint8Array(s.length/2);
  for (let i=0;i<s.length;i+=2) out[i/2] = parseInt(s.substr(i,2),16) & 255;
  return out;
}
async function inflateZlib(u8){
  if ('DecompressionStream' in window) {
    const ds = new DecompressionStream('deflate');
    const inStream = new Response(new Blob([u8])).body;
    const outStream = inStream.pipeThrough(ds);
    const out = await new Response(outStream).arrayBuffer();
    return new Uint8Array(out);
  } else { throw new Error('DecompressionStream unsupported'); }
}
// sync deflate used for small CS lookup; falls back to async inflateZlib if not available
function awaitInflateSync(u8){ throw new Error('Sync inflate not available; please use inflateZlib'); }
function runLengthDecode(u8){
  const out = [];
  for (let i=0;i<u8.length;){
    const n = u8[i++]; // 0..255
    if (n === 128) break; // EOD
    if (n < 128) {
      const count = n + 1;
      for (let k=0;k<count;k++) out.push(u8[i+k]);
      i += count;
    } else { // 129..255
      const count = 257 - n;
      const b = u8[i++]; for (let k=0;k<count;k++) out.push(b);
    }
  }
  return new Uint8Array(out);
}
/* ---- LZWDecode (PDF variant) ---- */
function lzwDecode(data){
  let pos = 0, bitPos = 0;
  function readBits(n){
    let val = 0;
    for (let i=0;i<n;i++){
      if (pos >= data.length) return null;
      const byte = data[pos];
      val = (val << 1) | ((byte >> (7 - bitPos)) & 1);
      bitPos++;
      if (bitPos === 8){ bitPos = 0; pos++; }
    }
    return val;
  }
  const CLEAR=256, EOD=257;
  let codeSize=9, dict=[], prev=null, out=[];
  for (let i=0;i<256;i++) dict[i]=new Uint8Array([i]);
  dict[CLEAR]=dict[EOD]=null;
  function readCode(n){ let v=0; for (let i=0;i<n;i++){ const b=readBits(1); if (b===null) return null; v=(v<<1)|b; } return v; }
  function concat(a,b){ const r=new Uint8Array(a.length+b.length); r.set(a); r.set(b,a.length); return r; }

  while (true){
    let code = readCode(codeSize); if (code===null) break;
    if (code===CLEAR){ dict=[]; for (let i=0;i<256;i++) dict[i]=new Uint8Array([i]); dict[CLEAR]=dict[EOD]=null; codeSize=9; prev=null; continue; }
    if (code===EOD) break;
    let entry;
    if (dict[code]) entry=dict[code];
    else if (prev!=null) entry=concat(dict[prev], new Uint8Array([dict[prev][0]]));
    else entry = new Uint8Array([code]);
    out.push(...entry);
    if (prev!=null) dict.push(concat(dict[prev], new Uint8Array([entry[0]])));
    prev = code;
    if (dict.length === (1<<codeSize) && codeSize<12) codeSize++;
  }
  return new Uint8Array(out);
}

/* ============================
   Raster ‚Üí RGBA ‚Üí PNG
============================ */
async function convertAllToPNGAndDedup(items){
  const total = items.length;
  const seen = new Set();
  const results = [];
  const base = state.pdfNameBase;

  for (let idx=0; idx<total; idx++){
    updateProgress(Math.round((idx/Math.max(1,total))*100), `Processing image ${idx+1}/${total}‚Ä¶`);
    const it = items[idx];
    try {
      const pngBlob = await convertOneToPNG(it);
      if (!pngBlob) continue;

      const ab = await pngBlob.arrayBuffer();
      const hash = await sha256Hex(new Uint8Array(ab));
      if (seen.has(hash)) { state.removedDuplicates++; continue; }
      seen.add(hash);

      const { w, h } = await getImageSizeFromBlob(pngBlob, it.width, it.height);
      const url = URL.createObjectURL(pngBlob);
      const name = `${base}_img${results.length+1}.png`;

      results.push({
        id: 'img'+(results.length+1),
        pngBlob, hashHex: hash,
        width: w, height: h,
        mb: ab.byteLength/(1024*1024),
        name,
        selected: false,
        srcObjectUrl: url
      });
    } catch (e) {
      console.warn('Skipping image due to error', e);
    }
  }
  updateProgress(100, `Done (${results.length} images).`);
  state.images = results;
}

async function convertOneToPNG(item){
  let data = item.bytes;
  const filters = (item.filters && item.filters.length) ? item.filters.slice() : [];

  if (!filters.length) return rasterToPNG(item, data);

  for (let i=0;i<filters.length;i++){
    const f = filters[i];
    if (/^ASCII85Decode$/i.test(f)) { data = ascii85DecodeToBytes(data); continue; }
    if (/^ASCIIHexDecode$/i.test(f)) { data = asciiHexDecodeToBytes(data); continue; }
    if (/^FlateDecode$/i.test(f)) { data = await inflateZlib(data); if (i===filters.length-1) return rasterToPNG(item, data); continue; }
    if (/^RunLengthDecode$/i.test(f)) { data = runLengthDecode(data); if (i===filters.length-1) return rasterToPNG(item, data); continue; }
    if (/^LZWDecode$/i.test(f)) { data = lzwDecode(data); if (i===filters.length-1) return rasterToPNG(item, data); continue; }
    if (/^DCTDecode$/i.test(f)) { return jpegToPNG(data, item.width, item.height); }
    if (/^JPXDecode$/i.test(f)) { return jpxToPNG(data, item.width, item.height); }
    console.warn('Unsupported filter:', f); return null;
  }
  return rasterToPNG(item, data);
}

async function jpegToPNG(u8, hintW, hintH){
  const blob = new Blob([u8], { type: 'image/jpeg' });
  const { canvas, img } = await drawToCanvas(blob, hintW, hintH);
  const png = await canvasToPNG(canvas);
  try { URL.revokeObjectURL(img.src); } catch {}
  return png;
}
async function jpxToPNG(u8, hintW, hintH){
  const blob = new Blob([u8], { type: 'image/jp2' });
  try {
    const { canvas, img } = await drawToCanvas(blob, hintW, hintH);
    const png = await canvasToPNG(canvas);
    try { URL.revokeObjectURL(img.src); } catch {}
    return png;
  } catch {
    console.warn('JPEG2000 not supported by this browser.'); return null;
  }
}

async function rasterToPNG(item, raw){
  const { width, height, bits, csInfo, predictor, columns } = item;
  if (bits !== 8) { console.warn('Only 8 bpc supported for raw; got', bits); return null; }

  // Components for predictor phase (pre-color-mapping)
  let compsPredictor;
  switch (csInfo.type) {
    case 'DeviceRGB': compsPredictor = 3; break;
    case 'DeviceGray': compsPredictor = 1; break;
    case 'DeviceCMYK': compsPredictor = 4; break;
    case 'Indexed': compsPredictor = 1; break;
    default: console.warn('Unsupported ColorSpace', csInfo); return null;
  }

  let pixels; // bytes after predictor undo, per-pixel components = compsPredictor
  if (predictor === 1) {
    const expected = width * height * compsPredictor;
    if (raw.length !== expected) { console.warn('Raw length mismatch; expected', expected, 'got', raw.length); return null; }
    pixels = raw;
  } else if (predictor >= 10 && predictor <= 15) {
    const rowBytes = (columns || width) * compsPredictor;
    const stride = 1 + rowBytes;
    if (raw.length !== stride * height) {
      const altRowBytes = width * compsPredictor;
      const altStride = 1 + altRowBytes;
      if (raw.length !== altStride * height) { console.warn('Predictor size mismatch'); return null; }
      pixels = undoPNGPrediction(raw, altRowBytes, height, compsPredictor);
    } else {
      pixels = undoPNGPrediction(raw, rowBytes, height, compsPredictor);
    }
  } else {
    console.warn('Unsupported Predictor:', predictor); return null;
  }

  // Map to RGBA
  let rgba = new Uint8ClampedArray(width * height * 4);
  if (csInfo.type === 'DeviceRGB') {
    let si=0, di=0, n=width*height; for (let i=0;i<n;i++){ rgba[di++]=pixels[si++]; rgba[di++]=pixels[si++]; rgba[di++]=pixels[si++]; rgba[di++]=255; }
  } else if (csInfo.type === 'DeviceGray') {
    let si=0, di=0, n=width*height; for (let i=0;i<n;i++){ const v=pixels[si++]; rgba[di++]=v; rgba[di++]=v; rgba[di++]=v; rgba[di++]=255; }
  } else if (csInfo.type === 'DeviceCMYK') {
    let si=0, di=0, n=width*height;
    for (let i=0;i<n;i++){
      const C=pixels[si++]/255, M=pixels[si++]/255, Y=pixels[si++]/255, K=pixels[si++]/255;
      // Profileless conversion (common heuristic)
      const R = 255 * (1 - Math.min(1, C*(1-K) + K));
      const G = 255 * (1 - Math.min(1, M*(1-K) + K));
      const B = 255 * (1 - Math.min(1, Y*(1-K) + K));
      rgba[di++]=R|0; rgba[di++]=G|0; rgba[di++]=B|0; rgba[di++]=255;
    }
  } else if (csInfo.type === 'Indexed') {
    const base = csInfo.base || 'DeviceRGB';
    const hival = (csInfo.hival != null) ? csInfo.hival : 255;
    const table = csInfo.table || new Uint8Array(0);
    let di=0;
    if (base === 'DeviceRGB') {
      for (let i=0;i<width*height;i++){
        const idx = pixels[i];
        const ti = Math.min(idx, hival) * 3;
        const r = table[ti] || 0, g = table[ti+1] || 0, b = table[ti+2] || 0;
        rgba[di++]=r; rgba[di++]=g; rgba[di++]=b; rgba[di++]=255;
      }
    } else if (base === 'DeviceGray') {
      for (let i=0;i<width*height;i++){
        const idx = pixels[i];
        const v = table[Math.min(idx, hival)] || 0;
        rgba[di++]=v; rgba[di++]=v; rgba[di++]=v; rgba[di++]=255;
      }
    } else if (base === 'DeviceCMYK') {
      for (let i=0;i<width*height;i++){
        const idx = pixels[i];
        const ti = Math.min(idx, hival) * 4;
        const C=(table[ti]||0)/255, M=(table[ti+1]||0)/255, Y=(table[ti+2]||0)/255, K=(table[ti+3]||0)/255;
        const R = 255 * (1 - Math.min(1, C*(1-K) + K));
        const G = 255 * (1 - Math.min(1, M*(1-K) + K));
        const B = 255 * (1 - Math.min(1, Y*(1-K) + K));
        rgba[di++]=R|0; rgba[di++]=G|0; rgba[di++]=B|0; rgba[di++]=255;
      }
    } else {
      console.warn('Indexed base not supported:', base); return null;
    }
  } else {
    console.warn('Unknown ColorSpace info:', csInfo); return null;
  }

  // Canvas ‚Üí PNG
  const canvas = document.createElement('canvas');
  canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imgData = new ImageData(rgba, width, height);
  ctx.putImageData(imgData, 0, 0);
  return canvasToPNG(canvas);
}

/* ============================
   Canvas helpers & PNG export
============================ */
function drawToCanvas(blob, hintW, hintH){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const w = hintW || img.naturalWidth || img.width;
      const h = hintH || img.naturalHeight || img.height;
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha: true });
      ctx.drawImage(img, 0, 0, w, h);
      resolve({ canvas, img });
    };
    img.onerror = () => reject(new Error('Image decode failed'));
    img.src = URL.createObjectURL(blob);
  });
}
function canvasToPNG(canvas){
  return new Promise((resolve) => { canvas.toBlob(b => resolve(b), 'image/png', 1.0); });
}
async function getImageSizeFromBlob(blob, fallbackW, fallbackH){
  if ('createImageBitmap' in window) {
    try { const bmp = await createImageBitmap(blob); const w=bmp.width, h=bmp.height; bmp.close(); return { w, h }; } catch {}
  }
  return new Promise((resolve) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => { const w=img.naturalWidth||fallbackW||0, h=img.naturalHeight||fallbackH||0; URL.revokeObjectURL(url); resolve({ w, h }); };
    img.onerror = () => { URL.revokeObjectURL(url); resolve({ w: fallbackW||0, h: fallbackH||0 }); };
    img.src = url;
  });
}

/* ============================
   SHA-256 & ZIP (store method)
============================ */
async function sha256Hex(u8){ const buf = await crypto.subtle.digest('SHA-256', u8); return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join(''); }

const CRC32_TABLE = (() => { let c, t=[]; for (let n=0;n<256;n++){ c=n; for (let k=0;k<8;k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); t[n]=c>>>0; } return t; })();
function crc32(u8){ let c=0^(-1); for (let i=0;i<u8.length;i++) c=(c>>>8)^CRC32_TABLE[(c^u8[i])&0xFF]; return (c^(-1))>>>0; }
function strToU8(s){ const u = new Uint8Array(s.length); for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i) & 0xFF; return u; }
function u16(v){ return new Uint8Array([v & 0xFF, (v>>8) & 0FF]); } // corrected below (typo fix)
</script>
<script>
/* Tiny fix for u16 typo (split to avoid minifier confusion) */
function u16(v){ return new Uint8Array([v & 0xFF, (v>>8) & 0xFF]); }
function u32(v){ return new Uint8Array([v & 0xFF, (v>>8)&0xFF, (v>>16)&0xFF, (v>>24)&0xFF]); }
function toDosTime(d){ let h=d.getHours(), m=d.getMinutes(), s=Math.floor(d.getSeconds()/2); return (h<<11)|(m<<5)|s; }
function toDosDate(d){ let y=Math.max(1980,d.getFullYear())-1980, mon=d.getMonth()+1, day=d.getDate(); return (y<<9)|(mon<<5)|day; }

async function buildZipFromImages(files){
  const fileRecords = [];
  const localParts = [];
  let localOffset = 0;

  const now = new Date(), dt=toDosTime(now), dd=toDosDate(now);

  for (const f of files) {
    const ab = await f.pngBlob.arrayBuffer(); const u8 = new Uint8Array(ab);
    const c = crc32(u8), nameU8 = strToU8(f.name);
    const LFH = [ u32(0x04034b50), u16(20), u16(0), u16(0), u16(dt), u16(dd), u32(c), u32(u8.length), u32(u8.length), u16(nameU8.length), u16(0), nameU8, u8 ];
    const lfhSize = LFH.reduce((s,p)=> s+p.length, 0); localParts.push(...LFH);
    fileRecords.push({ nameU8, crc:c, size:u8.length, comp:u8.length, off: localOffset, dt, dd });
    localOffset += lfhSize;
  }

  const cdParts = []; let cdSize = 0;
  for (const r of fileRecords){
    const CDFH = [ u32(0x02014b50), u16(20), u16(20), u16(0), u16(0), u16(r.dt), u16(r.dd), u32(r.crc), u32(r.comp), u32(r.size),
                   u16(r.nameU8.length), u16(0), u16(0), u16(0), u16(0), u32(0), u32(r.off), r.nameU8 ];
    const size = CDFH.reduce((s,p)=> s+p.length, 0); cdSize += size; cdParts.push(...CDFH);
  }
  const cdOffset = localOffset;
  const EOCD = [ u32(0x06054b50), u16(0), u16(0), u16(fileRecords.length), u16(fileRecords.length), u32(cdSize), u32(cdOffset), u16(0) ];
  const total = localOffset + cdSize + EOCD.reduce((s,p)=> s+p.length, 0);
  const out = new Uint8Array(total); let pos=0;
  for (const p of localParts){ out.set(p, pos); pos += p.length; }
  for (const p of cdParts){ out.set(p, pos); pos += p.length; }
  for (const p of EOCD){ out.set(p, pos); pos += p.length; }
  return new Blob([out], { type: 'application/zip' });
}

/* ============================
   Render UI
============================ */
function renderImages(){
  sortImages();
  if (!state.images.length) { showEmpty('No images found after processing.'); return; }
  const frag = document.createDocumentFragment();
  for (const it of state.images) frag.appendChild(renderCard(it));
  els.gallery.innerHTML = ''; els.gallery.appendChild(frag);
  els.defaultSortBtn.disabled = false;
  els.smartSortBtn.disabled = false;
  els.selectAllBtn.disabled = false;
  els.deselectAllBtn.disabled = false;
  els.downloadSelectedZipBtn.disabled = false;
  els.downloadAllZipBtn.disabled = false;
}
function renderCard(it){
  const card = document.createElement('div'); card.className = 'card';
  const img = document.createElement('img'); img.className='thumb'; img.src=it.srcObjectUrl; img.alt=it.name; img.loading='lazy';
  img.title='Click to preview'; img.addEventListener('click', ()=> openModal(it));
  card.appendChild(img);

  const meta = document.createElement('div'); meta.className='meta';
  const row1 = document.createElement('div'); row1.className='row';
  const label = document.createElement('label'); label.style.display='flex'; label.style.alignItems='center'; label.style.gap='8px';
  const cb = document.createElement('input'); cb.type='checkbox'; cb.checked=!!it.selected;
  const name = document.createElement('span'); name.className='badge'; name.textContent = it.name;
  label.appendChild(cb); label.appendChild(name);
  const dl = document.createElement('button'); dl.textContent='Download'; dl.style.padding='6px 10px';
  dl.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=it.srcObjectUrl; a.download=it.name; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove(); });
  row1.appendChild(label); row1.appendChild(dl); meta.appendChild(row1);

  const row2 = document.createElement('div'); row2.className='row';
  const dims = document.createElement('div'); dims.className='small'; dims.textContent = `Dimensions: ${it.width}√ó${it.height}px`;
  const size = document.createElement('div'); size.className='small'; size.textContent = `Size: ${it.mb.toFixed(2)} MB`;
  row2.appendChild(dims); row2.appendChild(size); meta.appendChild(row2);

  const sel = document.createElement('div'); sel.className='small'; sel.innerHTML = it.selected ? `<span class="ok">Selected</span>` : `Not selected`;
  cb.addEventListener('change', ()=>{ it.selected = cb.checked; sel.innerHTML = cb.checked ? `<span class="ok">Selected</span>` : `Not selected`; });
  meta.appendChild(sel);

  card.appendChild(meta);
  return card;
}
function sortImages(){
  const arr = state.images; if (!arr.length) return;
  if (state.sortMode === 'default') arr.sort((a,b)=>(b.width*b.height)-(a.width*a.height));
  else {
    const areas = arr.map(i=>i.width*i.height), sizes = arr.map(i=>i.mb);
    const avgA = (areas.reduce((s,v)=>s+v,0)/areas.length)||1; const avgS = (sizes.reduce((s,v)=>s+v,0)/sizes.length)||1;
    for (const it of arr){ const area=it.width*it.height; const wA=area/avgA, wS=it.mb/avgS; it._smartScore=0.6*wA+0.4*wS; }
    arr.sort((a,b)=>b._smartScore-a._smartScore);
  }
}

/* ============================
   Downloads
============================ */
els.downloadSelectedZipBtn.addEventListener('click', async () => {
  const chosen = state.images.filter(i=>i.selected);
  if (!chosen.length) { alert('No images selected.'); return; }
  const zip = await buildZipFromImages(chosen);
  const a = document.createElement('a'); a.href = URL.createObjectURL(zip); a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove();
});
els.downloadAllZipBtn.addEventListener('click', async () => {
  const chosen = state.images.slice();
  if (!chosen.length) { alert('Nothing to download.'); return; }
  const zip = await buildZipFromImages(chosen);
  const a = document.createElement('a'); a.href = URL.createObjectURL(zip); a.download = `${state.pdfNameBase}_images.zip`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); a.remove();
});
</script>
</body>
</html>
